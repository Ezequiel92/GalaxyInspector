var documenterSearchIndex = {"docs":
[{"location":"api/analysis/data_analysis/#Data-analysis-functions","page":"Data analysis functions","title":"Data analysis functions","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\nThese functions read the data generated by the data acquisition functions, and produce the values that will be plotted.","category":"section"},{"location":"api/analysis/data_analysis/#Signature-for-the-[plotSnapshot](@ref)-function","page":"Data analysis functions","title":"Signature for the plotSnapshot function","text":"  da_function(data_dict, args...; kwargs...) -> (processed_data, ...)\n\nwhere:\n\ndata_dict::Dict\nprocessed_data::Union{VecOrMat{<:Number},Nothing}\n\nA data analysis functions for the pipeline plotSnapshot must take a dictionary with the following shape:\n\n:sim_data          -> ::Simulation (see Simulation).\n:snap_data         -> ::Snapshot (see Snapshot).\n:gc_data           -> ::GroupCatalog (see GroupCatalog).\ncell/particle type -> (block name -> data for block name, block name -> data of block name, ...).\ncell/particle type -> (block name -> data for block name, block name -> data of block name, ...).\ncell/particle type -> (block name -> data for block name, block name -> data of block name, ...).\n...\ngroupcat type      -> (block name -> data for block name, block name -> data of block name, ...).\ngroupcat type      -> (block name -> data for block name, block name -> data of block name, ...).\ngroupcat type      -> (block name -> data for block name, block name -> data of block name, ...).\n...\n\nand return one or more vectors or matrices with the processed data (see plotSnapshot for specifics). It should return nothing if the input data has some problem that prevents computation (e.g. it is empty).","category":"section"},{"location":"api/analysis/data_analysis/#Signature-for-the-[plotTimeSeries](@ref)-function","page":"Data analysis functions","title":"Signature for the plotTimeSeries function","text":"  da_function(sim_data, args...; kw_args...) -> (processed_data_x, processed_data_y)\n\nwhere:\n\nsim_data::Simulation, see Simulation\nprocessed_data_x::Vector{<:Number}\nprocessed_data_y::Vector{<:Number}\n\nA data analysis functions for the pipeline plotTimeSeries must take a Simulation struct, and return two vectors. It should return nothing if the input data has some problem that prevents computation (e.g. is empty).\n\n","category":"section"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daBandProfile-Tuple{Dict, Symbol, GalaxyInspector.CircularGrid}","page":"Data analysis functions","title":"GalaxyInspector.daBandProfile","text":"daBandProfile(\n    data_dict::Dict,\n    quantity::Symbol,\n    grid::CircularGrid;\n    <keyword arguments>\n)::Union{\n    Tuple{Vector{<:Unitful.Length},Vector{<:Number},Vector{<:Number},Vector{<:Number}},\n    Tuple{Vector{<:Unitful.Length},Vector{<:Number},Vector{<:Number}},\n    Nothing,\n}\n\nCompute a profile with uncertainty bands.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nquantity::Symbol: Target quantity. It can be any of the quantities valid for scatterQty.\ngrid::CircularGrid: Circular grid.\nflat::Bool=true: If the profile will be 2D (rings), or 3D (spherical shells).\ndensity::Bool=false: If the profile will be of the density of quantity.\nylog::Bool=false: If true, returns the profile of log_10(quantity).\nerror_bar::Bool=false: If the returned values will be compatible with band! (default) or with errorbars!.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with three elements if error_bar = false:\nA vector with the position of each ring or spherical shells.\nA vector with the \"low\" value of quantity in each each ring or spherical shells.\nA vector with the \"high\" value of quantity in each each ring or spherical shells.\nOr a tuple with four elements if error_bar = true:\nA vector with the position of each ring or spherical shells.\nA vector with the central value of quantity in each each ring or spherical shells.\nA vector with the \"low\" error of quantity in each each ring or spherical shells.\nA vector with the \"high\" error of quantity in each each ring or spherical shells.\nIt returns nothing if any of the necessary quantities are missing.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daBarGasFractions-Tuple{Dict, Symbol, GalaxyInspector.LinearGrid}","page":"Data analysis functions","title":"GalaxyInspector.daBarGasFractions","text":"daBarGasFractions(\n    data_dict::Dict,\n    quantity::Symbol,\n    grid::LinearGrid;\n    <keyword arguments>\n)::Union{NTuple{2,Vector{<:Number}},Nothing}\n\nCompute a bar plot, where the bins are for a given gas quantity and the heights are the corresponding gas fractions.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nquantity::Symbol: Target quantity. It can be any of the quantities valid for scatterQty with the cell/particle type :gas.\ngrid::LinearGrid: Linear grid.\ncomponents::Vector{Symbol}=[:ode_ionized, :ode_atomic, :ode_molecular]: List of gas components to be considered. The fractions will be normalized to this list of components. See COMPONENTS for options.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with the two elements required by barplot! from Makie:\nA vector with the index of each bar.\nA vector with the height of each bar.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daCPUtxt-Tuple{GalaxyInspector.Simulation, String, Symbol, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daCPUtxt","text":"daCPUtxt(\n    sim_data::Simulation,\n    target::String,\n    x_quantity::Symbol,\n    y_quantity::Symbol;\n    <keyword arguments>\n)::NTuple{2,Vector{<:Number}}\n\nCompute the evolution of a measured quantity in the cpu.txt file, for a given target process.\n\nArguments\n\nsim_data::Simulation: The Simulation struct for the target simulation.\ntarget::String: Target process.\nx_quantity::Symbol: Quantity for the x axis. The options are:\n:time_step              -> Time step.\n:physical_time          -> Physical time since the Big Bang.\n:clock_time_s           -> Clock time duration of the time step in seconds.\n:clock_time_percent     -> Clock time duration of the time step as a percentage.\n:tot_clock_time_s       -> Total clock time in seconds.\n:tot_clock_time_percent -> Total clock time as a percentage.\ny_quantity::Symbol: Quantity for the y axis. The options are:\n:time_step              -> Time step.\n:physical_time          -> Physical time since the Big Bang.\n:clock_time_s           -> Clock time duration of the time step in seconds.\n:clock_time_percent     -> Clock time duration of the time step as a percentage.\n:tot_clock_time_s       -> Total clock time in seconds.\n:tot_clock_time_percent -> Total clock time as a percentage.\ny_log::Union{Unitful.Units,Nothing}=nothing: Target unit for y_quantity, if you want to apply log_10 to the y_quantity. If set to nothing, the data from cpu.txt is left as is.\nsmooth::Int=0: The result will be smoothed out using smooth bins. Set it to 0 if you want no smoothing.\n\nReturns\n\nA Tuple with two elements:\nA Vector with the time series of x_quantity.\nA Vector with the time series of y_quantity.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daClumpingFactor-Tuple{Dict, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daClumpingFactor","text":"daClumpingFactor(\n    data_dict::Dict,\n    component::Symbol;\n    <keyword arguments>\n)::Tuple{Vector{<:Number},Vector{Float64}}\n\nCompute the clumping factor (C_rho), for the number density of component, at different volume scales.\n\nC_rho = fraclangle n^2 ranglelangle n rangle^2  \n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS with cell/partcile type :gas.\nn_neighbors::Int=32: Number of neighbors.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\nx_log::Union{Unitful.Units,Nothing}=nothing: Target unit for the volume, if you want to apply log_10 to the volume. If set to nothing, the volume is left as is.\ny_log::Union{Unitful.Units,Nothing}=nothing: Target unit for the clumping factor, if you want to apply log_10 to the clumping factor. If set tonothing`, the clumping factor is left as is.\n\nReturns\n\nA tuple with two elements:\nA vector with the the volumes.\nA vector with the clumping factors.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daClumpingFactorProfile-Tuple{Dict, Symbol, GalaxyInspector.CircularGrid}","page":"Data analysis functions","title":"GalaxyInspector.daClumpingFactorProfile","text":"daClumpingFactorProfile(\n    data_dict::Dict,\n    component::Symbol,\n    grid::CircularGrid;\n    <keyword arguments>\n)::Tuple{Vector{<:Unitful.Length},Vector{Float64}}\n\nCompute a clumping factor (C_rho) profile, for the number density of component.\n\nC_rho = fraclangle n^2 ranglelangle n rangle^2  \n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS with cell/partcile type :gas.\ngrid::CircularGrid: Circular grid.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with two elements:\nA vector with the central position of each bin.\nA vector with the clumping factors.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daDensity2DProjection-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daDensity2DProjection","text":"daDensity2DProjection(\n    data_dict::Dict,\n    grid::CubicGrid,\n    component::Symbol,\n    field_type::Symbol;\n    <keyword arguments>\n)::Tuple{Vector{<:Unitful.Length},Vector{<:Unitful.Length},VecOrMat{Float64}}\n\nProject a 3D density field into a given plane.\n\nnote: Note\nIf the source of the field are particles, a simple 2D histogram is used. If they are Voronoi cells, the density of the cells that cross the line of sight of each pixel are added up.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ngrid::CubicGrid: Cubic grid.\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\nfield_type::Symbol: If the field is made up of :particles or Voronoi :cells.\nprojection_plane::Symbol=:xy: Projection plane. The options are :xy, :xz, and :yz.\nreduce_grid::Symbol=:square: Type of 2D grid to do the final projection. The options are:\n:square    -> The density distribution will be projected into a regular square grid, with a resolution reduce_factor times lower than grid. This emulates the way the surface densities are measured in observations. reduce_factor = 1 means no reduction in resolution.\n:circular -> The density distribution will be projected into a flat circular grid, formed by a series of reduce_factor concentric rings. This emulates the traditional way the Kennicutt-Schmidt law is measured in some simulations. reduce_factor = 1 means that the result will be a single point. Note that this behaves the opposite way than the reduce_grid = :square case.\nreduce_factor::Int=1: Factor by which the resolution of the result will be reduced. This will be applied after the density projection. If reduce_grid = :square, the new values will be computed averaging the values of neighboring pixels. reduce_factor has to divide the size of grid exactly. If reduce_grid = :circular, the new values will be computed averaging the values of the pixels the fall within each of the reduce_factor concentric rings.\nm_unit::Unitful.Units=u\"Msun\": Mass unit.\nl_unit::Unitful.Units=u\"pc\": Length unit.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with three elements:\nA vector with the x coordinates of the grid.\nA vector with the y coordinates of the grid.\nA matrix or vector with the log_10 of the density at each bin of the 2D grid.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daDiskAccretion-Tuple{GalaxyInspector.Simulation, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daDiskAccretion","text":"daDiskAccretion(\n    sim_data::Simulation;\n    <keyword arguments>\n)::NTuple{2,Vector{<:Number}}\n\nCompute the evolution of the accreted mass into a given galactic disc.\n\nArguments\n\nsim_data::Simulation: The Simulation struct for the target simulation.\ncomponent::Symbol: Component to compute the accreted mass for. The options are:\n:dark_matter -> Dark matter.\n:black_hole  -> Black holes.\n:gas         -> Gas.\n:stellar     -> Stars.\n:all         -> All the matter.\nflux_direction::Symbol=:net: What flux direction will be plotted. The options are:\n:net_mass     -> Net accreted mass.\n:inflow_mass  -> Inflow mass only.\n:outflow_mass -> Outflow mass only.\nmax_r::Unitful.Length=DISK_R: Radius of the disk.\nmax_z::Unitful.Length=5.0u\"kpc\": Half height of the disk.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\ntracers::Bool=false: If tracers will be use to compute the mass accretion.\nsmooth::Int=0: The time series will be smoothed out using smooth bins. Set it to 0 if you want no smoothing.\nshow_progress::Bool=true: If a progress bar will be shown.\n\nReturns\n\nA Tuple with two elements:\nA Vector with the physical times.\nA Vector with the accreted mass at each time.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daEvolution-Tuple{GalaxyInspector.Simulation, Symbol, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daEvolution","text":"daEvolution(\n    sim_data::Simulation,\n    x_quantity::Symbol,\n    y_quantity::Symbol;\n    <keyword arguments>\n)::NTuple{2,Vector{<:Number}}\n\nCompute the time series of two quantities.\n\nArguments\n\nsim_data::Simulation: The Simulation struct for the target simulation.\nx_quantity::Symbol: Quantity for the x axis.\ny_quantity::Symbol: Quantity for the y axis.\nintegration_functions::NTuple{2,Function}=(integrateQty, integrateQty): Functions to compute the integral value of x_quantity and y_quantity at a given time. The functions must have the signature:\nintegration_functions(data_dict::Dict, quantity::Symbol)::Number\nwhere\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nquantity::Symbol: The quantity to be integrated.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nextra_filter::Function=filterNothing: Filter function to be applied after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for extra_filter.\nx_log::Union{Unitful.Units,Nothing}=nothing: Target unit for x_quantity, if you want to apply log_10 to the x_quantity. If set to nothing, the data from scatterQty is left as is.\ny_log::Union{Unitful.Units,Nothing}=nothing: Target unit for y_quantity, if you want to apply log_10 to the y_quantity. If set to nothing, the data from scatterQty is left as is.\nsmooth::Int=0: The result of integrateQty will be smoothed out using smooth bins. Set it to 0 if you want no smoothing.\ncumulative::Bool=false: If the y_quantity will be accumulated or not.\nshow_progress::Bool=true: If a progress bar will be shown.\n\nReturns\n\nA Tuple with two elements:\nA Vector with the time series of x_quantity.\nA Vector with the time series of y_quantity.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daGasSFR2DProjection-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daGasSFR2DProjection","text":"daGasSFR2DProjection(\n    data_dict::Dict,\n    grid::CubicGrid,\n    field_type::Symbol;\n    <keyword arguments>\n)::Tuple{Vector{<:Unitful.Length},Vector{<:Unitful.Length},VecOrMat{Float64}}\n\nProject the 3D gas SFR field into a given plane.\n\nnote: Note\nIf the source of the field are particles, a simple 2D histogram is used. If they are Voronoi cells instead, the SFR of the cells that cross the line of sight of each pixel are added up.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ngrid::CubicGrid: Cubic grid.\nfield_type::Symbol: If the field is made up of :particles or Voronoi :cells.\nprojection_plane::Symbol=:xy: Projection plane. The options are :xy, :xz, and :yz.\nreduce_grid::Symbol=:square: Type of 2D grid to do the final projection. The options are:\n:square    -> The density distribution will be projected into a regular square grid, with a resolution reduce_factor times lower than grid. This emulates the way the surface densities are measured in observations. reduce_factor = 1 means no reduction in resolution.\n:circular -> The density distribution will be projected into a flat circular grid, formed by a series of reduce_factor concentric rings. This emulates the traditional way the Kennicutt-Schmidt law is measured in some simulations. reduce_factor = 1 means that the result will be a single point. Note that this behaves the opposite way than the reduce_grid = :square case.\nreduce_factor::Int=1: Factor by which the resolution of the result will be reduced. This will be applied after the density projection. If reduce_grid = :square, the new values will be computed averaging the values of neighboring pixels. reduce_factor has to divide the size of grid exactly. If reduce_grid = :circular, the new values will be computed averaging the values of the pixels the fall within each of the reduce_factor concentric rings.\nm_unit::Unitful.Units=u\"Msun\": Mass unit.\nt_unit::Unitful.Units=u\"yr\": Time unit.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with three elements:\nA vector with the x coordinates of the grid.\nA vector with the y coordinates of the grid.\nA matrix or vector with the log_10 of the gas SFR at each bin of the 2D grid.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daHistogram-Tuple{Dict, Symbol, GalaxyInspector.LinearGrid}","page":"Data analysis functions","title":"GalaxyInspector.daHistogram","text":"daHistogram(\n    data_dict::Dict,\n    quantity::Symbol,\n    grid::LinearGrid;\n    <keyword arguments>\n)::Union{Tuple{Vector{<:Number},Vector{<:Number}},Nothing}\n\nCompute a 1D histogram of a given quantity.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nquantity::Symbol: Target quantity. It can be any of the quantities valid for scatterQty.\ngrid::LinearGrid: Linear grid.\nnorm::Int=0: Number of counts that will be use to normalize the histogram. If left as 0, the histogram will be normalize with the maximum bin count.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with two elements:\nA vector with the value of quantity corresponding to each bin.\nA vector with the counts.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daHistogram-Tuple{Dict, Symbol, Int64, Bool}","page":"Data analysis functions","title":"GalaxyInspector.daHistogram","text":"daHistogram(\n    data_dict::Dict,\n    quantity::Symbol,\n    n_bins::Int,\n    log::Bool;\n    <keyword arguments>\n)::Union{Tuple{Vector{<:Number},Vector{<:Number}},Nothing}\n\nCompute a 1D histogram of a given quantity.\n\nnote: Note\nThis method uses the extrema of the values of quantity as the range of the histogram.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nquantity::Symbol: Target quantity. It can be any of the quantities valid for scatterQty.\nn_bins::Int: Number of bins.\nlog::Bool: If the histogram bins will be logarithmic.\nnorm::Int=0: Number of count that will be use to normalize the histogram. If left as 0, the histogram will be normalize with the maximum bin count.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with two elements:\nA vector with the value of quantity corresponding to each bin.\nA vector with the counts.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daIntegrateGalaxy-Tuple{Dict, Symbol, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daIntegrateGalaxy","text":"daIntegrateGalaxy(\n    data_dict::Dict,\n    x_quantity::Symbol,\n    y_quantity::Symbol;\n    <keyword arguments>\n)::NTuple{2,Vector{<:Number}}\n\nCompute two global quantities for the simulation.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nx_quantity::Symbol: Quantity for the x axis. It can be any of the quantities valid for integrateQty.\ny_quantity::Symbol: Quantity for the y axis. It can be any of the quantities valid for integrateQty.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with two elements:\nA single element vector with the value of x_quantity.\nA single element vector with the value of y_quantity.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daMetallicity2DProjection-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daMetallicity2DProjection","text":"daMetallicity2DProjection(\n    data_dict::Dict,\n    grid::CubicGrid,\n    component::Symbol,\n    field_type::Symbol;\n    <keyword arguments>\n)::Tuple{Vector{<:Unitful.Length},Vector{<:Unitful.Length},VecOrMat{Float64}}\n\nProject the 3D metallicity field to a given plane.\n\nnote: Note\nIf if element = :all, the total metallicity (in solar units) is computed. If element = :X, the abundance of element X is computed, ABUNDANCE_SHIFT + ``\\log_{10}(X/H). In both cases the total value of the column given by the line of sight of each pixel is computed.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ngrid::CubicGrid: Cubic grid.\ncomponent::Symbol: Target component. It can be either :stellar or :gas.\nfield_type::Symbol: If the field is made up of :particles or Voronoi :cells.\nelement::Symbol=:all: Target element. The possibilities are the keys of ELEMENT_INDEX. Set it to :all if you want the total metallicity.\nprojection_plane::Symbol=:xy: Projection plane. The options are :xy, :xz, and :yz.\nreduce_grid::Symbol=:square: Type of 2D grid to do the final projection. The options are:\n:square    -> The density distribution will be projected into a regular square grid, with a resolution reduce_factor times lower than grid. This emulates the way the surface densities are measured in observations. reduce_factor = 1 means no reduction in resolution.\n:circular -> The density distribution will be projected into a flat circular grid, formed by a series of reduce_factor concentric rings. This emulates the traditional way the Kennicutt-Schmidt law is measured in some simulations. reduce_factor = 1 means that the result will be a single point. Note that this behaves the opposite way than the reduce_grid = :square case.\nreduce_factor::Int=1: Factor by which the resolution of the result will be reduced. This will be applied after the density projection. If reduce_grid = :square, the new values will be computed averaging the values of neighboring pixels. reduce_factor has to divide the size of grid exactly. If reduce_grid = :circular, the new values will be computed averaging the values of the pixels the fall within each of the reduce_factor concentric rings.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with three elements:\nA vector with the x coordinates of the grid.\nA vector with the y coordinates of the grid.\nA matrix or vector with the log_10 of the metallicity at each bin of the 2D grid.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daMolla2015-Tuple{Dict, GalaxyInspector.CircularGrid, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daMolla2015","text":"daMolla2015(\n    data_dict::Dict,\n    grid::CircularGrid,\n    quantity::Symbol;\n    <keyword arguments>\n)::Union{\n    Tuple{\n        Vector{<:Unitful.Length},\n        <:Union{Vector{<:SurfaceDensity},Vector{<:MassFlowDensity},Vector{Float64}}\n    },\n    Nothing,\n}\n\nCompute a profile for the Milky Way, compatible with the experimental data in Mollá et al. (2015).\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ngrid::CircularGrid: Circular grid.\nquantity::Symbol: Quantity for the y axis. The options are:\n:stellar_area_density       -> Stellar mass surface density.\n:sfr_area_density           -> Star formation rate surface density.\n:ode_molecular_area_density -> Molecular mass surface density.\n:br_molecular_area_density  -> Molecular mass surface density, computed using the pressure relation in Blitz et al. (2006).\n:ode_atomic_area_density    -> Atomic mass surface density.\n:br_atomic_area_density     -> Atomic mass surface density, computed using the pressure relation in Blitz et al. (2006).\n:O_stellar_abundance        -> Stellar abundance of oxygen, as 12 + log_10(mathrmO    H).\n:N_stellar_abundance        -> Stellar abundance of nitrogen, as 12 + log_10(mathrmN    H).\n:C_stellar_abundance        -> Stellar abundance of carbon, as 12 + log_10(mathrmC    H).\ny_unit::Unitful.Units=Unitful.NoUnits: Unit for quantity.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with two elements:\nA vector with the position of each ring.\nA vector with the value quantity in each ring.\nIt returns nothing if any of the necessary quantities are missing.\n\nReferences\n\nL. Blitz et al. (2006). The Role of Pressure in GMC Formation II: The H2-Pressure Relation. The Astrophysical Journal, 650(2), 933. doi:10.1086/505417\n\nM. Mollá et al. (2015). Galactic chemical evolution: stellar yields and the initial mass function. Monthly Notices of the Royal Astronomical Society 451(4), 3693–3708. doi:10.1093/mnras/stv1102\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daProfile-Tuple{Dict, Symbol, GalaxyInspector.CircularGrid}","page":"Data analysis functions","title":"GalaxyInspector.daProfile","text":"daProfile(\n    data_dict::Dict,\n    quantity::Symbol,\n    grid::CircularGrid;\n    <keyword arguments>\n)::Union{Tuple{Vector{<:Unitful.Length},Vector{<:Number}},Nothing}\n\nCompute a profile.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nquantity::Symbol: Target quantity. It can be any of the quantities valid for scatterQty.\ngrid::CircularGrid: Circular grid.\nnorm::Union{Symbol,Nothing}=nothing: The value of quantity in each bin will be divided by the corresponding value of norm. It can be any of the quantities valid for scatterQty. If set to nothing, no operation is applied.\ny_log::Union{Unitful.Units,Nothing}=nothing: Target unit for quantity, if you want to apply log_10 to quantity. If set to nothing, the data is left as is.\nflat::Bool=true: If the profile will be 2D (rings), or 3D (spherical shells).\ntotal::Bool=true: If the sum (default) or the mean of quantity will be computed for each bin. This affects the values of norm too.\ncumulative::Bool=false: If the profile will be accumulated (after dividing by norm).\ndensity::Bool=false: If the profile will be of the density of quantity (after dividing by norm).\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with two elements:\nA vector with the position of each ring or spherical shells.\nA vector with the value of quantity in each each ring or spherical shells.\nIt returns nothing if any of the necessary quantities are missing.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daRotationCurve-Tuple{Dict}","page":"Data analysis functions","title":"GalaxyInspector.daRotationCurve","text":"daRotationCurve(\n    data_dict::Dict;\n    <keyword arguments>\n)::Tuple{Vector{<:Unitful.Length},Vector{<:Unitful.Velocity}}\n\nCompute a rotation curve.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nR::Unitful.Length=DISK_R: Maximum radial distance for the rotation curve.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with two elements:\nA vector with the distances to each star.\nA vector with the circular velocity of each star.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daSFRtxt-Tuple{GalaxyInspector.Simulation, Symbol, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daSFRtxt","text":"daSFRtxt(\n    sim_data::Simulation,\n    x_quantity::Symbol,\n    y_quantity::Symbol;\n    <keyword arguments>\n)::NTuple{2,Vector{<:Number}}\n\nCompute the stellar mass or SFR evolution using the data in the sfr.txt file.\n\nArguments\n\nsim_data::Simulation: The Simulation struct for the target simulation.\nx_quantity::Symbol: Quantity for the x axis. The options are:\n:scale_factor  -> Scale factor.\n:redshift      -> Redshift.\n:physical_time -> Physical time since the Big Bang.\n:lookback_time -> Physical time left to reach the last snapshot.\ny_quantity::Symbol: Quantity for the y axis. The options are:\n:stellar_mass -> Cumulative stellar mass.\n:sfr          -> Star formation rate.\nsmooth::Int=0: The result will be smoothed out using smooth bins. Set it to 0 if you want no smoothing.\n\nReturns\n\nA Tuple with two elements:\nA Vector with the time series of x_quantity.\nA Vector with the time series of y_quantity.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daScatterDensity-Tuple{Dict, Symbol, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daScatterDensity","text":"daScatterDensity(\n    data_dict::Dict,\n    x_quantity::Symbol,\n    y_quantity::Symbol;\n    <keyword arguments>\n)::Tuple{Vector{<:Number},Vector{<:Number},Matrix{Float64}}\n\nCompute two quantities for every cell/particle using a 2D histogram.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nx_quantity::Symbol: Quantity for the x axis. It can be any of the quantities valid for scatterQty.\ny_quantity::Symbol: Quantity for the y axis. It can be any of the quantities valid for scatterQty.\nx_range::Union{NTuple{2,<:Number},Nothing}=nothing: x axis range for the histogram grid. If set to nothing, the extrema of the values will be used.\ny_range::Union{NTuple{2,<:Number},Nothing}=nothing: y axis range for the histogram grid. If set to nothing, the extrema of the values will be used.\nx_log::Union{Unitful.Units,Nothing}=nothing: Target unit for x_quantity, if you want to apply log_10 to the x_quantity. If set to nothing, the data from scatterQty is left as is.\ny_log::Union{Unitful.Units,Nothing}=nothing: Target unit for y_quantity, if you want to apply log_10 to the y_quantity. If set to nothing, the data from scatterQty is left as is.\nn_bins::Int=100: Number of bins per side of the grid.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with three elements:\nA vector with the x coordinates of the grid.\nA vector with the y coordinates of the grid.\nA matrix with the the log_10 of the counts in each bin.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daScatterGalaxy-Tuple{Dict, Symbol, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daScatterGalaxy","text":"daScatterGalaxy(\n    data_dict::Dict,\n    x_quantity::Symbol,\n    y_quantity::Symbol;\n    <keyword arguments>\n)::NTuple{2,Vector{<:Number}}\n\nCompute two quantities for every cell/particle in the simulation using scatterQty.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nx_quantity::Symbol: Quantity for the x axis. It can be any of the quantities valid for scatterQty.\ny_quantity::Symbol: Quantity for the y axis. It can be any of the quantities valid for scatterQty.\nx_log::Union{Unitful.Units,Nothing}=nothing: Target unit for x_quantity, if you want to apply log_10 to the x_quantity. If set to nothing, the data from scatterQty is left as is.\ny_log::Union{Unitful.Units,Nothing}=nothing: Target unit for y_quantity, if you want to apply log_10 to the y_quantity. If set to nothing, the data from scatterQty is left as is.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with two elements:\nA vector with the values of x_quantity.\nA vector with the values of y_quantity.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daScatterWeightedDensity-Tuple{Dict, Symbol, Symbol, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daScatterWeightedDensity","text":"daScatterWeightedDensity(\n    data_dict::Dict,\n    x_quantity::Symbol,\n    y_quantity::Symbol,\n    z_quantity::Symbol;\n    <keyword arguments>\n)::Tuple{Vector{<:Number},Vector{<:Number},Matrix{Float64}}\n\nCompute two quantities for every cell/particle using a 2D histogram, weighted by z_quantity.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nx_quantity::Symbol: Quantity for the x axis. It can be any of the quantities valid for scatterQty.\ny_quantity::Symbol: Quantity for the y axis. It can be any of the quantities valid for scatterQty.\nz_quantity::Symbol: Quantity for the weights. It can be any of the quantities valid for scatterQty.\nx_range::Union{NTuple{2,<:Number},Nothing}=nothing: x axis range. If set to nothing, the extrema of the values will be used.\ny_range::Union{NTuple{2,<:Number},Nothing}=nothing: y axis range. If set to nothing, the extrema of the values will be used.\nx_log::Union{Unitful.Units,Nothing}=nothing: Target unit for x_quantity, if you want to apply log_10 to the x_quantity. If set to nothing, the data from scatterQty is left as is.\ny_log::Union{Unitful.Units,Nothing}=nothing: Target unit for y_quantity, if you want to apply log_10 to the y_quantity. If set to nothing, the data from scatterQty is left as is.\ntotal::Bool=true: If the sum (default) or the mean of z_quantity will be used as the value of each bin.\nn_bins::Int=100: Number of bins per side of the grid.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with three elements:\nA vector with the x coordinates of the grid.\nA vector with the y coordinates of the grid.\nA matrix with the log_10 of z_quantity for each bin.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daStellarHistory-Tuple{Dict}","page":"Data analysis functions","title":"GalaxyInspector.daStellarHistory","text":"daStellarHistory(\n    data_dict::Dict;\n    <keyword arguments>\n)::Union{Tuple{Vector{<:Unitful.Time},Vector{<:Number}},Nothing}\n\nCompute the evolution of a given stellar quantity using the stellar ages at a given instant in time.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nquantity::Symbol=:sfr: Target quantity. The options are:\n:sfr                 -> Star formation rate.\n:ssfr                -> The specific star formation rate.\n:stellar_mass        -> Stellar mass.\n:stellar_metallicity -> Mass fraction of all elements above He in the stars (solar units).\nn_bins::Int=100: Number of bins (time intervals).\nylog::Bool=false: If true, returns log_10(quantity).\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with two elements:\nA vector with the physical times.\nA vector with the values of quantity at each time.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daTemperature2DProjection-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daTemperature2DProjection","text":"daTemperature2DProjection(\n    data_dict::Dict,\n    grid::CubicGrid,\n    field_type::Symbol;\n    <keyword arguments>\n)::Tuple{Vector{<:Unitful.Length},Vector{<:Unitful.Length},VecOrMat{Float64}}\n\nProject the 3D temperature field to a given plane.\n\nnote: Note\nThe gas temperature is the mean value in the column given by the line of sight of each pixel.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ngrid::CubicGrid: Cubic grid.\nfield_type::Symbol: If the field is made up of :particles or Voronoi :cells.\nprojection_plane::Symbol=:xy: Projection plane. The options are :xy, :xz, and :yz.\nreduce_grid::Symbol=:square: Type of 2D grid to do the final projection. The options are:\n:square    -> The density distribution will be projected into a regular square grid, with a resolution reduce_factor times lower than grid. This emulates the way the surface densities are measured in observations. reduce_factor = 1 means no reduction in resolution.\n:circular -> The density distribution will be projected into a flat circular grid, formed by a series of reduce_factor concentric rings. This emulates the traditional way the Kennicutt-Schmidt law is measured in some simulations. reduce_factor = 1 means that the result will be a single point. Note that this behaves the opposite way than the reduce_grid = :square case.\nreduce_factor::Int=1: Factor by which the resolution of the result will be reduced. This will be applied after the density projection. If reduce_grid = :square, the new values will be computed averaging the values of neighboring pixels. reduce_factor has to divide the size of grid exactly. If reduce_grid = :circular, the new values will be computed averaging the values of the pixels the fall within each of the reduce_factor concentric rings.\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with three elements:\nA vector with the x coordinates of the grid.\nA vector with the y coordinates of the grid.\nA matrix or vector with the log_10 of the temperature at each bin of the 2D grid.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daTrajectory-Tuple{String, Vector{<:Unsigned}, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daTrajectory","text":"daTrajectory(\n    simulation_path::String,\n    target_ids::Vector{<:Unsigned},\n    cp_type::Symbol;\n    <keyword arguments>\n)::Dict{UInt64,Matrix{Quantity}}\n\nCompute the trajectory of a set of cells/particles, given their IDs.\n\nArguments\n\nsimulation_path::String: Path to the simulation directory, set in the code variable OutputDir.\ntarget_ids::Vector{<:Unsigned}: IDs of the cells/particles whose trajectories will be computed.\ncp_type::Symbol: Target type of cell/particle. The possibilities are the keys of PARTICLE_INDEX.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\n\nReturns\n\nA dictionary with the following shape:\ntarget_id::UInt64 -> A matrix with the trajectory of the cell/particle with ID target_id. The matrix has 7 rows, where:\nRow 1: Physical time.\nRows 2-4: Position [x, y, z].\nRows 5-7: Velocity [vx, vy, vz].\nIf the target ID is not found at a given physical time the position and velocity are NaN.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daVSFLaw-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daVSFLaw","text":"daVSFLaw(\n    data_dict::Dict,\n    grid::CubicGrid,\n    component::Symbol;\n    <keyword arguments>\n)::Union{NTuple{2,Vector{<:Float64}},Nothing}\n\nCompute the gas density and the SFR density, used in the volumetric star formation (VSF) law.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ngrid::CubicGrid: Cubic grid.\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\nfield_type::Symbol=:cells: If the gas surface density will be calculated assuming the gas is in :particles or in Voronoi :cells.\nstellar_ff::Function=filterNothing: Filter function for the stars. See the required signature and examples in ./src/analysis/filters.jl.\ngas_ff::Function=filterNothing: Filter function for the gas. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with two elements:\nA vector with log_10(rho_mathrmH    mathrmM_odot  pc^-3)\nA vector with log_10(rho_mathrmSFR    mathrmM_odot  yr^-1  kpc^-3)\nIt returns nothing if any of the necessary quantities are missing.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daVelocityField-Tuple{Dict, GalaxyInspector.SquareGrid, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daVelocityField","text":"daVelocityField(\n    data_dict::Dict,\n    grid::SquareGrid,\n    component::Symbol;\n    <keyword arguments>\n)::Tuple{Vector{<:Unitful.Length},Vector{<:Unitful.Length},Matrix{Float64},Matrix{Float64}}\n\nProject a 3D velocity field into a given plane.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ngrid::SquareGrid: Square grid.\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\nprojection_plane::Symbol=:xy: Projection plane. The options are :xy, :xz, and :yz.\nv_unit::Unitful.Units=u\"km * s^-1\",: Velocity unit\nfilter_function::Function=filterNothing: Filter function to be applied to data_dict before any other computation. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nA tuple with four elements:\nA vector with the x coordinates of the grid.\nA vector with the y coordinates of the grid.\nA matrix with the mean velocity in the x direction at each grid point.\nA matrix with the mean velocity in the y direction at each grid point.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_analysis/#GalaxyInspector.daVirialAccretion-Tuple{GalaxyInspector.Simulation, Symbol}","page":"Data analysis functions","title":"GalaxyInspector.daVirialAccretion","text":"daVirialAccretion(\n    sim_data::Simulation;\n    <keyword arguments>\n)::NTuple{2,Vector{<:Number}}\n\nCompute the evolution of the accreted mass into a sphere with the virial radius.\n\nArguments\n\nsim_data::Simulation: The Simulation struct for the target simulation.\ncomponent::Symbol: Component to compute the accreted mass for. The options are:\n:dark_matter -> Dark matter.\n:black_hole  -> Black holes.\n:gas         -> Gas.\n:stellar     -> Stars.\n:all         -> All the matter.\nflux_direction::Symbol=:net: What flux direction will be plotted. The options are:\n:net_mass     -> Net accreted mass.\n:inflow_mass  -> Inflow mass only.\n:outflow_mass -> Outflow mass only.\nhalo_idx::Int=1: Index of the target halo (FoF group). Starts at 1.\ntracers::Bool=false: If tracers will be use to compute the mass accretion.\nsmooth::Int=0: The time series will be smoothed out using smooth bins. Set it to 0 if you want no smoothing.\nshow_progress::Bool=true: If a progress bar will be shown.\n\nReturns\n\nA Tuple with two elements:\nA Vector with the physical times.\nA Vector with the accreted mass at each time.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#Auxiliary-functions","page":"Auxiliary functions","title":"Auxiliary functions","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/auxiliary_functions/other/#Base.intersect-Tuple{Colon, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Auxiliary functions","title":"Base.intersect","text":"New methods for Base.intersect to use with the Colon type.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#Base.intersect-Tuple{Vector{Bool}, Union{Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Auxiliary functions","title":"Base.intersect","text":"New methods for Base.intersect to use with the Vector{Bool} type.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#Base.isempty-Tuple{LaTeXStrings.LaTeXString}","page":"Auxiliary functions","title":"Base.isempty","text":"New method for Base.isempty to check for empty LaTeXStrings.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#Base.iszero-Tuple{Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Auxiliary functions","title":"Base.iszero","text":"New method for Base.iszero to compare IndexType with 0.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#Base.iterate-Tuple{Symbol}","page":"Auxiliary functions","title":"Base.iterate","text":"New method for Base.iterate to manage symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#Base.round-Tuple{Unitful.Quantity}","page":"Auxiliary functions","title":"Base.round","text":"New method for Base.round to use with the Unitful.Quantity type.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#Base.union-Tuple{Vector{Bool}, Union{Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Auxiliary functions","title":"Base.union","text":"New methods for Base.union to use with the Vector{Bool} type.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.area-Tuple{Number}","page":"Auxiliary functions","title":"GalaxyInspector.area","text":"Area of a circle with radius r.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.evaluateNormal-Tuple{Vector{<:Number}}","page":"Auxiliary functions","title":"GalaxyInspector.evaluateNormal","text":"evaluateNormal(values::Vector{<:Number})::Vector{<:Number}\n\nEvaluate a normal distribution at values.\n\nThe median and standard deviation for the distribution are the ones of values.\n\nArguments\n\nvalues::Vector{<:Number}: Vector used to compute the mean and standard deviation of the normal distribution.\n\nReturns\n\nThe normal distribution evaluated at values.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.format_seconds-Tuple{Float64}","page":"Auxiliary functions","title":"GalaxyInspector.format_seconds","text":"format_seconds(sec::Float64)::String\n\nFormat given number of seconds as \"DDd-HHh:MM':SS''\", where D is days, H is hours, M is minutes, and S is seconds.\n\nArguments\n\nsec::Float64: Number of seconds.\n\nReturns\n\nString with the formatted time.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.getEmpty-Tuple","page":"Auxiliary functions","title":"GalaxyInspector.getEmpty","text":"Always returns an empty vector, for any type and number of arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.getNothing-Tuple","page":"Auxiliary functions","title":"GalaxyInspector.getNothing","text":"Always returns nothing, for any type and number of arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.hvcatImages-Tuple{Int64, Vector{String}}","page":"Auxiliary functions","title":"GalaxyInspector.hvcatImages","text":"hvcatImages(\n    blocks_per_row::Int,\n    paths::Vector{String};\n    <keyword arguments>\n)::Nothing\n\nJoin several images vertically and horizontally.\n\nThe images in paths will fill the rows and columns starting at the top left, going from left to right and from top to bottom (row-major order).\n\nArguments\n\nblocks_per_row::Int: Number of columns.\npaths::Vector{String}: Paths to the images.\noutput_path::String=\"./joined_images.png\": Path to the output image.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.isPositive-Tuple{Number}","page":"Auxiliary functions","title":"GalaxyInspector.isPositive","text":"Test for strict positivity.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.metaFormatter-Tuple{Base.CoreLogging.LogLevel, Vararg{Any, 5}}","page":"Auxiliary functions","title":"GalaxyInspector.metaFormatter","text":"metaFormatter(level::LogLevel, _module, group, id, file, line)\n\nFormatter for loggers.\n\nSee the documentation of ConsoleLogger\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.parserWS-Tuple{AbstractString}","page":"Auxiliary functions","title":"GalaxyInspector.parserWS","text":"parserWS(value::AbstractString)::Union{Float64,Missing}\n\nParse a string as a Float64, ignoring white spaces. If the string is empty return missing.\n\nArguments\n\nvalue::AbstractString: String to be parsed.\n\nReturns\n\nNumber in the string as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.rangeCut!-Tuple{Vector{<:Number}, Tuple{Number, Number}}","page":"Auxiliary functions","title":"GalaxyInspector.rangeCut!","text":"rangeCut!(\n    raw_values::Vector{<:Number},\n    range::Tuple{<:Number,<:Number};\n    <keyword arguments>\n)::Bool\n\nDelete every element in raw_values that is outside the given range.\n\nArguments\n\nraw_values::Vector{<:Number}: Dataset that will be pruned.\nrange::Tuple{<:Number,<:Number}: The range in question.\nkeep_edges::Bool=true: If the edges of the range will be kept.\nmin_left::Int=1: Minimum number of values that need to be left after pruning to proceed with the transformation.\n\nReturns\n\nIf a transformation was performed.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.rangeCut!-Tuple{Vector{<:Number}, Vector, Tuple{Number, Number}}","page":"Auxiliary functions","title":"GalaxyInspector.rangeCut!","text":"rangeCut!(\n    m_data::Vector{<:Number},\n    s_data::Vector,\n    range::Tuple{<:Number,<:Number};\n    <keyword arguments>\n)::Bool\n\nDelete every element in m_data that is outside the given range.\n\nEvery corresponding element in s_data (i.e. with the same index) will be deleted too.\n\nArguments\n\nm_data::Vector{<:Number}: Master dataset that will be pruned.\ns_data::Vector: Slave dataset that will be pruned according to which values of m_data are outside range.\nrange::Tuple{<:Number,<:Number}: The range in question.\nkeep_edges::Bool=true: If the edges of the range will be kept.\nmin_left::Int=1: Minimum number of values that need to be left in the master dataset after pruning to proceed with the transformation.\n\nReturns\n\nIf a transformation was performed.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.ratio-Tuple{Symbol, Symbol}","page":"Auxiliary functions","title":"GalaxyInspector.ratio","text":"ratio(qty_1::Symbol, qty_2::Symbol)::Symbol\n\nReturns the symbol for the ratio between two derived quantities.\n\nArguments\n\nqty_1::Symbol: Symbol for the numerator derived quantity.\nqty_2::Symbol: Symbol for the denominator derived quantity.\n\nReturns\n\nThe symbol for the ration between qty_1 and qty_2.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.ring-Tuple{Vector, Integer}","page":"Auxiliary functions","title":"GalaxyInspector.ring","text":"ring(vec::Vector, index::Integer)::Vector\n\nMake the indexing operation vec[index] work with modular arithmetic for the indices.\n\nArguments\n\nvec::Vector: Vector.\nindex::Integer: Index.\n\nReturns\n\nvec[mod1(index, length(vec))]\n\nExamples\n\njulia> ring([1, 2, 3], 11)\n2\n\njulia> ring([1, 2, 3], 3)\n3\n\njulia> ring([1, 2, 3], -5)\n1\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.safeSelect-Tuple{Vector, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Auxiliary functions","title":"GalaxyInspector.safeSelect","text":"safeSelect(vec::Vector, index::IndexType)\n\nDo the indexing operation vec[index] while ignoring indices that are out of bounds.\n\nArguments\n\nvec::Vector: Vector.\nindex::IndexType: Indices. It can be an integer (a single element), a vector of integers (several elements), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (every element).\n\nReturns\n\nvec[index (minus out of bounds indices)]\n\nExamples\n\njulia> safeSelect([1, 2, 3], 11)\nInt[]\n\njulia> safeSelect([1, 2, 3], 1:5)\n3-element Vector{Int}:\n 1\n 2\n 3\n\njulia> safeSelect([1, 2, 3], 1:3:10)\n1\n\njulia> safeSelect([1, 2, 3], [1, 2, 5, 9])\n2-element Vector{Int}:\n 1\n 2\n\njulia> safeSelect([1, 2, 3], (:))\n3-element Vector{Int}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.sanitizeData!-Tuple{Vector{<:Number}, Vector{<:Number}}","page":"Auxiliary functions","title":"GalaxyInspector.sanitizeData!","text":"sanitizeData!(\n    x_data::Vector{<:Number},\n    y_data::Vector{<:Number};\n    <keyword arguments>\n)::NTuple{4,Bool}\n\nDo the following transformations over x_data and y_data, in order:\n\nTrim them to fit within the domain of the functions func_domain[1] and func_domain[2], respectively.\nTrim them to fit within range[1] and range[2], respectively.\nScale them down by a factor 10^exp_factor[1] and 10^exp_factor[2], respectively.\n\nBy default, no transformation is done.\n\nnote: Note\nThe datasets must have the same length, and any operation that deletes an element, will delete the corresponding element (i.e. with the same index) in the other dataset, so that the datasets will remain of equal length.\n\nArguments\n\nx_data::Vector{<:Number}: First dataset to be sanitized.\ny_data::Vector{<:Number}: Second dataset to be sanitized.\nfunc_domain::NTuple{2,Function}=(identity, identity): x_data will be trimmed to fit within the domain of the function func_domain[1], and y_data will be trimmed to fit within the domain of the function func_domain[2]. The options are the scaling functions accepted by Makie: log10, log2, log, sqrt, Makie.logit, Makie.Symlog10, Makie.pseudolog10, and identity.\nrange::Tuple{Tuple{<:Number,<:Number},Tuple{<:Number,<:Number}}=((-Inf, Inf), (-Inf, Inf)): Every element in x_data that falls outside of range[1] will be deleted, and every element in y_data that falls outside of range[2] will be deleted.\nkeep_edges::NTuple{2,Bool}=(true, true): If the edges of each corresponding range will be kept.\nmin_left::Int=1: Minimum number of values that need to be left in each dataset after any of the transformations to proceed with them.\nexp_factor::NTuple{2,Int}=(0, 0): Every element in x_data will be divided by 10^exp_factor[1], and every element in y_data will be divided by 10^exp_factor[2].\n\nReturns\n\nA tuple with four flags:\nIf x_data was mutated to fit within the domain of func_domain[1].\nIf y_data was mutated to fit within the domain of func_domain[2].\nIf x_data was mutated to fit within range[1].\nIf y_data was mutated to fit within range[2].\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.sanitizeData!-Tuple{Vector{<:Number}}","page":"Auxiliary functions","title":"GalaxyInspector.sanitizeData!","text":"sanitizeData!(\n    raw_values::Vector{<:Number};\n    <keyword arguments>\n)::NTuple{2,Bool}\n\nDo the following transformations over raw_values, in order:\n\nTrim it to fit within the domain of the function func_domain.\nTrim it to fit within range.\nScale it down by a factor of 10^exp_factor.\n\nBy default, no transformation is done.\n\nArguments\n\nraw_values::Vector{<:Number}: Dataset to be sanitized.\nfunc_domain::Function=identity: raw_values will be trimmed to fit within the domain of the function func_domain. The options are the scaling functions accepted by Makie: log10, log2, log, sqrt, Makie.logit, Makie.Symlog10, Makie.pseudolog10, and identity.\nrange::Tuple{<:Number,<:Number}=(-Inf, Inf): Every element in raw_values that falls outside of range will be deleted.\nkeep_edges::Bool=true: If the edges of range will be kept.\nmin_left::Int=1: Minimum number of values that need to be left after each transformation to proceed with it.\nexp_factor::Int=0: Every element in raw_values will be divided by 10^exp_factor.\n\nReturns\n\nA tuple with two flags:\nIf raw_values was mutated to fit within the domain of func_domain.\nIf raw_values was mutated to fit within range.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.setLogging!-Tuple{Bool}","page":"Auxiliary functions","title":"GalaxyInspector.setLogging!","text":"setLogging!(log::Bool; <keyword arguments>)::Nothing\n\nSet if logging messages will be printed out. By default no logs are printed.\n\nArguments\n\nlog::Bool: If logs will be printed out using the default logger.\nstream::IO=stdout: Where to print the logs. It can be a file.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.setPositive-Tuple{VecOrMat{<:Number}}","page":"Auxiliary functions","title":"GalaxyInspector.setPositive","text":"Return a copy of list with every negative value set to 0.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.smoothWindow-Tuple{Vector{<:Number}, Vector{<:Number}, Int64}","page":"Auxiliary functions","title":"GalaxyInspector.smoothWindow","text":"smoothWindow(\n    x_data::Vector{<:Number},\n    y_data::Vector{<:Number},\n    n_bins::Int;\n    <keyword arguments>\n)::NTuple{2,Vector{<:Number}}\n\nSeparate the values of x_data in n_bins bins and compute the mean value of x_data and y_data within each one.\n\nArguments\n\nx_data::Vector{<:Number}: x-axis data.\ny_data::Vector{<:Number}: y-axis data.\nn_bins::Int: Number of bins.\nscaling::Function=identity: Scaling function for the x axis. The options are the scaling functions accepted by Makie: log10, log2, log, sqrt, Makie.logit, Makie.Symlog10, Makie.pseudolog10, and identity. All the values of x_data must be in the domain of scaling.\n\nReturns\n\nA tuple with two vectors, containing the smoothed-out x and y values.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/other/#GalaxyInspector.volume-Tuple{Number}","page":"Auxiliary functions","title":"GalaxyInspector.volume","text":"Volume of a sphere with radius r.\n\n\n\n\n\n","category":"method"},{"location":"api/constants/arepo/#Arepo-constants","page":"Arepo constants","title":"Arepo constants","text":"This is a list of constant and types used in GalaxyInspector, specific for the Arepo codebase.\n\nNone of these are exported.\n\n","category":"section"},{"location":"api/constants/arepo/#GalaxyInspector.COSMO_THRESHOLD_DENSITY","page":"Arepo constants","title":"GalaxyInspector.COSMO_THRESHOLD_DENSITY","text":"Cosmological threshold density above which the gas cells/particles can turn into stars.\n\nThis value corresponds to CritOverDensity = 577  mathrmcm^-3 in the param.txt file (used only in cosmological simulations). Which is converted to internal units within the code using OverDensThresh = CritOverDensity * OmegaBaryon * 3 * Hubble * Hubble / (8 * M_PI * G). Then, to go to physical units again one has to do:OverDensThresh*UnitDensityincgs*cf_a3inv*HubbleParam*HubbleParam`.\n\nUsing the unit factors,\n\nUnitLength_in_cm         = 3085678 times 10^24\n\nUnitMass_in_g            = 1989 times 10^43\n\nUnitVelocity_in_cm_per_s = 100000\n\nThe derived units,\n\nUnitTime_in_s      = UnitLength_in_cm * UnitVelocity_in_cm_per_s^-1 = 308568 times 10^19\n\nUnitDensity_in_cgs = UnitMass_in_g * UnitLength_in_cm^-3            = 676991 times 10^-31\n\nThe parameters,\n\nOmegaBaryon       = 0048\n\nHubbleParam       = 06777\n\nPROTONMASS        = 167262178 times 10^-24\n\nHYDROGEN_MASSFRAC = 076\n\nGRAVITY           = 66738 times 10^-8\n\nHUBBLE            = 32407789 times 10^-18\n\nAnd the derived parameters,\n\nHubble = HUBBLE * UnitTime_in_s                                              = 100\n\nG      = GRAVITY * UnitLength_in_cm^-3 * UnitMass_in_g * UnitTime_in_s^2 = 430187\n\nOne gets,\n\nOverDensThresh = 76.8495 [internal units of density]\n\nAnd, for a cosmological simulation at redshift 0 (cf_a3inv = 1), this result in a physical density threshold of 142857 times 10^-5  mathrmcm^-3, or, adding the proton mass, a value of\n\nlog_10 rho  mathrmM_odot  kpc^-3 = 2548\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.CPU_REL_PATH","page":"Arepo constants","title":"GalaxyInspector.CPU_REL_PATH","text":"Relative path, within the simulation directory, of cpu.txt.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.Cxd","page":"Arepo constants","title":"GalaxyInspector.Cxd","text":"Star formation model parameters\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.DEFAULT_L_UNIT","page":"Arepo constants","title":"GalaxyInspector.DEFAULT_L_UNIT","text":"Default internal unit of length.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.DEFAULT_M_UNIT","page":"Arepo constants","title":"GalaxyInspector.DEFAULT_M_UNIT","text":"Default internal unit of mass.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.DEFAULT_V_UNIT","page":"Arepo constants","title":"GalaxyInspector.DEFAULT_V_UNIT","text":"Default internal unit of velocity.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.ELEMENT_INDEX","page":"Arepo constants","title":"GalaxyInspector.ELEMENT_INDEX","text":"Code index for each tracked element.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.GC_BASENAME","page":"Arepo constants","title":"GalaxyInspector.GC_BASENAME","text":"Base name of the group catalog files.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.HUBBLE_CONSTANT","page":"Arepo constants","title":"GalaxyInspector.HUBBLE_CONSTANT","text":"Hubble constant in mathrmGyr^-1.\n\nThis value corresponds to H_0 = 0102201  mathrmGyr^-1 = 100  mathrmkm  mathrms^-1  mathrmMpc^-1.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.HYDROGEN_MASSFRAC","page":"Arepo constants","title":"GalaxyInspector.HYDROGEN_MASSFRAC","text":"Mass fraction of hydrogen.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.ISOLATED_PARTICLE_NAMES","page":"Arepo constants","title":"GalaxyInspector.ISOLATED_PARTICLE_NAMES","text":"Human readable name for each type of cell/particle.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.LONG_PARTICLE_INDEX","page":"Arepo constants","title":"GalaxyInspector.LONG_PARTICLE_INDEX","text":"Code index for each type of cell/particle.\n\nReferences\n\nSee for example Gadget2 User's Guide, or Gadget4 documentation.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.LONG_PARTICLE_NAMES","page":"Arepo constants","title":"GalaxyInspector.LONG_PARTICLE_NAMES","text":"Human readable name for each type of cell/particle.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.METAL_LIST","page":"Arepo constants","title":"GalaxyInspector.METAL_LIST","text":"List of element indices above helium.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.MORPHOLOGICAL_COMPONENTS","page":"Arepo constants","title":"GalaxyInspector.MORPHOLOGICAL_COMPONENTS","text":"Human readable name for each morphological component.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.PARTICLE_INDEX","page":"Arepo constants","title":"GalaxyInspector.PARTICLE_INDEX","text":"Current cell/particle index in use.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.PARTICLE_NAMES","page":"Arepo constants","title":"GalaxyInspector.PARTICLE_NAMES","text":"Current human readable name of each cell/particle type in use.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.SFM_IDX","page":"Arepo constants","title":"GalaxyInspector.SFM_IDX","text":"ODE index corresponding to each gas phase in our star formation model.\n\nIonized gas fraction:   fi(t) = Mi(t) / MC –> data_dict[:gas][\"FRAC\"][1, :]\nAtomic gas fraction:    fa(t) = Ma(t) / MC –> data_dict[:gas][\"FRAC\"][2, :]\nMolecular gas fraction: fm(t) = Mm(t) / MC –> data_dict[:gas][\"FRAC\"][3, :]\nStellar fraction:       fs(t) = Ms(t) / MC –> data_dict[:gas][\"FRAC\"][4, :]\nMetal fraction:         fZ(t) = MZ(t) / MC –> data_dict[:gas][\"FRAC\"][5, :]\nDust fraction:          fd(t) = Md(t) / MC –> data_dict[:gas][\"FRAC\"][6, :]\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.SFR_REL_PATH","page":"Arepo constants","title":"GalaxyInspector.SFR_REL_PATH","text":"Relative path, within the simulation directory, of sfr.txt.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.SNAP_BASENAME","page":"Arepo constants","title":"GalaxyInspector.SNAP_BASENAME","text":"Base name of the snapshot files, set in the code variable SnapshotFileBase.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.SOLAR_METALLICITY","page":"Arepo constants","title":"GalaxyInspector.SOLAR_METALLICITY","text":"Solar metallicity, as used in Arepo.\n\nReferences\n\nM. Asplund et al. (2006). The new solar abundances - Part I: the observations. Communications in Asteroseismology, 147. doi:10.1553/cia147s76\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.THRESHOLD_DENSITY","page":"Arepo constants","title":"GalaxyInspector.THRESHOLD_DENSITY","text":"Threshold density above which the gas cells/particles can turn into stars.\n\nThis value corresponds to CritPhysDensity = 0318  mathrmcm^-3 in the param.txt file (used in cosmological and non-cosmological simulations). Which is converted to internal units within the code using PhysDensThresh = CritPhysDensity * PROTONMASS / HYDROGEN_MASSFRAC / UnitDensity_in_cgs. Then, to go to physical units again one has to do: PhysDensThresh * UnitDensity_in_cgs * cf_a3inv * HubbleParam * HubbleParam.\n\nPhysDensThresh = 103378 times 10^6 [internal units of density]\n\nFor a cosmological simulation at redshift 0 (cf_a3inv = 1), this result in a physical density threshold of 0192  mathrmcm^-3, or, adding the proton mass, a value of\n\nlog_10 rho  mathrmM_odot  kpc^-3 = 6677\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/arepo/#GalaxyInspector.TRACER_MASS","page":"Arepo constants","title":"GalaxyInspector.TRACER_MASS","text":"Mass of the tracers in internal code units. Its value comes from All.TargetGasMass = All.TargetGasMassFactor * All.ReferenceGasPartMass in the code.\n\nIt is only printed in the output files (stdout_n), as All.TargetGasMass=3.65456e-06\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#Quantities","page":"Quantities","title":"Quantities","text":"This is a list of constant related to code and derived quantities used in GalaxyInspector.\n\nNone of these are exported.\n\n","category":"section"},{"location":"api/constants/quantities/#GalaxyInspector.COMPONENTS","page":"Quantities","title":"GalaxyInspector.COMPONENTS","text":"List of symbols for the physical components of a simulation.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.DERIVED_QTY","page":"Quantities","title":"GalaxyInspector.DERIVED_QTY","text":"List of symbols for the derived quantities (component + magnitude).\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.HALO_KEYS","page":"Quantities","title":"GalaxyInspector.HALO_KEYS","text":"Dictionary mapping each halo quantity with its QUANTITIES key.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.MAGNITUDES","page":"Quantities","title":"GalaxyInspector.MAGNITUDES","text":"List of symbols for physical magnitudes.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.QTY_GLOBAL_LIST","page":"Quantities","title":"GalaxyInspector.QTY_GLOBAL_LIST","text":"List of symbols for almost all the quantities in GalaxyInspector.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.QUANTITIES","page":"Quantities","title":"GalaxyInspector.QUANTITIES","text":"Dimensional properties for the quantities in the code.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.QUANTITY_SPLITS","page":"Quantities","title":"GalaxyInspector.QUANTITY_SPLITS","text":"Dictionary mapping each derived quantity to its component and magnitude.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.RATIO_QTY","page":"Quantities","title":"GalaxyInspector.RATIO_QTY","text":"List of symbols for the ratios between derived quantities.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.RATIO_SPLITS","page":"Quantities","title":"GalaxyInspector.RATIO_SPLITS","text":"Dictionary mapping each ratio to its two derived quantities.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.SFM_DERIVED_MAGNITUDES","page":"Quantities","title":"GalaxyInspector.SFM_DERIVED_MAGNITUDES","text":"List of symbols for every derived code magnitude in our SF model.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.SFM_DERIVED_QTY","page":"Quantities","title":"GalaxyInspector.SFM_DERIVED_QTY","text":"List of symbols for every derived code quantity in our SF model.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.SFM_DERIVED_QTY_SPLITS","page":"Quantities","title":"GalaxyInspector.SFM_DERIVED_QTY_SPLITS","text":"Dictionary mapping each derived code quantity to its component and magnitude.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.SFM_GAS_DERIVED_QTY","page":"Quantities","title":"GalaxyInspector.SFM_GAS_DERIVED_QTY","text":"List of symbols for every derived code quantity associated with a gas cell in our SF model.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.SFM_GAS_QTY","page":"Quantities","title":"GalaxyInspector.SFM_GAS_QTY","text":"List of symbols for every code quantity associated with a gas cell in our SF model.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.SFM_KEYS","page":"Quantities","title":"GalaxyInspector.SFM_KEYS","text":"Dictionary mapping each code quantity in our SF model with its QUANTITIES key.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.SFM_QTY","page":"Quantities","title":"GalaxyInspector.SFM_QTY","text":"List of symbols for every code quantity in our SF model.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.SFM_QTY_SPLITS","page":"Quantities","title":"GalaxyInspector.SFM_QTY_SPLITS","text":"Dictionary mapping each code quantity in our SF model to its component and magnitude.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.SFM_STELLAR_DERIVED_QTY","page":"Quantities","title":"GalaxyInspector.SFM_STELLAR_DERIVED_QTY","text":"List of symbols for every derived code quantity associated with a stellar particle in our SF model.\n\nThis values come from the state of the parent gas cell (at the stellar birth time).\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.SFM_STELLAR_QTY","page":"Quantities","title":"GalaxyInspector.SFM_STELLAR_QTY","text":"List of symbols for every code quantity associated with a stellar particle in our SF model.\n\nThis values come from the state of the parent gas cell (at the stellar birth time).\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/quantities/#GalaxyInspector.parseHaloQuantity-Tuple{Symbol}","page":"Quantities","title":"GalaxyInspector.parseHaloQuantity","text":"parseHaloQuantity(s::Symbol)::Tuple{Symbol,Int}\n\nTakes a symbol for an halo (FoF group) quantity in the format :quantity_haloidx and splits it into the text part as a Symbol and the number part as an Int.\n\nArguments\n\ns::Symbol: Target halo and halo quantity, e.g., :halo_mass_12. The index of the target halo starts at 1 and the halo quantity has to be one of the keys of HALO_KEYS.\n\nReturns\n\nA Tuple with two elements:\nA Symbol for the target quantity.\nThe index of the target halo.\n\nExamples\n\njulia> parseHaloQuantity(:halo_mass_12)\n(:halo_mass, 12)\n\njulia> parseHaloQuantity(:halo_M200_1)\n(:halo_M200, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/energies/#Computation-of-energy-related-quantities","page":"Computation of energy related quantities","title":"Computation of energy related quantities","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/analysis/compute_quantities/energies/#GalaxyInspector.computeKineticEnergy-Tuple{Dict, Symbol}","page":"Computation of energy related quantities","title":"GalaxyInspector.computeKineticEnergy","text":"computeKineticEnergy(data_dict::Dict, component::Symbol)::Vector{<:Unitful.Energy}\n\nCompute the kinetic energy.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component:\nIf component ∈ [:stellar, :darkmatter, :blackhole, :gas]:\ncomponent => [\"VEL \", \"MASS\"]\nIf component == :Z_stellar\n:stellar => [\"VEL \", \"MASS\", \"GZ2 \"]\nIf component ∈ [:hydrogen, :helium]:\n:gas => [\"VEL \", \"MASS\"]\nIf component == :Z_gas:\n:gas => [\"VEL \", \"MASS\", \"GZ  \"]\nIf component ∈ [:ionized, :neutral]:\n:gas => [\"VEL \", \"MASS\", \"NH  \", \"NHP \"]\nIf component ∈ [:bratomic, :brmolecular]:\n:gas => [\"VEL \", \"MASS\", \"NH  \", \"NHP \", \"PRES\"]\nIf component ∈ [:odeionized, :odeatomic, :odemetals, :odedust, :ode_neutral]:\n:gas => [\"VEL \", \"MASS\", \"NH  \", \"NHP \", \"FRAC\", \"RHO \", \"GZ  \"]\nIf component ∈ [:odemolecular, :odestellar]:\n:gas => [\"VEL \", \"MASS\", \"FRAC\", \"RHO \"]\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nThe kinetic energy of each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/energies/#GalaxyInspector.computeKineticEnergy-Tuple{Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}, Matrix{<:Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}}","page":"Computation of energy related quantities","title":"GalaxyInspector.computeKineticEnergy","text":"computeKineticEnergy(\n    masses::Vector{<:Unitful.Mass},\n    velocities::Matrix{<:Unitful.Velocity},\n)::Vector{<:Unitful.Energy}\n\nCompute the kinetic energy.\n\nArguments\n\nmasses::Vector{<:Unitful.Mass}: Mass of every cell/particle.\nvelocities::Matrix{<:Unitful.Velocity}: Velocities of the cells/particles. Each column is a cell/particle and each row a dimension.\n\nReturns\n\nThe kinetic energy of each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/energies/#GalaxyInspector.computePotentialEnergy-Tuple{Dict, Symbol}","page":"Computation of energy related quantities","title":"GalaxyInspector.computePotentialEnergy","text":"computePotentialEnergy(data_dict::Dict, component::Symbol)::Vector{<:Unitful.Energy}\n\nCompute the gravitational potencial energy.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component:\nIf component ∈ [:stellar, :darkmatter, :blackhole, :gas]:\ncomponent => [\"POT \", \"MASS\"]\nIf component == :Z_stellar\n:stellar => [\"POT \", \"MASS\", \"GZ2 \"]\nIf component ∈ [:hydrogen, :helium]:\n:gas => [\"POT \", \"MASS\"]\nIf component == :Z_gas:\n:gas => [\"POT \", \"MASS\", \"GZ  \"]\nIf component ∈ [:ionized, :neutral]:\n:gas => [\"POT \", \"MASS\", \"NH  \", \"NHP \"]\nIf component ∈ [:bratomic, :brmolecular]:\n:gas => [\"POT \", \"MASS\", \"NH  \", \"NHP \", \"PRES\"]\nIf component ∈ [:odeionized, :odeatomic, :odemetals, :odedust, :ode_neutral]:\n:gas => [\"POT \", \"MASS\", \"NH  \", \"NHP \", \"FRAC\", \"RHO \", \"GZ  \"]\nIf component ∈ [:odemolecular, :odestellar]:\n:gas => [\"POT \", \"MASS\", \"FRAC\", \"RHO \"]\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nThe gravitational potencial energy of each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/energies/#GalaxyInspector.computePotentialEnergy-Tuple{Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐋^2 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐓^-2, U}} where {L, S}} where {T, U}}}","page":"Computation of energy related quantities","title":"GalaxyInspector.computePotentialEnergy","text":"computePotentialEnergy(\n    masses::Vector{<:Unitful.Mass},\n    potential::Vector{<:SpecificEnergy},\n)::Vector{<:Unitful.Energy}\n\nCompute the gravitational potencial energy.\n\nArguments\n\nmasses::Vector{<:Unitful.Mass}: Mass of every cell/particle.\npotential::Vector{<:SpecificEnergy}: Specific potential energy of every cell/particle.\n\nReturns\n\nThe gravitational potencial energy of each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/energies/#GalaxyInspector.computeTemperature-Tuple{Vector{<:Union{Unitful.Quantity{T, 𝐋^2 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐓^-2, U}} where {L, S}} where {T, U}}, Vector{Float32}}","page":"Computation of energy related quantities","title":"GalaxyInspector.computeTemperature","text":"computeTemperature(\n    internal_energy::Vector{<:SpecificEnergy},\n    electron_fraction::Vector{Float32},\n)::Vector{<:Unitful.Temperature}\n\nCompute the gas temperature.\n\nArguments\n\ninternal_energy::Vector{<:SpecificEnergy}: Specific internal energy of every gas cell.\nelectron_fraction::Vector{Float32}: Number fraction of electrons in every gas cell.\n\nReturns\n\nThe temperature of each gas cell.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/energies/#GalaxyInspector.computeTotalEnergy-Tuple{Dict, Symbol}","page":"Computation of energy related quantities","title":"GalaxyInspector.computeTotalEnergy","text":"computeTotalEnergy(data_dict::Dict, component::Symbol)::Vector{<:Unitful.Energy}\n\nCompute the total energy (kinetic + potential).\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component:\nIf component ∈ [:stellar, :darkmatter, :blackhole, :gas]:\ncomponent => [\"VEL \", \"POT \", \"MASS\"]\nIf component == :Z_stellar\n:stellar => [\"VEL \", \"POT \", \"MASS\", \"GZ2 \"]\nIf component ∈ [:hydrogen, :helium]:\n:gas => [\"VEL \", \"POT \", \"MASS\"]\nIf component == :Z_gas:\n:gas => [\"VEL \", \"POT \", \"MASS\", \"GZ  \"]\nIf component ∈ [:ionized, :neutral]:\n:gas => [\"VEL \", \"POT \", \"MASS\", \"NH  \", \"NHP \"]\nIf component ∈ [:bratomic, :brmolecular]:\n:gas => [\"VEL \", \"POT \", \"MASS\", \"NH  \", \"NHP \", \"PRES\"]\nIf component ∈ [:odeionized, :odeatomic, :odemetals, :odedust, :ode_neutral]:\n:gas => [\"VEL \", \"POT \", \"MASS\", \"NH  \", \"NHP \", \"FRAC\", \"RHO \", \"GZ  \"]\nIf component ∈ [:odemolecular, :odestellar]:\n:gas => [\"VEL \", \"POT \", \"MASS\", \"FRAC\", \"RHO \"]\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nThe total energy of each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/sfm/#Compute-derived-code-quantities-for-our-star-formation-model","page":"Compute derived code quantities for our star formation model","title":"Compute derived code quantities for our star formation model","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/analysis/compute_quantities/sfm/#GalaxyInspector.computeDerivedSFMQty-Tuple{Dict, Symbol}","page":"Compute derived code quantities for our star formation model","title":"GalaxyInspector.computeDerivedSFMQty","text":"computeDerivedSFMQty(data_dict::Dict, quantity::Symbol)::Vector{<:Number}\n\nCompute a derived code quantity for our star formation model.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component and magnitude:\nIf magnitude == :tau_star\ntype => [\"RHOC\"]\nIf magnitude == :tau_rec\ntype => [\"RHOC\", \"FRAC\"]\nIf magnitude == :tau_cond\ntype => [\"RHOC\", \"FRAC\"]\nIf magnitude == :tau_dg\ntype => [\"RHOC\", \"FRAC\"]\nIf magnitude == :tau_dc\ntype => [\"RHOC\", \"FRAC\"]\nIf magnitude == :tau_ion\ntype => [\"RHOC\", \"PARH\", \"FRAC\"]\nIf magnitude == :tau_diss\ntype => [\"RHOC\", \"PARH\", \"FRAC\"]\nIf magnitude == :S_d\ntype => [\"RHOC\", \"PARH\", \"FRAC\"]\nIf magnitude == :S_H2\ntype => [\"RHOC\", \"PARH\", \"FRAC\"]\nIf magnitude == :equivalent_size\n:gas => [\"RHOC\", \"MASS\"] or :stellar => [\"RHOC\", \"GMAS\"]\nwhere\nIf component == :odegas\ntype = :gas\nIf component == :odestellar\ntype = :stellar\nquantity::Symbol: Target quantity. It can only be one of the elements of SFM_DERIVED_QTY.\n\nReturns\n\nquantity for each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#Index","page":"Function Index","title":"Index","text":"","category":"section"},{"location":"api/auxiliary_functions/histograms/#Histogram-utilities","page":"Histogram utilities","title":"Histogram utilities","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/auxiliary_functions/histograms/#GalaxyInspector.computeBandProfile-Tuple{Matrix{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Vector{<:Number}, GalaxyInspector.CircularGrid}","page":"Histogram utilities","title":"GalaxyInspector.computeBandProfile","text":"computeBandProfile(\n    positions::Matrix{<:Unitful.Length},\n    quantity::Vector{<:Number},\n    grid::CircularGrid;\n    <keyword arguments>\n)::NTuple{3,Vector{<:Number}}\n\nCompute a profile of quantity, using an 1D histogram and three given aggregator functions.\n\nEach aggregator functions with the signature:\n\n`agg_func(::Vector{<:Number}) -> ::Number`\n\nwill be used to accumulate the values of quantity within each bin.\n\nArguments\n\npositions::Matrix{<:Unitful.Length}: Positions of the cells/particles. Each column is a cell/particle and each row a dimension.\nquantity::Vector{<:Number}: The profile will be of this quantity.\ngrid::CircularGrid: Circular grid.\nflat::Bool=true: If the profile will be 2D, using rings, or 3D, using spherical shells.\ndensity::Bool=false: If the profile will be of the density of quantity.\ncenter_func::Function=x->quantile(x, 0.5): Aggregator function for the central value.\nlow_func::Function=x->quantile(x, 0.25): Aggregator function for the low value.\nhigh_func::Function=x->quantile(x, 0.75): Aggregator function for the high value.\n\nReturns\n\nA tuple with three elements:\nA vector with the central value for each bin.\nA vector with the low value for each bin.\nA vector with the high value for each bin.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/histograms/#GalaxyInspector.computeProfile-Tuple{Matrix{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Vector{<:Number}, GalaxyInspector.CircularGrid}","page":"Histogram utilities","title":"GalaxyInspector.computeProfile","text":"computeProfile(\n    positions::Matrix{<:Unitful.Length},\n    quantity::Vector{<:Number},\n    grid::CircularGrid;\n    <keyword arguments>\n)::Vector{<:Number}\n\nCompute a profile of quantity, using an 1D histogram.\n\nArguments\n\npositions::Matrix{<:Unitful.Length}: Positions of the cells/particles. Each column is a cell/particle and each row a dimension.\nquantity::Vector{<:Number}: The profile will be of this quantity.\ngrid::CircularGrid: Circular grid.\nnorm::Vector{<:Number}=Number[]: The value of quantity in each bin will be divided by the corresponding value of norm.\nflat::Bool=true: If the profile will be 2D (rings), or 3D (spherical shells).\ntotal::Bool=true: If the sum (default) or the mean of quantity will be computed for each bin.\ncumulative::Bool=false: If the profile will be accumulated.\ndensity::Bool=false: If the profile will be of the density of quantity.\nempty_nan::Bool=true: If empty bins will be set to NaN. 0 is used otherwise. Notice that if empty_nan = true and cumulative = true, every bin after the first NaN will be set to NaN.\n\nReturns\n\nVector with the values of the profile.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/histograms/#GalaxyInspector.histogram1D-Tuple{Vector{<:Number}, Union{GalaxyInspector.CircularGrid, GalaxyInspector.LinearGrid}}","page":"Histogram utilities","title":"GalaxyInspector.histogram1D","text":"histogram1D(\n    positions::Vector{<:Number},\n    grid::Union{LinearGrid,CircularGrid};\n    <keyword arguments>\n)::Vector{Float64}\n\nCompute a 1D histogram of positions.\n\nArguments\n\npositions::Vector{<:Number}: Values for which the histogram will be constructed.\ngrid::Union{LinearGrid,CircularGrid}: A linear or circular grid.\nempty_nan::Bool=true: If NaN will be put into empty bins, 0 is used otherwise.\n\nReturns\n\nA vector with the counts.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/histograms/#GalaxyInspector.histogram1D-Tuple{Vector{<:Number}, Vector{<:Number}, Union{GalaxyInspector.CircularGrid, GalaxyInspector.LinearGrid}}","page":"Histogram utilities","title":"GalaxyInspector.histogram1D","text":"histogram1D(\n    positions::Vector{<:Number},\n    values::Vector{<:Number},\n    grid::Union{LinearGrid,CircularGrid};\n    <keyword arguments>\n)::Vector{<:Number}\n\nCompute a 1D histogram of values.\n\nArguments\n\npositions::Vector{<:Number}: Positions of the values within a 1D axis.\nvalues::Vector{<:Number}: The values that will be added up to each bin, according to their positions.\ngrid::Union{LinearGrid,CircularGrid}: A linear or circular grid.\ntotal::Bool=true: If the sum (total = true) or the mean (total = false) of values will be computed for each bin.\nempty_nan::Bool=true: If NaN will be put into empty bins, 0 is used otherwise.\n\nReturns\n\nA vector with the histogram values.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/histograms/#GalaxyInspector.histogram1D-Tuple{Vector{<:Number}, Vector{<:Number}, Vector{<:Number}}","page":"Histogram utilities","title":"GalaxyInspector.histogram1D","text":"histogram1D(\n    positions::Vector{<:Number},\n    values::Vector{<:Number},\n    edges::Vector{<:Number};\n    <keyword arguments>\n)::Vector{<:Number}\n\nCompute a 1D histogram of values.\n\nArguments\n\npositions::Vector{<:Number}: Positions of the values within a 1D axis.\nvalues::Vector{<:Number}: The values that will be added up in each bin, according to their positions.\nedges::Vector{<:Number}: A list of bin edges.\ntotal::Bool=true: If the sum (total = true) or the mean (total = false) of values will be computed for each bin.\nempty_nan::Bool=true: If NaN will be put into empty bins, 0 is used otherwise.\n\nReturns\n\nA vector with the histogram values.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/histograms/#GalaxyInspector.histogram1D-Tuple{Vector{<:Number}, Vector{<:Number}}","page":"Histogram utilities","title":"GalaxyInspector.histogram1D","text":"histogram1D(\n    positions::Vector{<:Number},\n    edges::Vector{<:Number};\n    <keyword arguments>\n)::Vector{Float64}\n\nCompute a 1D histogram of positions.\n\nArguments\n\npositions::Vector{<:Number}: Values for which the histogram will be constructed.\nedges::Vector{<:Number}: A list of bin edges.\nempty_nan::Bool=true: If NaN will be put into empty bins, 0 is used otherwise.\n\nReturns\n\nA vector with the counts.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/histograms/#GalaxyInspector.histogram2D-Tuple{Matrix{<:Number}, Vector{<:Number}, GalaxyInspector.SquareGrid}","page":"Histogram utilities","title":"GalaxyInspector.histogram2D","text":"histogram2D(\n    positions::Matrix{<:Number},\n    values::Vector{<:Number},\n    grid::SquareGrid;\n    <keyword arguments>\n)::Matrix{<:Number}\n\nCompute a 2D histogram of values.\n\nArguments\n\npositions::Matrix{<:Number}: Positions of the values in the grid. Each column corresponds to a value and each row is a dimension.\nvalues::Vector{<:Number}: The values that will be added up in each square bin, according to their positions.\ngrid::SquareGrid: A square grid.\ntotal::Bool=true: If the sum (total = true) or the mean (total = false) of values will be computed for each bin.\nempty_nan::Bool=true: If NaN will be put into empty bins, 0 is used otherwise.\n\nReturns\n\nA matrix with the histogram values.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/histograms/#GalaxyInspector.histogram2D-Tuple{Matrix{<:Number}, Vector{<:Number}, Vector{<:Number}, Vector{<:Number}}","page":"Histogram utilities","title":"GalaxyInspector.histogram2D","text":"histogram2D(\n    positions::Matrix{<:Number},\n    values::Vector{<:Number},\n    x_edges::Vector{<:Number},\n    y_edges::Vector{<:Number};\n    <keyword arguments>\n)::Matrix{<:Number}\n\nCompute a 2D histogram of values.\n\nArguments\n\npositions::Matrix{<:Number}: Positions of the values in the grid. Each column corresponds to a value and each row is a dimension.\nvalues::Vector{<:Number}: The values that will be added up in each square bin, according to their positions.\nx_edges::Vector{<:Number}: A list of bin edges for the x axis.\ny_edges::Vector{<:Number}: A list of bin edges for the y axis.\ntotal::Bool=true: If the sum (total = true) or the mean (total = false) of values will be computed for each bin.\nempty_nan::Bool=true: If NaN will be put into empty bins, 0 is used otherwise.\n\nReturns\n\nA matrix with the histogram values.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/histograms/#GalaxyInspector.histogram2D-Tuple{Matrix{<:Number}, Vector{<:Number}, Vector{<:Number}}","page":"Histogram utilities","title":"GalaxyInspector.histogram2D","text":"histogram2D(\n    positions::Matrix{<:Number},\n    x_edges::Vector{<:Number},\n    y_edges::Vector{<:Number};\n    <keyword arguments>\n)::Matrix{Float64}\n\nCompute a 2D histogram of positions.\n\nArguments\n\npositions::Matrix{<:Number}: Values for which the histogram will be constructed.\nx_edges::Vector{<:Number}: A list of bin edges for the x axis.\ny_edges::Vector{<:Number}: A list of bin edges for the y axis.\nempty_nan::Bool=true: If NaN will be put into empty bins, 0 is used otherwise.\n\nReturns\n\nA matrix with the counts.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/histograms/#GalaxyInspector.histogram3D-Tuple{Matrix{<:Number}, Vector{<:Number}, GalaxyInspector.CubicGrid}","page":"Histogram utilities","title":"GalaxyInspector.histogram3D","text":"histogram3D(\n    positions::Matrix{<:Number},\n    values::Vector{<:Number},\n    grid::CubicGrid;\n    <keyword arguments>\n)::Array{<:Number,3}\n\nCompute a 3D histogram of values.\n\nArguments\n\npositions::Matrix{<:Number}: Positions of the values in the grid. Each column corresponds to a value and each row is a dimension.\nvalues::Vector{<:Number}: The values that will be added up in each square bin, according to their positions.\ngrid::CubicGrid: A cubic grid.\ntotal::Bool=true: If the sum (total = true) or the mean (total = false) of values will be computed for each bin.\nempty_nan::Bool=true: If NaN will be put into empty bins, 0 is used otherwise.\n\nReturns\n\nA 3D tensor with the histogram values.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/histograms/#GalaxyInspector.listHistogram1D-Tuple{Vector{<:Number}, Vector{<:Number}, Union{GalaxyInspector.CircularGrid, GalaxyInspector.LinearGrid}}","page":"Histogram utilities","title":"GalaxyInspector.listHistogram1D","text":"listHistogram1D(\n    positions::Vector{<:Number},\n    values::Vector{<:Number},\n    grid::Union{LinearGrid,CircularGrid},\n)::Vector{Vector{<:Number}}\n\nCompute a 1D histogram of values, returning the full list of values within each bin.\n\nArguments\n\npositions::Vector{<:Number}: The positions of values within a 1D axis.\nvalues::Vector{<:Number}: The values that will be sorted, according to their positions.\ngrid::Union{LinearGrid,CircularGrid}: A linear or circular grid.\n\nReturns\n\n- A vector with the lists of `values` within each bin.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/histograms/#GalaxyInspector.listHistogram1D-Tuple{Vector{<:Number}, Vector{<:Number}, Vector{<:Number}}","page":"Histogram utilities","title":"GalaxyInspector.listHistogram1D","text":"listHistogram1D(\n    positions::Vector{<:Number},\n    values::Vector{<:Number},\n    edges::Vector{<:Number},\n)::Vector{Vector{<:Number}}\n\nCompute a 1D histogram of values, returning the full list of values within each bin.\n\nArguments\n\npositions::Vector{<:Number}: The positions of values within a 1D axis.\nvalues::Vector{<:Number}: The values that will be sorted, according to their positions.\nedges::Vector{<:Number}: A list of bin edges.\n\nReturns\n\n- A vector with the lists of `values` within each bin.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/histograms/#GalaxyInspector.listHistogram3D-Tuple{Matrix{<:Number}, GalaxyInspector.CubicGrid}","page":"Histogram utilities","title":"GalaxyInspector.listHistogram3D","text":"listHistogram3D(positions::Matrix{<:Number}, grid::CubicGrid)::Array{Vector{Int},3}\n\nCompute a 3D histogram of positions, returning the list of indices that fall within each bin.\n\nArguments\n\npositions::Matrix{<:Number}: Positions of the points. Each column corresponds to a point and each row is a dimension.\ngrid::CubicGrid: A cubic grid.\n\nReturns\n\n- A tensor with the indices of the points within each bin.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#Convenience-functions","page":"Convenience functions","title":"Convenience functions","text":"These functions are pre-made recipes for specific plots.\n\nThey are also examples of how to use the more configurable pipeline functions.\n\nAll these functions are exported.\n\n","category":"section"},{"location":"api/plotting/convenience/#GalaxyInspector.atomicMolecularTransition-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}, Vector{<:Tuple{var\"#s80\", var\"#s79\"} where {var\"#s80\"<:Real, var\"#s79\"<:Real}}}","page":"Convenience functions","title":"GalaxyInspector.atomicMolecularTransition","text":"atomicMolecularTransition(\n    simulation_paths::Vector{String},\n    slice::IndexType,\n    ranges::Vector{<:Tuple{<:Real,<:Real}};\n    <keyword arguments>\n)::Nothing\n\nPlot the atomic to molecular gas transition for a set of metallicity ranges.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be in a different file.\nslice::IndexType: Slice of the simulations, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nranges::Vector{<:Tuple{<:Real,<:Real}}: Metallicity (in solar units) ranges.\nplot_type::Symbol=:heatmap: Type of plot. The options are:\n:heatmap -> Heatmap. One figure per range will be produced.\n:scatter -> Scatter plot. A single figure with every range will be produced.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.circularityHistogram-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.circularityHistogram","text":"circularityHistogram(\n    simulation_paths::Vector{String},\n    slice::IndexType;\n    <keyword arguments>\n)::Nothing\n\nPlot three stellar circularity histograms for each simulation. One for the stars within R_out, another for the stars within R_in, and another for the stars between R_in and R_out.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nR_in::Unitful.Length=2.0u\"kpc\": Internal radius.\nR_out::Unitful.Length=DISK_R: External radius.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.clumpingFactor-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}, Symbol}","page":"Convenience functions","title":"GalaxyInspector.clumpingFactor","text":"clumpingFactor(\n    simulation_paths::Vector{String},\n    slice::IndexType,\n    component::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot the clumping factor of component for different volume scales.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS with cell/partcile type :gas.\nn_neighbors::Int=32: Number of neighbors.\nsmooth::Int=0: The result will be average out using smooth bins for the volume. Set it to 0 if you want no smoothing.\nxlog::Bool=false: If true, sets the x axis to the log_10 of the volume.\nylog::Bool=false: If true, sets the y axis to the log_10 of the clumping factor.\nl_unit::Unitful.Units=u\"kpc\": Lenght unit for the volume.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=nothing: Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.compareAgertz2021-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.compareAgertz2021","text":"compareAgertz2021(\n    simulation_paths::Vector{String},\n    slice::IndexType;\n    <keyword arguments>\n)::Nothing\n\nPlot a stellar density profile with the corresponding experimental values of the Milky Way from Agertz et al. (2021).\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). It works over the longest simulation. Starts at 1 and out of bounds indices are ignored.\nylog::Bool=true: If true, sets the y axis as log_10 Sigma_star.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=basename.(simulation_paths): Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\nReferences\n\nO. Agertz et al. (2021). VINTERGATAN – I. The origins of chemically, kinematically, and structurally distinct discs in a simulated Milky Way-mass galaxy. Monthly Notices of the Royal Astronomical Society. **503(4), 5826–5845. doi:10.1093/mnras/stab322\n\nA. K. Leroy et al. (2008). THE STAR FORMATION EFFICIENCY IN NEARBY GALAXIES: MEASURING WHERE GAS FORMS STARS EFFECTIVELY. The Astronomical Journal 136(6), 2782–2845. doi:10.1088/0004-6256/136/6/2782\n\nP. J. McMillan (2011). Mass models of the Milky Way. Monthly Notices of the Royal Astronomical Society 414(3), 2446–2457. doi:10.1111/j.1365-2966.2011.18564.x\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.compareFeldmann2020-Tuple{Vector{String}, Symbol, Symbol}","page":"Convenience functions","title":"GalaxyInspector.compareFeldmann2020","text":"compareFeldmann2020(\n    simulation_paths::Vector{String},\n    x_component::Symbol,\n    y_component::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot a time series plus the corresponding experimental results from Feldmann (2020).\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nx_component::Symbol: Component for the x axis. The options are:\n:stellar   -> Stellar mass.\n:molecular -> Molecular hydrogen (mathrmH_2) mass.\n:atomic    -> Atomic hydrogen (mathrmHI) mass.\n:sfr       -> Star formation rate of the last AGE_RESOLUTION.\ny_component::Symbol: Component for the y axis. The options are:\n:stellar   -> Stellar mass.\n:molecular -> Molecular hydrogen (mathrmH_2) mass.\n:atomic    -> Atomic hydrogen (mathrmHI) mass.\n:sfr       -> Star formation rate of the last AGE_RESOLUTION.\nslice::IndexType=(:): Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nscatter::Bool=false: If the data will be presented as a line plot with error bands (default), or a scatter plot.\nxlog::Bool=true: If true, sets the x axis to log_10(x_quantity).\nylog::Bool=true: If true, sets the y axis to log_10(y_quantity).\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=basename.(simulation_paths): Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\nReferences\n\nR. Feldmann (2020). The link between star formation and gas in nearby galaxies. Communications Physics 3(226). doi:10.1038/s42005-020-00493-0\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.compareMolla2015-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}, Symbol}","page":"Convenience functions","title":"GalaxyInspector.compareMolla2015","text":"compareMolla2015(\n    simulation_paths::Vector{String},\n    slice::IndexType,\n    quantity::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot a profile with the corresponding experimental values of the Milky Way from Mollá et al. (2015).\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). It works over the longest simulation. Starts at 1 and out of bounds indices are ignored.\nquantity::Symbol: Quantity for the y axis. The options are:\n:stellar_area_density       -> Stellar mass surface density.\n:sfr_area_density           -> Star formation rate surface density.\n:ode_molecular_area_density -> Molecular mass surface density.\n:br_molecular_area_density  -> Molecular mass surface density, computed using the pressure relation in Blitz et al. (2006).\n:ode_atomic_area_density    -> Atomic mass surface density.\n:br_atomic_area_density     -> Atomic mass surface density, computed using the pressure relation in Blitz et al. (2006).\n:O_stellar_abundance        -> Stellar abundance of oxygen, as 12 + log_10(mathrmO    H).\n:N_stellar_abundance        -> Stellar abundance of nitrogen, as 12 + log_10(mathrmN    H).\n:C_stellar_abundance        -> Stellar abundance of carbon, as 12 + log_10(mathrmC    H).\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=basename.(simulation_paths): Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\nReferences\n\nL. Blitz et al. (2006). The Role of Pressure in GMC Formation II: The H2-Pressure Relation. The Astrophysical Journal, 650(2), 933. doi:10.1086/505417\n\nM. Mollá et al. (2015). Galactic chemical evolution: stellar yields and the initial mass function. Monthly Notices of the Royal Astronomical Society 451(4), 3693–3708. doi:10.1093/mnras/stv1102\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.cpuTXT-Tuple{Vector{String}, String, Symbol, Symbol}","page":"Convenience functions","title":"GalaxyInspector.cpuTXT","text":"cpuTXT(\n    simulation_paths::Vector{String},\n    target::String,\n    x_quantity::Symbol,\n    y_quantity::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot a time series of the data in the cpu.txt file.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\ntarget::String: Target process.\nx_quantity::Symbol: Quantity for the x axis. The options are:\n:time_step              -> Time step.\n:physical_time          -> Physical time since the Big Bang.\n:clock_time_s           -> Clock time duration of the time step in seconds.\n:clock_time_percent     -> Clock time duration of the time step as a percentage.\n:tot_clock_time_s       -> Total clock time in seconds.\n:tot_clock_time_percent -> Total clock time as a percentage.\ny_quantity::Symbol: Quantity for the y axis. The options are:\n:time_step              -> Time step.\n:physical_time          -> Physical time since the Big Bang.\n:clock_time_s           -> Clock time duration of the time step in seconds.\n:clock_time_percent     -> Clock time duration of the time step as a percentage.\n:tot_clock_time_s       -> Total clock time in seconds.\n:tot_clock_time_percent -> Total clock time as a percentage.\nsmooth::Int=0: The result will be smoothed out using smooth bins. Set it to 0 if you want no smoothing.\nylog::Bool=false: If the y axis is will have a log_10 scale.\nx_trim::NTuple{2,<:Real}=(-Inf, Inf): The data will be trim down so the x coordinates fit within x_trim.\ny_trim::NTuple{2,<:Real}=(-Inf, Inf): The data will be trim down so the y coordinates fit within y_trim.\noutput_path::String=\".\": Path to the output folder.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=basename.(simulation_paths): Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.densityMap-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.densityMap","text":"densityMap(\n    simulation_paths::Vector{String},\n    slice::IndexType;\n    <keyword arguments>\n)::Nothing\n\nPlot a 2D projection of the component mass density.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\ncomponents::Vector{Symbol}=[:gas]: Target components. It can be any of the elements of COMPONENTS.\nfield_types::Vector{Symbol}=[:cells]: If the field, of each of the components, is made up of :particles or Voronoi :cells.\nprojection_planes::Vector{Symbol}=[:xy]: Projection planes. The options are :xy, :xz, and :yz.\nbox_size::Unitful.Length=100u\"kpc\": Physical side length of the plot window.\npixel_length::Unitful.Length=0.1u\"kpc\": Side length of each bin.\nreduce_factor::Int=1: Factor by which the resolution of the result will be reduced. This will be applied after the density projection, averaging the value of neighboring pixels. It has to divide the size of grid exactly.\nm_unit::Unitful.Units=u\"Msun\": Mass unit.\nl_unit::Unitful.Units=u\"pc\": Length unit.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ntitle::Union{Symbol,<:AbstractString}=\"\": Title for the figure. If left empty, no title is printed. It can also be set to one of the following options:\n:physical_time -> Physical time since the Big Bang.\n:lookback_time -> Physical time left to reach the last snapshot.\n:scale_factor  -> Scale factor (only relevant for cosmological simulations).\n:redshift      -> Redshift (only relevant for cosmological simulations).\nannotation::AbstractString=\"\": Text to be added into the top left corner of the plot. If left empty, nothing is printed.\ncolorbar::Bool=false: If a colorbar will be added.\ncolorrange::Union{Nothing,Tuple{<:Real,<:Real}}=nothing: Sets the start and end points of the colormap. Use nothing to use the extrema of the density values.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.densityMapVelField-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.densityMapVelField","text":"densityMapVelField(\n    simulation_paths::Vector{String},\n    slice::IndexType;\n    <keyword arguments>\n)::Nothing\n\nPlot a 2D projection of the mass density of component, with the velocity field.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\ncomponents::Vector{Symbol}=[:gas]: Target components. It can only be one of the elements of COMPONENTS.\nfield_types::Vector{Symbol}=[:cells]: If the field, of each of the components, is made up of :particles or Voronoi :cells.\nprojection_planes::Vector{Symbol}=[:xy]: Projection planes. The options are :xy, :xz, and :yz.\nbox_size::Unitful.Length=100u\"kpc\": Physical side length of the plot window.\npixel_length::Unitful.Length=0.1u\"kpc\": Side length of each bin.\nreduce_factor::Int=1: Factor by which the resolution of the result will be reduced. This will be applied after the density projection, averaging the value of neighboring pixels. It has to divide the size of grid exactly.\nm_unit::Unitful.Units=u\"Msun\": Mass unit.\nl_unit::Unitful.Units=u\"pc\": Length unit.\nv_unit::Unitful.Units=u\"km * s^-1\",: Velocity unit\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ntitle::Union{Symbol,<:AbstractString}=\"\": Title for the figure. If left empty, no title is printed. It can also be set to one of the following options:\n:physical_time -> Physical time since the Big Bang.\n:lookback_time -> Physical time left to reach the last snapshot.\n:scale_factor  -> Scale factor (only relevant for cosmological simulations).\n:redshift      -> Redshift (only relevant for cosmological simulations).\nannotation::AbstractString=\"\": Text to be added into the top left corner of the plot. If left empty, nothing is printed.\ncolorbar::Bool=false: If a colorbar will be added.\ncolorrange::Union{Nothing,Tuple{<:Real,<:Real}}=nothing: Sets the start and end points of the colormap. Use nothing to use the extrema of the density values.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.diskAccretionEvolution-Tuple{Vector{String}}","page":"Convenience functions","title":"GalaxyInspector.diskAccretionEvolution","text":"diskAccretionEvolution(\n    simulation_paths::Vector{String};\n    <keyword arguments>\n)::Nothing\n\nPlot a time series of the accreted mass into a given disc.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nslice::IndexType=(:): Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nflux_direction::Symbol=:net: What flux direction will be plotted. The options are:\n:net_mass     -> Net accreted mass.\n:inflow_mass  -> Inflow mass only.\n:outflow_mass -> Outflow mass only.\nmax_r::Unitful.Length=DISK_R: Radius of the disk.\nmax_z::Unitful.Length=5.0u\"kpc\": Half height of the disk.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles. For options see selectTransformation.\ncomponent::Symbol=:all: Component to compute the accreted mass for. The options are:\n:dark_matter -> Dark matter.\n:black_hole  -> Black holes.\n:gas         -> Gas.\n:stellar     -> Stars.\n:all         -> All the matter.\ntracers::Bool=false: If tracers will be use to compute the mass accretion.\nsmooth::Int=0: The time series will be smoothed out using smooth bins. Set it to 0 if you want no smoothing.\noutput_path::String=\".\": Path to the output folder.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=nothing: Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.efficiencyHistogram-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.efficiencyHistogram","text":"efficiencyHistogram(\n    simulation_paths::Vector{String},\n    slice::IndexType;\n    <keyword arguments>\n)::Nothing\n\nPlot two histogram of the efficiency per free-fall time, for each simulation. One for the progenitors of the stars and the other for the gas.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nrange::NTuple{2,Float64}=(1.0e-4, 1.0): Range for the efficiency per free-fall time (x axis).\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nstellar_ff::Function=filterNothing: Filter function to be applied to the stellar histogram after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\ngas_ff::Function=filterNothing: Filter function to be applied to the gas histogram after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for stellar_ff and gas_ff.\nlabels::Vector{<:AbstractString}=[\"Stars\", \"Gas\"]: Legend for the stellar and gas histograms, respectively.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.evolutionVideo-Tuple{Vector{String}, Symbol}","page":"Convenience functions","title":"GalaxyInspector.evolutionVideo","text":"evolutionVideo(\n    simulation_paths::Vector{String},\n    component::Symbol;\n    <keyword arguments>\n)::Nothing\n\nMake a video of how the projected density (xy and xz planes) evolves through time, for the stars, gas, and a given gas component.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will have a different video.\ncomponent::Symbol: Target gas component. See COMPONENTS for options.\nslice::IndexType=(:): Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nfield_type::Symbol=cells: If the gas field is made up of :particles or Voronoi :cells.\nbox_size::Unitful.Length=BOX_L: Size of the plotting box.\noutput_path::String=\".\": Path to the output folder.\ndensity_range::NTuple{2,Float64}=(NaN,NaN): Area density range in log_10 mathrmM_odot  kpc^-2 for the component and gas. If set to NaN a value is chosen automatically.\nframerate::Int64=20: Video framerate.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daDensity2DProjection after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\nshow_progress::Bool=true: If a progress bar will be shown.\nsave_data::Bool=false: If the density maps data will be saved in JLD2 files.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.fitVSFLaw-Tuple{String, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}, Symbol}","page":"Convenience functions","title":"GalaxyInspector.fitVSFLaw","text":"fitVSFLaw(\n    simulation_path::String,\n    slice::IndexType,\n    component::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot the resolved volumetric star formation (VSF) law with an optional linear fit.\n\nnote: Note\nOnly stars younger than AGE_RESOLUTION are considered.\n\nnote: Note\nThe star formation surface density is just the stellar mass surface density divided by AGE_RESOLUTION.\n\nArguments\n\nsimulation_path::String: Path to the simulation directory, set in the code variable OutputDir.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\nfield_type::Symbol=:cells: If the gas surface density will be calculated assuming the gas is in :particles or in Voronoi :cells.\nfit::Bool=true: If a fit of the plotted values will be added on top of the scatter plot.\nbox_size::Unitful.Length=BOX_L: Physical side length for the grids.\nx_range::NTuple{2,<:Real}=(-Inf, Inf): Only the data withing this range (for the x coordinates) will be fitted.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nsim_label::Union{String,Nothing}=basename(simulation_path): Label for the plot legend. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.gasBarPlot-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}, Symbol, Vector{<:Number}}","page":"Convenience functions","title":"GalaxyInspector.gasBarPlot","text":"gasBarPlot(\n    simulation_paths::Vector{String},\n    slice::IndexType,\n    quantity::Symbol,\n    edges::Vector{<:Number};\n    <keyword arguments>\n)::Nothing\n\nPlot a bar plot of the gas fractions, where the bins are a given gas quantity.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nquantity::Symbol: Target quantity. It can be any of the valid quantities of scatterQty with the cell/particle type :gas.\nedges::Vector{<:Number}: A list of bin edges for quantity.\ncomponents::Vector{Symbol}=[:ode_ionized, :ode_atomic, :ode_molecular]: List of gas components to be considered. The fractions will be normalized to this list of components. See COMPONENTS for options.\nylog::Bool=false: If true, sets everything so the y axis is log_10(quantity).\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.gasDensityMaps-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.gasDensityMaps","text":"gasDensityMaps(\n    simulation_paths::Vector{String},\n    slice::IndexType;\n    <keyword arguments>\n)::Nothing\n\nPlot the density map of five gas components for the xy and xz projections, in several panels.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nbox_size::Unitful.Length=BOX_L: Size of the plotting box.\noutput_path::String=\".\": Path to the output folder.\ndensity_range::NTuple{2,Float64}=(NaN,NaN): Area density range in log_10 mathrmM_odot  kpc^-2. If set to NaN a value is chosen automatically.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daDensity2DProjection after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.gasEvolution-Tuple{Vector{String}}","page":"Convenience functions","title":"GalaxyInspector.gasEvolution","text":"gasEvolution(\n    simulation_paths::Vector{String};\n    <keyword arguments>\n)::Nothing\n\nPlot a time series of the gas components. Either their masses or their fractions.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nfractions::Bool=true: If the fractions (default), or the masses, will be plotted.\nslice::IndexType=(:): Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nylog::Bool=true: If the y axis is will have a log_10 scale.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\nsmooth::Int=0: The result of integrateQty will be smoothed out using smooth bins. Set it to 0 if you want no smoothing.\nbackup_results::Bool=false: If the values to be plotted will be saved in a JLD2 file.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.gasFractionsEvolution-Tuple{Vector{String}}","page":"Convenience functions","title":"GalaxyInspector.gasFractionsEvolution","text":"gasFractionsEvolution(\n    simulation_paths::Vector{String};\n    <keyword arguments>\n)::Nothing\n\nPlot time evolution of the gas components mass and fraction, in two panels.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType=(:): Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nr_gas::Unitful.Length=DISK_R: Radius of the gas sphere to consider.\noutput_path::String=\".\": Path to the output folder.\nmass_limits::NTuple{2,Float64}=(-4.2, 1.2): Limits for the masses, log_10 M mathrmM_odot.\nfraction_limits::NTuple{2,Float64}=(-5.2, 0.2): Limits for fractions, log_10 f.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.gasSFRMap-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.gasSFRMap","text":"gasSFRMap(\n    simulation_paths::Vector{String},\n    slice::IndexType;\n    <keyword arguments>\n)::Nothing\n\nPlot a 2D projection of the gas SFR.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nfield_type::Symbol=:cells,: If the field is made up of :particles or Voronoi :cells.\nprojection_planes::Vector{Symbol}=[:xy]: Projection planes. The options are :xy, :xz, and :yz.\nbox_size::Unitful.Length=100u\"kpc\": Physical side length of the plot window.\npixel_length::Unitful.Length=0.1u\"kpc\": Side length of each bin.\nreduce_factor::Int=1: Factor by which the resolution of the result will be reduced. This will be applied after the density projection, averaging the value of neighboring pixels. It has to divide the size of grid exactly.\nm_unit::Unitful.Units=u\"Msun\": Mass unit.\nt_unit::Unitful.Units=u\"yr\": Time unit.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ntitle::Union{Symbol,<:AbstractString}=\"\": Title for the figure. If left empty, no title is printed. It can also be set to one of the following options:\n:physical_time -> Physical time since the Big Bang.\n:lookback_time -> Physical time left to reach the last snapshot.\n:scale_factor  -> Scale factor (only relevant for cosmological simulations).\n:redshift      -> Redshift (only relevant for cosmological simulations).\nannotation::AbstractString=\"\": Text to be added into the top left corner of the plot. If left empty, nothing is printed.\ncolorbar::Bool=false: If a colorbar will be added.\ncolorrange::Union{Nothing,Tuple{<:Real,<:Real}}=nothing: Sets the start and end points of the colormap. Use nothing to use the extrema of the density values.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.gasVelocityCubes-Tuple{Vector{String}, Union{Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.gasVelocityCubes","text":"gasVelocityCubes(\n    simulation_paths::Vector{String},\n    slice::ReducedIndexType;\n    <keyword arguments>\n)::Nothing\n\nCreate a HDF5 file with the position, gas mass, velocity, and velocity dispersion of each voxel in a rectangular 3D grid.\n\nThe metadata for each snapshot in the HDF5 file includes the physical time in Gyr, the scale factor, and the redshift of that snapshot.\n\nBy default, the grid is centered at coordinates (0, 0, 0), has 300x300x300 voxels, and has a side length of BOX_L. There are as many rows as there are voxels (27000000 by default).\n\nThe quantities in the HDF5 file for each voxel are:\n\nColumn 01: x coordinate [l_unit] Column 02: y coordinate [l_unit] Column 03: z coordinate [l_unit] Column 04: Molecular hydrogen mass [m_unit] Column 05: Atomic hydrogen mass [m_unit] Column 06: Ionized hydrogen mass [m_unit] Column 07: Gas velocity in the x direction [v_unit] Column 08: Gas velocity in the y direction [v_unit] Column 09: Gas velocity in the z direction [v_unit] Column 10: Gas velocity dispersion in the x direction [v_unit] Column 11: Gas velocity dispersion in the y direction [v_unit] Column 12: Gas velocity dispersion in the z direction [v_unit]\n\nFor simulations with the gas represented by Voronoi cells (e.g. Arepo):\n\nThe mass is the mass of molecular, atomic or ionized gas intersecting the voxel, so it only considers the cell that is closest to the center of the voxel. The velocity is given by the weighted mean of the velocities of the n_neighbors nearest cells. And the velocity dispersion, by the weighted standard deviation.\n\nNotice that for Voronoi cells, the mass will be sample at a high sub-cell resolution (as long as voxel size < cell size), while the velocities are sample at a locally lower resolution (as long as n_neighbors > 1). The weights are given by the distance (in kpc) to each neighbor, using a Gaussian kernel.\n\nFor simulations with the gas represented by particles (e.g. SPH codes):\n\nThe mass is the accumulated mass of the particles within each voxel. The velocity is the mean of the velocities of those particles, and the velocity dispersion is the corresponding standard deviation.\n\nIf there are no particles, the mass is 0, and the velocity and velocity dispersion are set to NaN. If there is only one particle, the mass and velocity are the ones from that particle, and the velocity dispersion is set to NaN.\n\nBy default (trans_mode = :allbox and `filtermode` = :all) we use the following reference system:\n\nThe origin is the global center of mass of the simulation.\nThe x, y, and z axis form a right-handed cartesian reference system (x × y = z), where the z axis has the orientation of the global angular momentum, and the x and y axis are roughly in the direction of the global principal axis.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be written to the same file.\nslice::ReducedIndexType: Slice of the simulations, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13) or an StepRange (e.g. 5:2:13). Starts at 1 and out of bounds indices are ignored.\ngas_type::Symbol=:cells: If the gas density will be calculated assuming the gas is in :particles or in Voronoi :cells.\nn_neighbors::Int=32: Number of neighbors for the mean and standard deviation of the velocity. Setting this value to 1 maximizes the resolution for the velocity, and sets the standard deviation (columns 8, 9, and 10) to NaN. This is only relevant for simulations where gas is represented by Voronoi cells (type = :cells).\ngrid::CubicGrid=CubicGrid(BOX_L, 300): Cubic grid.\nrow_major_order::Bool=true: Store the results in row-major order (as used in C and Python) instead of column-major order (used in Julia, Fortran, and MATLAB). See Row- and column-major order.\nm_unit::Unitful.Units=u\"Msun\": Mass unit\nl_unit::Unitful.Units=u\"kpc\": Length unit.\nv_unit::Unitful.Units=u\"km * s^-1\": Velocity unit.\noutput_file::String=\"./gas_velocity_cube.hdf5\": Path to the output file.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nshow_progress::Bool=true: If a progress bar will be shown.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.histogram-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}, Symbol}","page":"Convenience functions","title":"GalaxyInspector.histogram","text":"histogram(\n    simulation_paths::Vector{String},\n    slice::IndexType,\n    quantity::Symbol,\n    range::NTuple{2,<:Number};\n    <keyword arguments>\n)::Nothing\n\nPlot a histogram of quantity.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). It works over the longest simulation. Starts at 1 and out of bounds indices are ignored.\nquantity::Symbol: Target quantity. It can be any of the valid quantities of scatterQty.\nn_bins::Int=100: Number of bins.\nline::Bool=true: If the histogram will be plotted with a line or with bars.\nnorm::Int=0: Number of count that will be use to normalize the histogram. If left as 0, the histogram will be normalize with the maximum bin count.\nrange::Union{NTuple{2,<:Number},Nothing}=nothing,: Range of values for the histogram. If set to nothing, the extrema of the values will be used.\nxlog::Bool=false: If the histogram bins will be logarithmic.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=basename.(simulation_paths): Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.kennicuttSchmidtLaw-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.kennicuttSchmidtLaw","text":"kennicuttSchmidtLaw(\n    simulation_paths::Vector{String},\n    slice::IndexType;\n    <keyword arguments>\n)::Nothing\n\nPlot the Kennicutt-Schmidt law.\n\nnote: Note\nOnly stars younger than AGE_RESOLUTION are considered. The star formation area density is the stellar mass area density divided by AGE_RESOLUTION.\n\nnote: Note\nThis function uses physical units regardless of the PHYSICAL_UNITS global setting.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nslice::IndexType: Slice of the simulations, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored. All the selected snapshots will be plotted together.\nquantity::Symbol=:molecular: Quantity for the x axis. The options are:\n:gas       -> Total gas mass area density.\n:molecular -> Molecular mass area density.\n:atomic    -> Atomic mass area density.\n:neutral   -> Neutral mass area density.\ngas_type::Symbol=:cells: If the gas area density will be calculated assuming the gas is made up of :particles or Voronoi :cells.\nreduce_grid::Symbol=:square: Grid for the density projection. The options are:\n:square   -> The gas and stellar distributions will be projected into a regular cubic grid first and then into a flat square one, to emulate the way the area densities are measured in observations.\n:circular -> The gas and stellar distributions will be projected into a regular cubic grid first, then into a flat square one, and finally into a flat circular grid, formed by a series of concentric rings. This emulates the traditional way the Kennicutt-Schmidt law is measured in simulations.\ngrid_size::Unitful.Length=BOX_L: Physical side length of the cubic and square grids (if reduce_grid = :square), and diameter of the circular grid (if reduce_grid = :circular). This limits which cells/particles will be consider. As a reference, Bigiel et al. (2008) uses measurements up to the optical radius r25 (where the B-band magnitude drops below 25 mag arcsec^−2).\nbin_size::Unitful.Length=BIGIEL_PX_SIZE: Target bin size for the grids. If reduce_grid = :square, it is the physical side length of the pixels in the final square grid. If reduce_grid = :circular, it is the ring width for the final circular grid. In both cases of reduce_grid, the result will only be exact if bin_size divides grid_size exactly, otherwise grid_size will take priority and the final sizes will only approximate bin_size. For the cubic grids a default value of 200 pc is always used.\nplot_type::Symbol=:scatter: If the plot will be a :scatter plot or a :heatmap. Heatmaps will not show legends or several simulations at once. Scatter plots show one mark per pixel, and heatmaps show a 2D histogram for the number of pixel in each bin.\nintegrated::Bool=false: If the integrated (one mark per galaxy) or resolved (several marks per galaxy) Kennicutt-Schmidt law will be plotted. integrated = true only works with plot_type = :scatter. The central value is the weighted median and the error bars are the median absolute deviations.\nsfr_density::Bool=true: If the quantity for the y axis will be the SFR area density or, if sfr_density = false, the stellar mass area density.\ngas_weights::Union{Symbol,Nothing}=nothing: If plot_type = :scatter, each point (a bin in the 2D grid) can be weighted by a gas quantity. If integrated = true, the median will be computed with these weights. If integrated = false, each point will have a color given by the weight. The possible weights are:\n:gas_area_density -> Gas mass area density of each bin. See the documentation for the function daDensity2DProjection.\n:gas_sfr          -> The total gas SFR of the column associated with each bin. See the documentation for the function daGasSFR2DProjection.\n:gas_metallicity  -> The total metallicity of the column associated with each bin. See the documentation for the function daMetallicity2DProjection.\n:temperature      -> The median gas temperature of the column associated with each bin. See the documentation for the function daTemperature2DProjection.\npost_processing::Function=getNothing: Post processing function. It can only be getNothing, ppBigiel2008!, ppBigiel2010!, ppKennicutt1998!, ppSun2023! or ppLeroy2008!. The default units will be force into the post processing function.\npp_args::Tuple=(): Positional arguments for the post processing function.\npp_kwargs::NamedTuple=(;): Keyword arguments for the post processing function.\nfit::Bool=false: If the simulation data will be fitted with a power law. The fit will be plotted as a line. This option is only valid if integrated = false and plot_type = :scatter, otherwise it will be ignored.\nx_range::Union{NTuple{2,<:Number},Nothing}=nothing: x axis range for the heatmap grid. If set to nothing, the extrema of the x values will be used. Only relevant if plot_type = :heatmap.\ny_range::Union{NTuple{2,<:Number},Nothing}=nothing: y axis range for the heatmap grid. If set to nothing, the extrema of the y values will be used. Only relevant if plot_type = :heatmap.\nn_bins::Int=100: Number of bins per side of the heatmap grid. Only relevant if plot_type = :heatmap.\ncolorbar::Bool=false: If a colorbar will be added.\noutput_file::String=\"./kennicutt_schmidt_law.png\": Path to the output file.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=basename.(simulation_paths): Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\nReferences\n\nR. C. Kennicutt (1998). The Global Schmidt Law in Star-forming Galaxies. The Astrophysical Journal, 498(2), 541-552. doi:10.1086/305588\n\nF. Bigiel et al. (2008). THE STAR FORMATION LAW IN NEARBY GALAXIES ON SUB-KPC SCALES. The Astrophysical Journal, 136(6), 2846. doi:10.1088/0004-6256/136/6/2846\n\nJ. Sun et al. (2023). Star Formation Laws and Efficiencies across 80 Nearby Galaxies. The Astrophysical Journal Letters, 945(2), L19. doi:10.3847/2041-8213/acbd9c\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.massMetallicityRelation-Tuple{Vector{String}}","page":"Convenience functions","title":"GalaxyInspector.massMetallicityRelation","text":"massMetallicityRelation(\n    simulation_paths::Vector{String},\n    slice::IndexType;\n    <keyword arguments>\n)::Nothing\n\nPlot the resolved mass-metallicity relation. This method plots the M-Z relation at a fix moment in time.\n\nnote: Note\nOnly stars younger than AGE_RESOLUTION are considered.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nslice::IndexType=(:): Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nelement::Symbol=:all: Which metals to consider. The options are:\n:all -> Total metallicity in solar units.\n:X   -> Abundance of element mathrmX, as 12 + log_10(mathrmX    H). The possibilities are the keys of ELEMENT_INDEX.\nmass::Bool=true: If the x axis will be the stellar mass density (default) or the SFR density.\nreduce_factor::Int=1: Factor by which the resolution of the result will be reduced. This will be applied after the density projection, averaging the value of neighboring pixels. It has to divide the size of grid exactly.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.massProfile-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}, Vector{Symbol}}","page":"Convenience functions","title":"GalaxyInspector.massProfile","text":"massProfile(\n    simulation_paths::Vector{String},\n    slice::IndexType,\n    components::Vector{Symbol};\n    <keyword arguments>\n)::Nothing\n\nPlot a mass profile.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\ncomponents::Vector{Symbol}: Target components. It can only be one of the elements of COMPONENTS. All the components will be plotted together.\ncumulative::Bool=false: If the profile will be accumulated or not.\nylog::Bool=false: If the y axis is will have a log_10 scale.\nradius::Unitful.Length=DISK_R: Radius of the profile.\nn_bins::Int=100: Number of bins.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_filter::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.metallicityMap-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.metallicityMap","text":"metallicityMap(\n    simulation_paths::Vector{String},\n    slice::IndexType;\n    <keyword arguments>\n)::Nothing\n\nPlot a 2D projection of the metallicity.\n\nnote: Note\nIf if element = :all, the total metallicity (in solar units) is computed. If element = :X, the abundance of element X is computed, ABUNDANCE_SHIFT + ``\\log_{10}(X/H). In both cases the total value of the column given by the  line of sight of each pixel is computed.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\ncomponents::Vector{Symbol}=[:gas]: Target component. It can be either :stellar or :gas.\nfield_types::Vector{Symbol}=[:cells]: If the field, of each of the components, is made up of :particles or Voronoi :cells.\nelement::Symbol=:all: Target element. The possibilities are the keys of ELEMENT_INDEX. Set it to :all if you want the total metallicity.\nprojection_planes::Vector{Symbol}=[:xy]: Projection planes. The options are :xy, :xz, and :yz.\nbox_size::Unitful.Length=100u\"kpc\": Physical side length of the plot window.\npixel_length::Unitful.Length=0.1u\"kpc\": Side length of each bin.\nreduce_factor::Int=1: Factor by which the resolution of the result will be reduced. This will be applied after the density projection, averaging the value of neighboring pixels. It has to divide the size of grid exactly.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ntitle::Union{Symbol,<:AbstractString}=\"\": Title for the figure. If left empty, no title is printed. It can also be set to one of the following options:\n:physical_time -> Physical time since the Big Bang.\n:lookback_time -> Physical time left to reach the last snapshot.\n:scale_factor  -> Scale factor (only relevant for cosmological simulations).\n:redshift      -> Redshift (only relevant for cosmological simulations).\nannotation::AbstractString=\"\": Text to be added into the top left corner of the plot. If left empty, nothing is printed.\ncolorbar::Bool=false: If a colorbar will be added.\ncolorrange::Union{Nothing,Tuple{<:Real,<:Real}}=nothing: Sets the start and end points of the colormap. Use nothing to use the extrema of the density values.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.quantityReport-Tuple{Vector{String}, Dict{Symbol, Vector{String}}}","page":"Convenience functions","title":"GalaxyInspector.quantityReport","text":"quantityReport(\n    simulation_paths::Vector{String},\n    base_request::Dict{Symbol,Vector{String}};\n    <keyword arguments>\n)::Nothing\n\nWrite a text file with information about a the results of applying da_function to each snapshot.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. One text file will be written for each simulation.\nbase_request::Dict{Symbol,Vector{String}}: Dictionary with the shape cell/particle type -> [block, block, ...], where the possible types are the keys of PARTICLE_INDEX, and the possible quantities are the keys of QUANTITIES. Which data blocks are needed depends on da_function.\nda_function::Function=getNothing: Data analysis function. It must have the same signature as the examples in ./src/analysis/data_analysis.jl, but it should only return an Array.\nda_arg::Tuple=(): Psitional arguments for the data analysis function.\nda_kwarg::NamedTuple=(;): Keyword arguments for the data analysis function.\nslice::IndexType=(:): Slice of the simulation, i.e. which snapshots will be analysed. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nshow_progress::Bool=true: If a progress bar will be shown.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.quantityReport-Tuple{Vector{String}, Symbol}","page":"Convenience functions","title":"GalaxyInspector.quantityReport","text":"quantityReport(\n    simulation_paths::Vector{String},\n    quantity::Symbol;\n    <keyword arguments>\n)::Nothing\n\nWrite a text file with information about a given quantity.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. One text file will be written for each simulation.\nquantity::Symbol: Target quantity. Has to be one of the valid quantities of scatterQty.\nslice::IndexType=(:): Slice of the simulation, i.e. which snapshots will be analysed. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.radialProfile-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}, Symbol}","page":"Convenience functions","title":"GalaxyInspector.radialProfile","text":"radialProfile(\n    simulation_paths::Vector{String},\n    slice::IndexType,\n    quantity::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot a radial profile.\n\nnote: Note\nThis method plots one quantity for several simulations in one figure.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). It works over the longest simulation. Starts at 1 and out of bounds indices are ignored.\nquantity::Symbol: Target quantity. It can be any of the valid quantities of scatterQty.\nnorm::Union{Symbol,Nothing}=nothing: The value of quantity in each bin will be divided by the corresponding value of norm. It can be any of the valid quantities of scatterQty. If set to nothing, no operation is applied.\nradius::Unitful.Length=DISK_R: Radius of the profile.\nn_bins::Int=100: Number of bins.\nylog::Bool=false: If true, returns the profile of log_10(quantity) (after dividing by norm).\nflat::Bool=true: If the profile will be 2D (rings), or 3D (spherical shells).\ntotal::Bool=true: If the sum (default) or the mean of quantity will be computed for each bin. This affects the values of norm too.\ncumulative::Bool=false: If the profile will be accumulated (after dividing by norm).\ndensity::Bool=true: If the profile will be of the density of quantity (after dividing by norm).\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=basename.(simulation_paths): Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.radialProfile-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}, Vector{Symbol}, AbstractString}","page":"Convenience functions","title":"GalaxyInspector.radialProfile","text":"radialProfile(\n    simulation_paths::Vector{String},\n    slice::IndexType,\n    quantities::Vector{Symbol},\n    ylabel::AbstractString;\n    <keyword arguments>\n)::Nothing\n\nPlot a density profile.\n\nnote: Note\nThis method plots several quantities for one simulations in one figure.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nquantities::Vector{Symbol}: Target quantities. They can be any of the valid quantities of scatterQty.\nq_var_name::AbstractString: Name of the variable for the y axis.\nq_unit::Unitful.Units=Unitful.NoUnits: Unit of quantities. All must have the same units.\nnorm::Union{Symbol,Nothing}=nothing: The value of quantity in each bin will be divided by the corresponding value of norm. It can be any of the valid quantities of scatterQty. If set to nothing, no operation is applied.\nradius::Unitful.Length=DISK_R: Radius of the profile.\nn_bins::Int=100: Number of bins.\nylog::Bool=false: If true, returns the profile of log_10(quantity) (after dividing by norm).\nflat::Bool=true: If the profile will be 2D (rings), or 3D (spherical shells).\ntotal::Bool=true: If the sum (default) or the mean of quantity will be computed for each bin. This affects the values of norm too.\ncumulative::Bool=false: If the profile will be accumulated (after dividing by norm).\ndensity::Bool=true: If the profile will be of the density of quantity (after dividing by norm).\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.rotationCurve-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.rotationCurve","text":"rotationCurve(\n    simulation_paths::Vector{String},\n    slice::IndexType;\n    <keyword arguments>\n)::Nothing\n\nPlot the rotation curve of several simulations.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). It works over the longest simulation. Starts at 1 and out of bounds indices are ignored.\nR::Unitful.Length=DISK_R: Maximum radial distance for the rotation curve.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=basename.(simulation_paths): Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.scatterDensityMap-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}, Symbol, Symbol, Symbol}","page":"Convenience functions","title":"GalaxyInspector.scatterDensityMap","text":"scatterDensityMap(\n    simulation_paths::Vector{String},\n    slice::IndexType,\n    x_quantity::Symbol,\n    y_quantity::Symbol,\n    z_quantity::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot two quantities as a density scatter plot (2D histogram), weighted by z_quantity.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nx_quantity::Symbol: Quantity for the x axis. It can be any of the valid quantities of scatterQty.\ny_quantity::Symbol: Quantity for the y axis. It can be any of the valid quantities of scatterQty.\nz_quantity::Symbol: Quantity for the weights. It can be any of the valid quantities of scatterQty.\nx_range::Union{NTuple{2,<:Number},Nothing}=nothing: x axis range. If set to nothing, the extrema of the values will be used.\ny_range::Union{NTuple{2,<:Number},Nothing}=nothing: y axis range. If set to nothing, the extrema of the values will be used.\nxlog::Bool=false: If true, sets everything so the x axis is log_10(x_quantity).\nylog::Bool=false: If true, sets everything so the y axis is log_10(y_quantity).\ntotal::Bool=true: If the sum (default) or the mean of z_quantity will be used as the value of each bin.\nn_bins::Int=100: Number of bins per side of the grid.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ncolorbar::Bool=false: If a colorbar will be added.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.scatterDensityMap-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}, Symbol, Symbol}","page":"Convenience functions","title":"GalaxyInspector.scatterDensityMap","text":"scatterDensityMap(\n    simulation_paths::Vector{String},\n    slice::IndexType,\n    x_quantity::Symbol,\n    y_quantity::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot two quantities as a density scatter plot (2D histogram).\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nx_quantity::Symbol: Quantity for the x axis. It can be any of the valid quantities of scatterQty.\ny_quantity::Symbol: Quantity for the y axis. It can be any of the valid quantities of scatterQty.\nx_range::Union{NTuple{2,<:Number},Nothing}=nothing: x axis range. If set to nothing, the extrema of the values will be used.\ny_range::Union{NTuple{2,<:Number},Nothing}=nothing: y axis range. If set to nothing, the extrema of the values will be used.\nxlog::Bool=false: If true, sets everything so the x axis is log_10(x_quantity).\nylog::Bool=false: If true, sets everything so the y axis is log_10(y_quantity).\nn_bins::Int=100: Number of bins per side of the grid.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ncolorbar::Bool=false: If a colorbar will be added.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.scatterPlot-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}, Symbol, Symbol}","page":"Convenience functions","title":"GalaxyInspector.scatterPlot","text":"scatterPlot(\n    simulation_paths::Vector{String},\n    slice::IndexType,\n    x_quantity::Symbol,\n    y_quantity::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot two quantities as a scatter plot, one marker for every cell/particle.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nx_quantity::Symbol: Quantity for the x axis. It can be any of the valid quantities of scatterQty.\ny_quantity::Symbol: Quantity for the y axis. It can be any of the valid quantities of scatterQty.\nxlog::Bool=false: If true, sets the x axis to log_10(x_quantity).\nylog::Bool=false: If true, sets the y axis to log_10(y_quantity).\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.sfrTXT-Tuple{Vector{String}, Symbol, Symbol}","page":"Convenience functions","title":"GalaxyInspector.sfrTXT","text":"sfrTXT(\n    simulation_paths::Vector{String},\n    x_quantity::Symbol,\n    y_quantity::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot a time series of the data in the sfr.txt file.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nx_quantity::Symbol: Quantity for the x axis. The options are:\n:physical_time -> Physical time since the Big Bang.\n:lookback_time -> Physical time left to reach the last snapshot.\n:scale_factor  -> Scale factor.\n:redshift      -> Redshift.\ny_quantity::Symbol: Quantity for the y axis. The options are:\n:stellar_mass -> Cumulative stellar mass.\n:sfr          -> Star formation rate.\nsmooth::Int=0: The result will be smoothed out using smooth bins. Set it to 0 if you want no smoothing.\noutput_path::String=\".\": Path to the output folder.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=basename.(simulation_paths): Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.simulationReport-Tuple{Vector{String}}","page":"Convenience functions","title":"GalaxyInspector.simulationReport","text":"simulationReport(simulation_paths::Vector{String}; <keyword arguments>)::Nothing\n\nWrite a text file with information about a given simulation.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. One text file will be written for each simulation.\noutput_path::String=\".\": Path to the output folder.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.snapshotReport-Tuple{Vector{String}, Vector{Int64}}","page":"Convenience functions","title":"GalaxyInspector.snapshotReport","text":"snapshotReport(\n    simulation_paths::Vector{String},\n    slices::Vector{Int};\n    <keyword arguments>\n)::Nothing\n\nWrite a text file with information about a given snapshot.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. One text file will be written for each simulation.\nslices::Vector{Int}: Selects which snapshots to plot for each simulation, starts at 1 and is independent of the number in the file name. If every snapshot is present, the relation is slice = (number in filename) + 1.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be considered in the \"filtered\" section of the report. For options see selectFilter.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.statisticsEvolution-Tuple{Vector{String}, Symbol, Symbol}","page":"Convenience functions","title":"GalaxyInspector.statisticsEvolution","text":"statisticsEvolution(\n    simulation_paths::Vector{String},\n    x_quantity::Symbol,\n    y_quantity::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot a time series of the statistics of y_quantity (25th, 50th, 75th percentails, and maximum and minimum).\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nx_quantity::Symbol: Quantity for the x axis. It can be any of the time quantities valid for integrateQty, namely\n:physical_time -> Physical time since the Big Bang.\n:lookback_time -> Physical time left to reach the last snapshot.\n:scale_factor  -> Scale factor (only relevant for cosmological simulations).\n:redshift      -> Redshift (only relevant for cosmological simulations).\ny_quantity::Symbol: Quantity for the y axis. It can be any of the quantities valid for integrateQty.\nslice::IndexType=(:): Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). It works over the longest simulation. Starts at 1 and out of bounds indices are ignored.\nxlog::Bool=false: If the x axis is will have a log_10 scale.\nylog::Bool=false: If the y axis is will have a log_10 scale.\ncumulative::Bool=false: If the y_quantity will be accumulated or not.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\nsmooth::Int=0: The result of integrateQty will be smoothed out using smooth bins. Set it to 0 if you want no smoothing.\nbackup_results::Bool=false: If the values to be plotted will be saved in a JLD2 file.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.stellarBirthHalos-Tuple{Vector{String}, Int64}","page":"Convenience functions","title":"GalaxyInspector.stellarBirthHalos","text":"stellarBirthHalos(\n    simulation_paths::Vector{String},\n    snapshot_n::Int;\n    <keyword arguments>\n)::Nothing\n\nWrite, to a pair of CSV files, in which halo and subhalo every star in snapshot snapshot_n was born.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be in a different file.\nsnapshot_n::Int: Selects the target snapshot. Starts at 1 and is independent of the number in the file name. If every snapshot is present, the relation is snapshot_n = (number in filename) + 1.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.stellarDensityMaps-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.stellarDensityMaps","text":"stellarDensityMaps(\n    simulation_paths::Vector{String},\n    slice::IndexType;\n    <keyword arguments>\n)::Nothing\n\nPlot the stellar density maps for the xy and xz projections, in two panels.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nbox_size::Unitful.Length=BOX_L: Size of the plotting box (x and y coordinates).\nbox_height::Unitful.Length=12.0u\"kpc\": Size of the plotting box (z coordinate).\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daDensity2DProjection after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.stellarHistory-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.stellarHistory","text":"stellarHistory(\n    simulation_paths::Vector{String},\n    slice::IndexType,\n    quantity::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot the evolution of a given stellar quantity using the stellar ages at a given instant in time.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). It works over the longest simulation. Starts at 1 and out of bounds indices are ignored.\nquantity::Symbol=:sfr: Target quantity. The options are:\n:sfr                 -> Star formation rate.\n:ssfr                -> The specific star formation rate.\n:stellar_mass        -> Stellar mass.\n:stellar_metallicity -> Mass fraction of all elements above He in the stars (solar units).\nn_bins::Int=100: Number of bins.\nylog::Bool=false: If true, returns the profile of log_10(quantity) (after dividing by norm).\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=basename.(simulation_paths): Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.stellarVelocityCubes-Tuple{Vector{String}, Union{Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.stellarVelocityCubes","text":"stellarVelocityCubes(\n    simulation_paths::Vector{String},\n    slice::ReducedIndexType;\n    <keyword arguments>\n)::Nothing\n\nCreate a HDF5 file with the position, stellar mass, velocity, and velocity dispersion of each voxel in a rectangular 3D grid.\n\nThe metadata for each snapshot in the HDF5 file includes the physical time in Gyr, the scale factor, and the redshift of that snapshot.\n\nBy default, the grid is centered at coordinates (0, 0, 0), has 100x100x100 voxels, and has a side length of BOX_L. There are as many rows as there are voxels (1000000 by default).\n\nThe quantities in the HDF5 file for each voxel are:\n\nColumn 01: x coordinate [l_unit] Column 02: y coordinate [l_unit] Column 03: z coordinate [l_unit] Column 04: Stellar mass [m_unit] Column 05: Stellar velocity in the x direction [v_unit] Column 06: Stellar velocity in the y direction [v_unit] Column 07: Stellar velocity in the z direction [v_unit] Column 08: Stellar velocity dispersion in the x direction [v_unit] Column 09: Stellar velocity dispersion in the y direction [v_unit] Column 10: Stellar velocity dispersion in the z direction [v_unit]\n\nThe mass is the accumulated mass of the particles within each voxel. The velocity is the mean of the velocities of those particles, and the velocity dispersion is the corresponding standard deviation.\n\nIf there are no particles, the mass is 0, and the velocity and velocity dispersion are set to NaN. If there is only one particle, the mass and velocity are the ones from that particle, and the velocity dispersion is set to NaN.\n\nBy default (trans_mode = :allbox and `filtermode` = :all) we use the following reference system:\n\nThe origin is the global center of mass of the simulation.\nThe x, y, and z axis form a right-handed cartesian reference system (x × y = z), where the z axis has the orientation of the global angular momentum, and the x and y axis are roughly in the direction of the global principal axis.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be written to the same file.\nslice::ReducedIndexType: Slice of the simulations, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13) or an StepRange (e.g. 5:2:13). Starts at 1 and out of bounds indices are ignored.\ngrid::CubicGrid=CubicGrid(BOX_L, 300): Cubic grid.\nrow_major_order::Bool=true: Store the results in row-major order (as used in C and Python) instead of column-major order (used in Julia, Fortran, and MATLAB). See Row- and column-major order.\nm_unit::Unitful.Units=u\"Msun\": Mass unit\nl_unit::Unitful.Units=u\"kpc\": Length unit.\nv_unit::Unitful.Units=u\"km * s^-1\": Velocity unit.\noutput_file::String=\"./stellar_velocity_cube.hdf5\": Path to the output file.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nshow_progress::Bool=true: If a progress bar will be shown.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.temperatureMap-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}","page":"Convenience functions","title":"GalaxyInspector.temperatureMap","text":"temperatureMap(\n    simulation_paths::Vector{String},\n    slice::IndexType;\n    <keyword arguments>\n)::Nothing\n\nPlot a 2D projection of the gas temperature.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. Each simulation will be plotted in a different figure.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nfield_type::Symbol=:cells: If the field is made up of :particles or Voronoi :cells.\nprojection_planes::Vector{Symbol}=[:xy]: Projection planes. The options are :xy, :xz, and :yz.\nbox_size::Unitful.Length=100u\"kpc\": Physical side length of the plot window.\npixel_length::Unitful.Length=0.1u\"kpc\": Side length of each bin.\nreduce_factor::Int=1: Factor by which the resolution of the result will be reduced. This will be applied after the density projection, averaging the value of neighboring pixels. It has to divide the size of grid exactly.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\ntitle::Union{Symbol,<:AbstractString}=\"\": Title for the figure. If left empty, no title is printed. It can also be set to one of the following options:\n:physical_time -> Physical time since the Big Bang.\n:lookback_time -> Physical time left to reach the last snapshot.\n:scale_factor  -> Scale factor (only relevant for cosmological simulations).\n:redshift      -> Redshift (only relevant for cosmological simulations).\nannotation::AbstractString=\"\": Text to be added into the top left corner of the plot. If left empty, nothing is printed.\ncolorbar::Bool=false: If a colorbar will be added.\ncolorrange::Union{Nothing,Tuple{<:Real,<:Real}}=nothing: Sets the start and end points of the colormap. Use nothing to use the extrema of the density values.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.timeSeries-Tuple{Vector{String}, Symbol, Symbol}","page":"Convenience functions","title":"GalaxyInspector.timeSeries","text":"timeSeries(\n    simulation_paths::Vector{String},\n    x_quantity::Symbol,\n    y_quantity::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot a time series.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nx_quantity::Symbol: Quantity for the x axis. It can be any of the quantities valid for integrateQty.\ny_quantity::Symbol: Quantity for the y axis. It can be any of the quantities valid for integrateQty.\nslice::IndexType=(:): Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). It works over the longest simulation. Starts at 1 and out of bounds indices are ignored.\nxlog::Bool=true: If the x axis is will have a log_10 scale.\nylog::Bool=true: If the y axis is will have a log_10 scale.\ncumulative::Bool=false: If the y_quantity will be accumulated or not.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_ff::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\nsmooth::Int=0: The result of integrateQty will be smoothed out using smooth bins. Set it to 0 if you want no smoothing.\nbackup_results::Bool=false: If the values to be plotted will be saved in a JLD2 file.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\nsim_labels::Union{Vector{<:Union{AbstractString,Nothing}},Nothing}=nothing: Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.velocityProfile-Tuple{Vector{String}, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}, Symbol}","page":"Convenience functions","title":"GalaxyInspector.velocityProfile","text":"velocityProfile(\n    simulation_paths::Vector{String},\n    slice::IndexType,\n    velocity::Symbol;\n    <keyword arguments>\n)::Nothing\n\nPlot a velocity profile.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nvelocity::Symbol: Target velocity component. The options are:\n:stellar_radial_velocity     -> Component of the stellar velocity in the radial direction (v_r).\n:stellar_tangential_velocity -> Component of the stellar velocity in the tangential direction (v_theta).\n:stellar_zstar_velocity      -> Component of the stellar velocity in the z direction , computed as v_z  mathrmsign(z).\nradius::Unitful.Length=DISK_R: Radius of the profile.\nn_bins::Int=40: Number of bins.\noutput_path::String=\".\": Path to the output folder.\ntrans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box: How to translate and rotate the cells/particles, before filtering with filter_mode. For options see selectTransformation.\nfilter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all: Which cells/particles will be selected. For options see selectFilter.\nda_filter::Function=filterNothing: Filter function to be applied within daScatterGalaxy after trans_mode and filter_mode are applied. See the required signature and examples in ./src/analysis/filters.jl.\nff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}(): Request dictionary for da_ff.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=basename.(simulation_paths): Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/convenience/#GalaxyInspector.virialAccretionEvolution-Tuple{Vector{String}}","page":"Convenience functions","title":"GalaxyInspector.virialAccretionEvolution","text":"virialAccretionEvolution(\n    simulation_paths::Vector{String};\n    <keyword arguments>\n)::Nothing\n\nPlot a time series of the gas mass flux into a sphere with the virial radius.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir. All the simulations will be plotted together.\nslice::IndexType=(:): Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). Starts at 1 and out of bounds indices are ignored.\nflux_direction::Symbol=:net: What flux direction will be plotted. The options are:\n:net_mass     -> Net accreted mass.\n:inflow_mass  -> Inflow mass only.\n:outflow_mass -> Outflow mass only.\nhalo_idx::Int=1: Index of the target halo (FoF group). Starts at 1.\ncomponent::Symbol=:all: Component to compute the accreted mass for. The options are:\n:dark_matter -> Dark matter.\n:black_hole  -> Black holes.\n:gas         -> Gas.\n:stellar     -> Stars.\n:all         -> All the matter.\ntracers::Bool=false: If tracers will be use to compute the mass accretion.\nsmooth::Int=0: The time series will be smoothed out using smooth bins. Set it to 0 if you want no smoothing.\noutput_path::String=\".\": Path to the output folder.\nsim_labels::Union{Vector{<:AbstractString},Nothing}=nothing: Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#Filter-functions","page":"Filter functions","title":"Filter functions","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/analysis/filters/#GalaxyInspector.filterAll-Tuple","page":"Filter functions","title":"GalaxyInspector.filterAll","text":"Filter function that filters out all cells/particles.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.filterByBirthPlace-Tuple{Dict, Symbol}","page":"Filter functions","title":"GalaxyInspector.filterByBirthPlace","text":"filterByBirthPlace(\n    data_dict::Dict,\n    exclude::Symbol;\n    <keyword arguments>\n)::Dict{Symbol,IndexType}\n\nSelect stars that were born either inside the given halo and subhalo (exclude= :exsitu), or outside (exclude= :insitu).\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nexclude::Symbol: Which stars will be excluded, either the ones born outside the given halo and subhalo (:exsitu), or inside (:insitu).\nhalo_idx::Int=1: Index of the target halo (FoF group). Starts at 1.\nsubhalo_rel_idx::Int=1: Index of the target subhalo (subfind), relative to the target halo. Starts at 1. If it is set to 0, all subhalos of the target halo are considered in-situ.\n\nReturns\n\nA filter dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.filterByCylinder-Tuple{Dict, Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}, Vararg{Any}}","page":"Filter functions","title":"GalaxyInspector.filterByCylinder","text":"filterByCylinder(\n    data_dict::Dict,\n    max_r::Unitful.Length,\n    max_z::Unitful.Length,\n    origin...,\n)::Dict{Symbol,IndexType}\n\nSelect the cells/particles within a given cylinder.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nmax_r::Unitful.Length: Radius of the cylinder.\nmax_z::Unitful.Length: Half height of the cylinder.\norigin...: It can be any number and type of argument compatible with the second to last arguments of a computeCenter method.\n\nReturns\n\nA filter dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.filterByQuantity-Tuple{Dict, Symbol, Symbol, Number, Number}","page":"Filter functions","title":"GalaxyInspector.filterByQuantity","text":"filterByQuantity(\n    data_dict::Dict,\n    quantity::Symbol,\n    component::Symbol,\n    min::Number,\n    max::Number,\n)::Dict{Symbol,IndexType}\n\nSelect particles/cells with a value of quantity within [min, max].\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nquantity::Symbol: Target quantity. For the possibilities see the documentation of scatterQty.\ncomponent::Symbol: Type of particle/cell. The possibilities are the keys of PARTICLE_INDEX.\nmin::Number: Minimum value of quantity.\nmax::Number: Maximum value of quantity.\n\nReturns\n\nA filter dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.filterBySFM-Tuple{Dict}","page":"Filter functions","title":"GalaxyInspector.filterBySFM","text":"filterBySFM(data_dict::Dict)::Dict{Symbol,IndexType}\n\nSelect the gas cells that have entered our star formation routine at least once.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\n\nReturns\n\nA filter dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.filterBySphere-Tuple{Dict, Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}, Vararg{Any}}","page":"Filter functions","title":"GalaxyInspector.filterBySphere","text":"filterBySphere(\n    data_dict::Dict,\n    min_r::Unitful.Length,\n    max_r::Unitful.Length,\n    origin...,\n)::Dict{Symbol,IndexType}\n\nSelect the cells/particles within a given spherical shell.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nmin_r::Unitful.Length: Internal radius of the spherical shell.\nmax_r::Unitful.Length: External radius of the spherical shell.\norigin...: It can be any number and type of argument compatible with the second to last arguments of a computeCenter method.\n\nReturns\n\nA filter dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.filterByStellarAge-Tuple{Dict}","page":"Filter functions","title":"GalaxyInspector.filterByStellarAge","text":"filterByStellarAge(\n    data_dict::Dict;\n    <keyword arguments>\n)::Dict{Symbol,IndexType}\n\nSelect stars with an age within [min_age, max_age].\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nmin_age::Unitful.Time=0.0u\"Gyr\": Minimum age.\nmax_age::Unitful.Time=AGE_RESOLUTION: Maximum age.\n\nReturns\n\nA filter dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.filterBySubhalo-Tuple{Dict, Int64}","page":"Filter functions","title":"GalaxyInspector.filterBySubhalo","text":"filterBySubhalo(data_dict::Dict, subhalo_abs_idx::Int)::Dict{Symbol,IndexType}\n\nSelect the cells/particles that belong to a given subhalo.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nsubhalo_abs_idx::Int: Index of the target subhalo (subfind). Starts at 1.\n\nReturns\n\nA filter dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.filterBySubhalo-Tuple{Dict}","page":"Filter functions","title":"GalaxyInspector.filterBySubhalo","text":"filterBySubhalo(\n    data_dict::Dict;\n    <keyword arguments>\n)::Dict{Symbol,IndexType}\n\nSelect the cells/particles that belong to a given halo and subhalo.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nhalo_idx::Int=1: Index of the target halo (FoF group). Starts at 1.\nsubhalo_rel_idx::Int=1: Index of the target subhalo (subfind), relative to the target halo. Starts at 1. If it is set to 0, all subhalos of the target halo are included.\n\nReturns\n\nA filter dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.filterData!-Tuple{Dict}","page":"Filter functions","title":"GalaxyInspector.filterData!","text":"filterData!(data_dict::Dict; <keyword arguments>)::Nothing\n\nFilter data_dict using the indices provided by filter_function.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nfilter_function::Function=filterNothing: Filter function. See the required signature and examples in ./src/analysis/filters.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.filterData-Tuple{Dict}","page":"Filter functions","title":"GalaxyInspector.filterData","text":"filterData(data_dict::Dict; <keyword arguments>)::Dict\n\nReturn a filtered copy of data_dict using the indices provided by filter_function.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nfilter_function::Function=filterNothing: Filter function. See the required signature and examples in ./src/analysis/filters.jl.\n\nReturns\n\nThe filtered data.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.filterNothing-Tuple","page":"Filter functions","title":"GalaxyInspector.filterNothing","text":"Filter function that does not filter out any cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.filterOldStars-Tuple{Dict}","page":"Filter functions","title":"GalaxyInspector.filterOldStars","text":"filterOldStars(data_dict::Dict)::Dict{Symbol,IndexType}\n\nSelect stars born after the previous snapshot.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\n\nReturns\n\nA filter dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.intersectFilters-Tuple","page":"Filter functions","title":"GalaxyInspector.intersectFilters","text":"intersectFilters(filters...)::Dict{Symbol,IndexType}\n\nGenerate the filter dictionary resulting from intersecting filters (using AND in boolean logic).\n\nArguments\n\nfilters: Filter dictionary.\n\nReturns\n\nThe filter dictionary resulting from intersecting filters.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.intersectFilters-Tuple{Dict{Symbol, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}}","page":"Filter functions","title":"GalaxyInspector.intersectFilters","text":"intersectFilters(filters::Dict{Symbol,IndexType})::Dict{Symbol,IndexType}\n\nTrivial method for the case of a single argument.\n\nArguments\n\nfilters::Dict{Symbol,IndexType}: Filter dictionary.\n\nReturns\n\nThe filter dictionary given as argument.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.intersectFilters-Tuple{Vararg{Function}}","page":"Filter functions","title":"GalaxyInspector.intersectFilters","text":"intersectFilters(filters::Function...)::Function\n\nGenerate the filter function resulting from intersecting filters (using AND in boolean logic).\n\nArguments\n\nfilters: Filter functions.\n\nReturns\n\nThe filter function resulting from intersecting filters.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.invertFilter-Tuple{Function}","page":"Filter functions","title":"GalaxyInspector.invertFilter","text":"invertFilter(filter::Function)::Function\n\nInvert a filter function\n\nArguments\n\nfilter::Function: Filter function to be inverted.\n\nReturns\n\nThe inverted filter function.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.invertFilterDict-Tuple{Dict{Symbol, Union{Colon, Integer, StepRange{<:Integer, <:Integer}, UnitRange{<:Integer}, InvertedIndices.InvertedIndex, Vector{<:Integer}}}}","page":"Filter functions","title":"GalaxyInspector.invertFilterDict","text":"invertFilterDict(filter::Dict{Symbol,IndexType})::Dict{Symbol,IndexType}\n\nInvert a given filter dictionary.\n\nArguments\n\nfilter::Dict{Symbol,IndexType}: Filter dictionary to be inverted.\n\nReturns\n\nThe inverted filter dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.selectFilter-Tuple{Symbol, Dict{Symbol, Vector{String}}}","page":"Filter functions","title":"GalaxyInspector.selectFilter","text":"selectFilter(\n    filter_mode::Symbol,\n    base_request::Dict{Symbol,Vector{String}},\n)::Tuple{Function,Dict{Symbol,Vector{String}}}\n\nSelect a filter function from a list of premade ones.\n\nCreates a request dictionary, using base_request as a base, adding what is necessary for the filter function.\n\nArguments\n\nfilter_mode::Symbol: Which cells/particles will be selected, the options are:\n:all             -> Select every cell/particle within the simulation box.\n:halo            -> Select the cells/particles that belong to the main halo.\n:subhalo         -> Select the cells/particles that belong to the main subhalo.\n:sphere          -> Select the cells/particles inside a sphere centered at the origin with radius DISK_R (see ./src/constants/globals.jl).\n:cylinder        -> Select the cells/particles inside a cylinder centered at the origin with radius DISK_R and half height DISK_HEIGHT (see ./src/constants/globals.jl). The cylinder axis is aligned with the z axis.\nbase_request::Dict{Symbol,Vector{String}}: Base request dictionary.\n\nReturns\n\nA Tuple with two elements:\nThe filter function.\nThe new request dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/filters/#GalaxyInspector.selectFilter-Tuple{Tuple{Function, Dict{Symbol, Vector{String}}}, Dict{Symbol, Vector{String}}}","page":"Filter functions","title":"GalaxyInspector.selectFilter","text":"selectFilter(\n    filter_mode::Tuple{Function,Dict{Symbol,Vector{String}}},\n    base_request::Dict{Symbol,Vector{String}},\n)::Tuple{Function,Dict{Symbol,Vector{String}}}\n\nCompatibility method to pass personalized filters to functions that only use the filter_mode argument.\n\nArguments\n\nfilter_mode::Tuple{Function,Dict{Symbol,Vector{String}}}: Filter function and the request that goes with it.\nbase_request::Dict{Symbol,Vector{String}}: Base request dictionary.\n\nReturns\n\nA Tuple with two elements:\nThe filter function.\nThe new request dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/pipelines/#Pipeline-functions","page":"Pipeline functions","title":"Pipeline functions","text":"These functions provide a full plotting pipeline, from reading the data to generating figures and animations.\n\nThey have many optional arguments allowing to configure most aspects of the plots.\n\nAll these functions are exported.\n\n","category":"section"},{"location":"api/plotting/pipelines/#GalaxyInspector.plotSnapshot-Tuple{Vector{String}, Dict{Symbol, Vector{String}}, Vector{<:Function}}","page":"Pipeline functions","title":"GalaxyInspector.plotSnapshot","text":"plotSnapshot(\n    simulation_paths::Vector{String},\n    request::Dict{Symbol,Vector{String}},\n    plot_functions::Vector{<:Function};\n    <keyword arguments>\n)::Nothing\n\nGenerate one figure per snapshot, for one or more simulations.\n\nSome of the features are:\n\nIt can produce scatter plots, line plots, histograms, bar plots, and heatmaps.\nIt can generate an animation of the results.\nIt transparently manages units; you only have to indicate the final unit of each axis.\n\nnote: Note\nThe snapshots of different simulations are grouped by their filename, regardless of the \"Time\" parameter in the header. The data from the longest running simulation is used for the time stamp in the automatic title.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir.\nrequest::Dict{Symbol,Vector{String}}: Dictionary with the shape cell/particle type -> [block, block, ...], where the possible types are the keys of PARTICLE_INDEX, and the possible quantities are the keys of QUANTITIES. Which data blocks are needed depends on da_functions.\nplot_functions::Vector{<:Function}: Vector of plotting functions from Makie. This sets the type of plot for each simulation. The supported functions are:\nscatter!      -> Scatter plot.\nlines!        -> Line plot.\nscatterlines! -> Scatter plot with lines between the markers.\nhist!         -> Histogram.\nheatmap!      -> Heatmap.\narrows2d!     -> 2D vector field.\nbarplot!      -> Bar plots.\nband!         -> Band plots.\nerrorbars!    -> Error bars.\npf_kwargs::Vector{<:NamedTuple}=[(;)]: Vector of keyword arguments for the plot_functions.\n\nplotSnapshot configuration\n\noutput_path::String=\".\": Path to the output folder.\nbase_filename::String=\"plot\": Every file will be named base_filenamesnapXXXoutput_format where XXX is the snapshot number.\noutput_format::String=\".png\": File format for the figure. All formats supported by Makie can be used, namely .pdf, .svg, and .png.\nshow_progress::Bool=true: If a progress bar will be shown.\n\nData manipulation options\n\nslice::IndexType=(:): Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). It works over the longest simulation. Out of bounds indices are ignored.\ntransform_box::Bool=false: If a translation and rotation (in that order) will be applied to the simulation box, affecting the positions and velocities of all the cells and particles. If active, it is applied BEFORE the filter_function.\ntranslation::TranslationType=:zero: Type of translation (only relevant if transform_box = true). See the arguments after data_dict in translateData! for options. Several arguments can be passed as a Tuple.\nrotation::RotationType=:zero: Type of rotation (only relevant if transform_box = true). See the arguments after data_dict in rotateData! for options. Several arguments can be passed as a Tuple.\nfilter_function::Function=filterNothing: Filter function. See the required signature and examples in ./src/analysis/filters.jl. This is applied AFTER the translation and rotation.\nda_functions::Vector{<:Function}=[getNothing]: Vector of data analysis functions. See the required signature and examples in ./src/analysis/data_analysis.jl.\nda_args::Vector{<:Tuple}=[()]: Vector of positional arguments for the data analysis functions.\nda_kwargs::Vector{<:NamedTuple}=[(;)]: Vector of keyword arguments for the data analysis functions.\npost_processing::Function=getNothing: Post processing function. See the required signature and examples in ./src/plotting/post_processing.jl.\npp_args::Tuple=(): Positional arguments for the post processing function.\npp_kwargs::NamedTuple=(;): Keyword arguments for the post processing function.\nsmooth::Int=0: The first two data vectors of each da_functions will be smoothed out using smooth bins. Set it to 0 if you want no smoothing.\n\nAxes options\n\nx_unit::Unitful.Units=Unitful.NoUnits: Target unit for the x axis data. The values will be converted accordingly. Use the default value of Unitful.NoUnits for dimensionless quantities.\ny_unit::Unitful.Units=Unitful.NoUnits: Target unit for the y axis data. The values will be converted accordingly. Use the default value of Unitful.NoUnits for dimensionless quantities.\nx_exp_factor::Int=0: Numerical exponent to scale down the x axis data, e.g. if x_exp_factor = 10 the values will be divided by 10^10. The default is no scaling.\ny_exp_factor::Int=0: Numerical exponent to scale down the y axis data, e.g. if y_exp_factor = 10 the values will be divided by 10^10. The default is no scaling.\nx_trim::NTuple{2,<:Real}=(-Inf, Inf): The data will be trim down so the x coordinates fit within x_trim, in the units given by x_unit.\ny_trim::NTuple{2,<:Real}=(-Inf, Inf): The data will be trim down so the y coordinates fit within y_trim, in the units given by y_unit. This option does not affect histograms.\nx_edges::Bool=false: Set it to true if you want to keep the borders of x_trim.\ny_edges::Bool=false: Set it to true if you want to keep the borders of y_trim.\nx_scale_func::Function=identity: Scaling function for the x axis. The options are the scaling functions accepted by Makie: log10, log2, log, sqrt, Makie.logit, Makie.Symlog10, Makie.pseudolog10, and identity. The data will be trimmed down to fit within the domain of x_scale_func.\ny_scale_func::Function=identity: Scaling function for the y axis. The options are the scaling functions accepted by Makie: log10, log2, log, sqrt, Makie.logit, Makie.Symlog10, Makie.pseudolog10, and identity. The data will be trimmed down to fit within the domain of y_scale_func.\nxaxis_label::AbstractString=\"auto_label\": Label for the x axis. It can contain the string auto_label, which will be replaced by: xaxis_var_name [10^x_exp_factor x_unit]. If a LaTeXString with auto_label inside is used, it is recommended that each section around auto_label is delimited with a $ $ pair.\nyaxis_label::AbstractString=\"auto_label\": Label for the y axis. It can contain the string auto_label, which will be replaced by: yaxis_var_name [10^y_exp_factor y_unit]. If a LaTeXString with auto_label inside is used, it is recommended that each section around auto_label is delimited with a $ $ pair.\nxaxis_var_name::AbstractString=\"x\": Name of the variable for the x axis.\nyaxis_var_name::AbstractString=\"y\": Name of the variable for the y axis.\n\nPlotting options\n\nsave_figures::Bool=true: If every figure will be saved as a file.\nbackup_results::Bool=false: If the values to be plotted will be saved in a JLD2 file.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\nsim_labels::Union{Vector{<:Union{AbstractString,Nothing}},Nothing}=nothing: Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntitle::Union{Symbol,<:AbstractString}=\"\": Title for the figure. If left empty, no title is printed. It can also be set to one of the following options:\n:physical_time -> Physical time since the Big Bang.\n:lookback_time -> Physical time left to reach the last snapshot.\n:scale_factor  -> Scale factor (only relevant for cosmological simulations).\n:redshift      -> Redshift (only relevant for cosmological simulations).\ncolorbar::Bool=false: If a vertical colorbar will be added.\n\nAnimation options\n\nanimation::Bool=false: If an animation will be created.\nanimation_filename::String=\"{base_filename}.mkv\": Filename for the animation, including its extension. All formats supported by Makie can be used, namely .mkv, .mp4, .webm, and .gif.\nframerate::Int=20: Frame rate of the animation.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/pipelines/#GalaxyInspector.plotTimeSeries-Tuple{Vector{String}, Vector{<:Function}}","page":"Pipeline functions","title":"GalaxyInspector.plotTimeSeries","text":"plotTimeSeries(\n    simulation_paths::Vector{String},\n    plot_functions::Vector{<:Function};\n    <keyword arguments>\n)::Tuple{Makie.Axis,Figure}\n\nGenerate one figure per simulation.\n\nSome of the features are:\n\nIt can produce scatter and line plots.\nIt transparently manages units; you only have to indicate the final unit of each axis.\n\nArguments\n\nsimulation_paths::Vector{String}: Paths to the simulation directories, set in the code variable OutputDir.\nplot_functions::Vector{<:Function}: Vector of plotting functions from Makie. This sets the type of plot for each simulation. The supported functions are:\nscatter!      -> Scatter plot.\nlines!        -> Line plot.\nscatterlines! -> Scatter plot with lines between the markers.\npf_kwargs::Vector{<:NamedTuple}=[(;)]: Vector of keyword arguments for the functions plot_functions.\n\nplotTimeSeries configuration\n\noutput_path::String=\".\": Path to the output folder.\nfilename::String=\"time_series\": Filename for the figure, without the extension.\noutput_format::String=\".png\": File format for the figure. All formats supported by Makie can be used, namely .pdf, .svg and .png.\n\nData manipulation options\n\nslice::IndexType=(:): Slice of the simulation, i.e. which snapshots will be plotted. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots). It works over the longest possible list of snapshots among the simulations (grouped by the number in the file names). Out of bounds indices are ignored.\nda_functions::Vector{<:Function}=[getNothing]: Vector of data analysis functions. See the required signature and examples in ./src/analysis/data_analysis.jl.\nda_args::Vector{<:Tuple}=[()]: Vector of positional arguments for the data analysis functions.\nda_kwargs::Vector{<:NamedTuple}=[(;)]: Vector of keyword arguments for the data analysis functions.\npost_processing::Function=getNothing: Post processing function. See the required signature and examples in ./src/plotting/post_processing.jl.\npp_args::Tuple=(): Positional arguments for the post processing function.\npp_kwargs::NamedTuple=(;): Keyword arguments for the post processing function.\n\nAxes options\n\nx_unit::Unitful.Units=Unitful.NoUnits: Target unit for the x axis data. The values will be converted accordingly. Use the default value of Unitful.NoUnits for dimensionless quantities.\ny_unit::Unitful.Units=Unitful.NoUnits: Target unit for the y axis data. The values will be converted accordingly. Use the default value of Unitful.NoUnits for dimensionless quantities.\nx_exp_factor::Int=0: Numerical exponent to scale down the x axis data, e.g. if x_exp_factor = 10 the values will be divided by 10^10. The default is no scaling.\ny_exp_factor::Int=0: Numerical exponent to scale down the y axis data, e.g. if y_exp_factor = 10 the values will be divided by 10^10. The default is no scaling.\nx_trim::NTuple{2,<:Real}=(-Inf, Inf): The data will be trim down so the x coordinates fit within x_trim, in the units given by x_unit.\ny_trim::NTuple{2,<:Real}=(-Inf, Inf): The data will be trim down so the y coordinates fit within y_trim, in the units given by y_unit.\nx_edges::Bool=false: Set it to true if you want to keep the borders of x_trim.\ny_edges::Bool=false: Set it to true if you want to keep the borders of y_trim.\nx_scale_func::Function=identity: Scaling function for the x axis. The options are the scaling functions accepted by Makie: log10, log2, log, sqrt, Makie.logit, Makie.Symlog10, Makie.pseudolog10, and identity. The data will be trimmed down to fit within the domain of x_scale_func.\ny_scale_func::Function=identity: Scaling function for the y axis. The options are the scaling functions accepted by Makie: log10, log2, log, sqrt, Makie.logit, Makie.Symlog10, Makie.pseudolog10, and identity. The data will be trimmed down to fit within the domain of y_scale_func.\nxaxis_label::AbstractString=\"auto_label\": Label for the x axis. It can contain the string auto_label, which will be replaced by: xaxis_var_name [10^x_exp_factor x_unit]. If a LaTeXString with auto_label inside is used, it is recommended that each section around auto_label is delimited with a $ $ pair.\nyaxis_label::AbstractString=\"auto_label\": Label for the y axis. It can contain the string auto_label, which will be replaced by: yaxis_var_name [10^y_exp_factor y_unit]. If a LaTeXString with auto_label inside is used, it is recommended that each section around auto_label is delimited with a $ $ pair.\nxaxis_var_name::AbstractString=\"x\": Name of the variable for the x axis.\nyaxis_var_name::AbstractString=\"y\": Name of the variable for the y axis.\n\nPlotting options\n\nsave_figures::Bool=true: If the plot will be saved as a file.\nbackup_results::Bool=false: If the values to be plotted will be saved in a JLD2 file.\ntheme::Attributes=Theme(): Plot theme that will take precedence over DEFAULT_THEME.\nsim_labels::Union{Vector{<:Union{AbstractString,Nothing}},Nothing}=nothing: Labels for the plot legend, one per simulation. Set it to nothing if you don't want a legend.\ntitle::AbstractString=\"\": Title for the figure. If left empty, no title will be printed.\n\nReturns\n\nThe Axis and Figure objects.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#Computation-of-characteristic-positions","page":"Computation of characteristic positions","title":"Computation of characteristic positions","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.computeAMRotationMatrix-Tuple{Dict, Symbol}","page":"Computation of characteristic positions","title":"GalaxyInspector.computeAMRotationMatrix","text":"computeAMRotationMatrix(\n    data_dict::Dict,\n    component::Symbol,\n)::Union{Matrix{Float64},UniformScaling{Bool}}\n\nCompute the rotation matrix that will turn the angular momentum of component into the z axis, when view as an active (alibi) transformation.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present for every cell/particle that you want to be taken into account:\ncell/particle type => [\"POS \", \"MASS\", \"VEL \"]\ncomponent::Symbol: Target component. The options are:\n:all         -> Every component present in data_dict.\n:{component} -> Any of the keys of PARTICLE_INDEX, if present in data_dict.\n\nReturns\n\nThe rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.computeAMRotationMatrix-Tuple{Matrix{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Matrix{<:Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic positions","title":"GalaxyInspector.computeAMRotationMatrix","text":"computeAMRotationMatrix(\n    positions::Matrix{<:Unitful.Length},\n    velocities::Matrix{<:Unitful.Velocity},\n    masses::Vector{<:Unitful.Mass},\n)::Union{Matrix{Float64},UniformScaling{Bool}}\n\nCompute the rotation matrix that will turn the total angular momentum into the z axis, when view as an active (alibi) transformation.\n\nArguments\n\npositions::Matrix{<:Unitful.Length}: Positions of the cells/particles. Each column is a cell/particle and each row a dimension.\nvelocities::Matrix{<:Unitful.Velocity}: Velocities of the cells/particles. Each column is a cell/particle and each row a dimension.\nmasses::Vector{<:Unitful.Mass}: Mass of every cell/particle.\n\nReturns\n\nThe rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.computeCenter-Tuple{Dict, Int64, Int64}","page":"Computation of characteristic positions","title":"GalaxyInspector.computeCenter","text":"computeCenter(\n    data_dict::Dict,\n    halo_idx::Int,\n    subhalo_rel_idx::Int,\n)::Vector{<:Unitful.Length}\n\nReturn the 3D position of the potential minimum for a halo or subhalo.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present:\n:group   => [\"G_Nsubs\", \"G_Pos\"]\n:subhalo => [\"S_Pos\"]\nhalo_idx::Int: Index of the target halo (FoF group). Starts at 1.\nsubhalo_rel_idx::Int: Index of the target subhalo (subfind), relative to the target halo. Starts at 1. If set to 0, the halo potential minimum is returned.\n\nReturns\n\nThe 3D position of the potential minimum.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.computeCenter-Tuple{Dict, Int64}","page":"Computation of characteristic positions","title":"GalaxyInspector.computeCenter","text":"computeCenter(data_dict::Dict, subhalo_abs_idx::Int)::Vector{<:Unitful.Length}\n\nReturn the 3D position of the potential minimum for a given subhalo.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present:\n:subhalo => [\"S_Pos\"]\nsubhalo_abs_idx::Int: Absolute index of the target subhalo (subfind). Starts at 1.\n\nReturns\n\nThe 3D position of the potential minimum.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.computeCenter-Tuple{Dict, Symbol}","page":"Computation of characteristic positions","title":"GalaxyInspector.computeCenter","text":"computeCenter(data_dict::Dict, cm_type::Symbol)::Vector{<:Unitful.Length}\n\nCompute a characteristic center of mass for the system.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of cm_type:\nIf cm_type == :all:\n[\"POS \", \"MASS\"] for every cell/particle type in the snapshot (see computeCenterOfMass).\nIf haskey(PARTICLE_INDEX, cm_type):\ncm_type => [\"POS \", \"MASS\"].\nIf cm_type == :zero:\nNo blocks are required.\ncm_type::Symbol: It can be:\n:all         -> Center of mass of the whole system.\n:{component} -> Center of mass of the given component (e.g. :stellar, :gas, :darkmatter, etc). It can be any of the keys of [`PARTICLEINDEX`](@ref).\n:zero        -> Origin.\n\nReturns\n\nThe center of mass.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.computeCenterOfMass-Tuple{Dict, Symbol}","page":"Computation of characteristic positions","title":"GalaxyInspector.computeCenterOfMass","text":"computeCenterOfMass(data_dict::Dict, component::Symbol)::Vector{<:Unitful.Length}\n\nCompute the center of mass of component.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present for every cell/particle that you want to be taken into account:\ncell/particle type => [\"POS \", \"MASS\"]\ncomponent::Symbol: Target component. The options are:\n:all         -> Every component present in data_dict.\n:{component} -> Any of the keys of PARTICLE_INDEX, if present in data_dict.\n\nReturns\n\nThe center of mass.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.computeCenterOfMass-Tuple{Matrix{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic positions","title":"GalaxyInspector.computeCenterOfMass","text":"computeCenterOfMass(\n    positions::Matrix{<:Unitful.Length},\n    masses::Vector{<:Unitful.Mass},\n)::Vector{<:Unitful.Length}\n\nCompute the center of mass of a group of cells/particles.\n\nArguments\n\npositions::Matrix{<:Unitful.Length}: Positions of the cells/particles. Each column is a cell/particle and each row a dimension.\nmasses::Vector{<:Unitful.Mass}: Masses of the cells/particles.\n\nReturns\n\nThe center of mass.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.computePARotationMatrix-Tuple{Dict, Symbol}","page":"Computation of characteristic positions","title":"GalaxyInspector.computePARotationMatrix","text":"computePARotationMatrix(\n    data_dict::Dict,\n    component::Symbol,\n)::Union{Matrix{Float64},UniformScaling{Bool},Nothing}\n\nCompute the rotation matrix that will turn the principal axis of component into the new coordinate system, when view as an passive (alias) transformation.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present for every cell/particle that you want to be taken into account:\ncell/particle type => [\"POS \", \"MASS\", \"VEL \"]\ncomponent::Symbol: Target component. The options are:\n:all         -> Every component present in data_dict.\n:{component} -> Any of the keys of PARTICLE_INDEX, if present in data_dict.\n\nReturns\n\nThe rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.computePARotationMatrix-Tuple{Matrix{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Matrix{<:Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic positions","title":"GalaxyInspector.computePARotationMatrix","text":"computePARotationMatrix(\n    positions::Matrix{<:Unitful.Length},\n    velocities::Matrix{<:Unitful.Velocity},\n    masses::Vector{<:Unitful.Mass},\n)::Union{Matrix{Float64},UniformScaling{Bool}}\n\nCompute the rotation matrix that will turn the principal axis into the new coordinate system, when view as an passive (alias) transformation.\n\nArguments\n\npositions::Matrix{<:Unitful.Length}: Positions of the cells/particles. Each column is a cell/particle and each row a dimension.\nvelocities::Matrix{<:Unitful.Velocity}: Velocities of the cells/particles. Each column is a cell/particle and each row a dimension.\nmasses::Vector{<:Unitful.Mass}: Mass of every cell/particle.\n\nReturns\n\nThe rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.computeRadialDistance-Tuple{Dict, Symbol}","page":"Computation of characteristic positions","title":"GalaxyInspector.computeRadialDistance","text":"computeRadialDistance(data_dict::Dict, component::Symbol)::Vector{<:Unitful.Length}\n\nCompute the distance of each cell/particle to the origin.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present for the cell/particle type corresponding to component:\ncell/particle type => [\"POS \"].\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nThe distance of each cell/particles to the origin.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.computeXYDistance-Tuple{Dict, Symbol}","page":"Computation of characteristic positions","title":"GalaxyInspector.computeXYDistance","text":"computeXYDistance(data_dict::Dict, component::Symbol)::Vector{<:Unitful.Length}\n\nCompute the projected distance of each cell/particle to the origin, in the xy plane.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present for the cell/particle type corresponding to component:\ncell/particle type => [\"POS \"].\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nThe projected distance of each cell/particles to the origin.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.findStellarHalo-Tuple{Dict, Vector{Int64}, Vector{Bool}}","page":"Computation of characteristic positions","title":"GalaxyInspector.findStellarHalo","text":"findStellarHalo(\n    data_dict::Dict,\n    star_idxs::Vector{Int},\n    real_stars_idxs::Vector{Bool},\n)::Vector{Int}\n\nFind in which halo of data_dict each star in star_idxs is located.\n\nFor stars with no halo, an index of -1 is given.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present:\n:group   => [\"G_LenType\"]\nstar_idxs::Vector{Int}: Indices of the target stars in data_dict. The indices are relative to the stars in data_dict[:stellar].\nreal_stars_idxs::Vector{Bool}: Boolean list of stellar particles. True for real stars and false for wind particles. The indices are relative to the list of stars/wind particles in the snapshot (i.e. the output of findRealStars).\n\nReturns\n\nA vector with the halo (index starting at 1) of each star (in the order of star_idxs).\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.findStellarHaloSubhalo-Tuple{Dict, Vector{Int64}, Vector{Bool}}","page":"Computation of characteristic positions","title":"GalaxyInspector.findStellarHaloSubhalo","text":"findStellarHaloSubhalo(\n    data_dict::Dict,\n    star_idxs::Vector{Int},\n    real_stars_idxs::Vector{Bool},\n)::NTuple{2,Vector{Int}}\n\nFind in which halo and subhalo of data_dict each star in star_idxs is located.\n\nFor stars with no halo or subhalo, an index of -1 is given. The subhalo index is relative to the corresponding halo.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present:\n:group   => [\"G_Nsubs\", \"G_LenType\"]\n:subhalo => [\"S_LenType\"]\nstar_idxs::Vector{Int}: Indices of the target stars in data_dict. The indices are relative to the stars in data_dict[:stellar].\nreal_stars_idxs::Vector{Bool}: Boolean list of stellar particles. True for real stars and false for wind particles. The indices are relative to the list of stars/wind particles in the snapshot (i.e. the output of findRealStars).\n\nReturns\n\nA tuple with two elements:\nA vector with the halo (index starting at 1) of each star (in the order of star_idxs).\nA vector with the subhalo (index starting at 1) of each star (in the order of star_idxs).\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/positions/#GalaxyInspector.locateStellarBirthPlace-Tuple{Dict}","page":"Computation of characteristic positions","title":"GalaxyInspector.locateStellarBirthPlace","text":"locateStellarBirthPlace(data_dict::Dict)::NTuple{2,Vector{Int}}\n\nFind in which halo and subhalo each star in data_dict was born.\n\nFor stars with no halo or subhalo, an index of -1 is given. The subhalo index is relative to the corresponding halo.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present:\n:stellar => [\"GAGE\", \"ID  \"]\n\nReturns\n\nA tuple with two elements:\nA vector with the birth halo (index starting at 1) of each star (in the order of data_dict).\nA vector with the birth subhalo (index starting at 1) of each star (in the order of data_dict).\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/aggregators/#Aggregator-function","page":"Aggregator function","title":"Aggregator function","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/analysis/compute_quantities/aggregators/#GalaxyInspector.integrateQty-Tuple{Dict, Symbol}","page":"Aggregator function","title":"GalaxyInspector.integrateQty","text":"integrateQty(data_dict::Dict, quantity::Symbol; <keyword arguments>)::Number\n\nCompute quantity for the whole system of cell/particles in data_dict.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nquantity::Symbol: Target quantity. See plotParams for possibilities.\nagg_function::Union{Function,Symbol}=:default: If quantity is one the the listed symbols in DERIVED_QTY, SFM_STELLAR_QTY or SFM_GAS_QTY, you can pass an agg_function to accumulate the values given by scatterQty. If agg_function is left as :default integrateQty will try to compute the most reasonable global value for quantity.\n\nReturns\n\nThe value of quantity for the whole system of cell/particles in data_dict.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}","page":"Aggregator function","title":"GalaxyInspector.scatterQty","text":"scatterQty(data_dict::Dict, quantity::Symbol)::Vector{<:Number}\n\nCompute quantity for each cell/particle in data_dict.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nquantity::Symbol: Target quantity. See plotParams for possibilities; only quantities well defined for each cell/particle individually are possible.\n\nReturns\n\nThe values of quantity for every cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/tracers/#Tracer-functions","page":"Tracer functions","title":"Tracer functions","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/analysis/tracers/#GalaxyInspector.filterExistIDs!-Tuple{Dict, Symbol, Vector{UInt64}}","page":"Tracer functions","title":"GalaxyInspector.filterExistIDs!","text":"filterExistIDs!(target_ids::Vector{UInt}, component::Symbol, data_dict::Dict)::Nothing\n\nFilter out IDs from target_ids that do not exist for component.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\ntarget_ids::Vector{UInt}: IDs to be filtered.\n\nReturns\n\nA vector with only the IDs of target_ids that exist for component.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/tracers/#GalaxyInspector.idMass!-Tuple{Dict, Symbol, Vector{UInt64}}","page":"Tracer functions","title":"GalaxyInspector.idMass!","text":"idMass!(\n    data_dict::Dict,\n    component::Symbol,\n    target_ids::Vector{UInt};\n    <keyword arguments>\n)::Unitful.Mass\n\nCompute the total mass of the cells/particles with IDs given by target_ids.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\ntarget_ids::Vector{UInt}: Target IDs.\ntracers::Bool=false: If the mass will be computed using tracers or the proper mass of each cell/particle.\n\nReturns\n\nThe total mass.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/tracers/#GalaxyInspector.idToIndex-Tuple{Dict, Vector{<:Unsigned}}","page":"Tracer functions","title":"GalaxyInspector.idToIndex","text":"idToIndex(data_dict::Dict, target_ids::Vector{<:Unsigned})::Dict{Symbol,Vector{Int}}\n\nFind the indices of the cells/particles given their IDs.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ntarget_ids::Vector{<:Unsigned}: List of IDs.\n\nReturns\n\nA dictionary with the following shape:\ncell/particle type::Symbol -> indices::Int\ncell/particle type::Symbol -> indices::Int\ncell/particle type::Symbol -> indices::Int\n...\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/tracers/#GalaxyInspector.idWithinDisk-Tuple{Dict, Symbol, Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}, Vararg{Any}}","page":"Tracer functions","title":"GalaxyInspector.idWithinDisk","text":"idWithinDisk(\n    data_dict::Dict,\n    component::Symbol,\n    max_r::Unitful.Length,\n    max_z::Unitful.Length,\n    origin...,\n)::Vector{UInt}\n\nFind the IDs the the cell/particles of component that are within the given galactic disk.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\nmax_r::Unitful.Length: Radius of the disk.\nmax_z::Unitful.Length: Half height of the disk.\norigin...: Center of the disk. It can be any number and type of argument compatible with the second to last arguments of a computeCenter method.\n\nReturns\n\nA vector with the IDs.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/tracers/#GalaxyInspector.idWithinR200-Tuple{Dict, Symbol}","page":"Tracer functions","title":"GalaxyInspector.idWithinR200","text":"idWithinR200(data_dict::Dict, component::Symbol; <keyword arguments>)::Vector{UInt}\n\nFind the IDs the the cell/particles of component that are within the virial radius of halo halo_idx.\n\nnote: Note\nThis function assumes that no translation of the coordinate system has been done. It uses as the center of the halo the position given by the group catalog files, which are unaffected by coordinate transformation of the data.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\nhalo_idx::Int=1: Index of the target halo (FoF group). Starts at 1.\n\nReturns\n\nA vector with the IDs.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/tracers/#GalaxyInspector.parentToTracerID-Tuple{Dict, Vector{<:Unsigned}}","page":"Tracer functions","title":"GalaxyInspector.parentToTracerID","text":"parentToTracerID(data_dict::Dict, target_ids::Vector{<:Unsigned})::Vector{UInt}\n\nFind the tracer IDs given a list of parent IDs.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ntarget_ids::Vector{<:Unsigned}: List of parent IDs.\n\nReturns\n\nA vector with the IDs of the tracers. There is no guarantee length or order for this vector.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/tracers/#GalaxyInspector.parentToTracerMass-Tuple{Dict, Vector{<:Unsigned}}","page":"Tracer functions","title":"GalaxyInspector.parentToTracerMass","text":"parentToTracerMass(\n    data_dict::Dict,\n    target_ids::Vector{<:Unsigned},\n)::Unitful.Mass\n\nFind the mass of tracers given a list of parent IDs, ignoring parents without tracers\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ntarget_ids::Vector{<:Unsigned}: List of parent IDs.\n\nReturns\n\nThe total mass of tracers.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/tracers/#GalaxyInspector.tracerToParentID-Tuple{Dict, Vector{<:Unsigned}}","page":"Tracer functions","title":"GalaxyInspector.tracerToParentID","text":"tracerToParentID(data_dict::Dict, target_ids::Vector{<:Unsigned})::Vector{UInt}\n\nFind the parent IDs given a list of tracer IDs.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ntarget_ids::Vector{<:Unsigned}: List of tracer IDs.\n\nReturns\n\nA vector with the IDs of the parents. There is no guarantee length or order for this vector.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/tracers/#GalaxyInspector.tracersToParentMass-Tuple{Dict, Vector{<:Unsigned}}","page":"Tracer functions","title":"GalaxyInspector.tracersToParentMass","text":"tracersToParentMass(\n    data_dict::Dict,\n    target_ids::Vector{<:Unsigned},\n)::Dict{Symbol,Vector{<:Unitful.Mass}}\n\nFind the masses of the parents given a list of tracer IDs.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ntarget_ids::Vector{<:Unsigned}: List of tracer IDs.\n\nReturns\n\nA dictionary with the following shape:\ncell/particle type -> masses::Vector{<:Unitful.Mass}\ncell/particle type -> masses::Vector{<:Unitful.Mass}\ncell/particle type -> masses::Vector{<:Unitful.Mass}\n...\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/grid/#Grid-utilities","page":"Grid utilities","title":"Grid utilities","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/auxiliary_functions/grid/#GalaxyInspector.equalAreaBins-Tuple{Number, Int64}","page":"Grid utilities","title":"GalaxyInspector.equalAreaBins","text":"equalAreaBins(radius::Number, n_bins::Int; shift::Number=zero(radius))::Vector{<:Number}\n\nCompute the bin edges that make each bin have equal area.\n\nArguments\n\nradius::Number: Radius of the grid (equal to the last bin edge).\nn_bins::Int: Number of bins.\nshift::Number=zero(radius): Distance of the first bin edge to the center.\n\nReturns\n\nThe bin edges\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/grid/#GalaxyInspector.equalVolumeBins-Tuple{Number, Int64}","page":"Grid utilities","title":"GalaxyInspector.equalVolumeBins","text":"equalVolumeBins(radius::Number, n_bins::Int; shift::Number=zero(radius))::Vector{<:Number}\n\nCompute the bin edges that make each bin have equal volume.\n\nArguments\n\nradius::Number: Radius of the grid (equal to the last bin edge).\nn_bins::Int: Number of bins.\nshift::Number=zero(radius): Distance of the first bin edge to the center.\n\nReturns\n\nThe bin edges\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/grid/#GalaxyInspector.flattenGrid-Tuple{GalaxyInspector.CubicGrid}","page":"Grid utilities","title":"GalaxyInspector.flattenGrid","text":"flattenGrid(cubic_grid::CubicGrid)::SquareGrid\n\nFrom a CubicGrid construct a SquareGrid with the same center, number of bins, and physical side length.\n\nArguments\n\ncubic_grid::CubicGrid: Cubic grid.\n\nReturns\n\nA square grid.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/grid/#GalaxyInspector.projectIntoCircularGrid-Tuple{Matrix{<:Number}, Int64}","page":"Grid utilities","title":"GalaxyInspector.projectIntoCircularGrid","text":"projectIntoCircularGrid(\n    image::Matrix{<:Number},\n    n_bins::Int;\n    <keyword arguments>\n)::Vector{<:Number}\n\nProject a given matrix into a circular grid, averaging or adding up the values in each concentric ring.\n\nArguments\n\nimage::Matrix{<:Number}: Original matrix. It has to be a square matrix.\nn_bins::Int: Number of bins for the circular grid.\ninscribed::Bool=true: If the circular grid will be inscribed in image when doing the projection. If set to false, the matrix will be inscribed into the circular grid instead.\ntotal::Bool=false: If the sum (total = true) or the mean (total = false) of the values in image, that fall within each ring, will be used.\n\nReturns\n\nA vector with the average or sum of the values that fall within each concentric ring.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/grid/#GalaxyInspector.reduceMatrix-Tuple{Matrix{<:Number}, Int64}","page":"Grid utilities","title":"GalaxyInspector.reduceMatrix","text":"reduceMatrix(\n    hr_matrix::Matrix{<:Number},\n    factor::Int;\n    <keyword arguments>\n)::Matrix{<:Number}\n\nReduce the number of rows and columns of a given square matrix by factor, averaging or adding up its values.\n\nArguments\n\nhr_matrix::Matrix{<:Number}: Original \"high resolution\" matrix. It has to be a square matrix.\nfactor::Int: Factor by which the number of rows and columns will be reduced. It has to divide the size of hr_matrix exactly.\ntotal::Bool=false: If the sum (total = true) or the mean (total = false) of the high resolution values will be used for the new matrix.\n\nReturns\n\nThe new smaller matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/grid/#GalaxyInspector.scaledBins-Tuple{Vector{<:Number}, Int64}","page":"Grid utilities","title":"GalaxyInspector.scaledBins","text":"scaledBins(\n    values::Vector{<:Number},\n    n_bins::Int;\n    <keyword arguments>\n)::Vector{Float64}\n\nCompute a set of bin edges, that will encompass a given list of values.\n\nArguments\n\nvalues::Vector{<:Number}: Values to be binned.\nn_bins::Int: Number of bins.\nscaling::Function=identity: Scaling function. The options are the scaling functions accepted by Makie: log10, log2, log, sqrt, Makie.logit, Makie.Symlog10, Makie.pseudolog10, and identity.\nlimits::Tuple{<:Number,<:Number}=(-Inf, Inf): Set it to a value different than (-Inf, Inf) if you want to fix the limits of the bins.\n\nReturns\n\nA sorted list of bin edges.\n\n\n\n\n\n","category":"method"},{"location":"api/constants/globals/#Global-constants","page":"Global constants","title":"Global constants","text":"This is a list of constant and types used in GalaxyInspector.\n\nNone of these are exported.\n\n","category":"section"},{"location":"api/constants/globals/#GalaxyInspector.ABUNDANCE_SHIFT","page":"Global constants","title":"GalaxyInspector.ABUNDANCE_SHIFT","text":"Shift for the solar abundance in dex.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.AGE_RESOLUTION","page":"Global constants","title":"GalaxyInspector.AGE_RESOLUTION","text":"Characteristic stellar age limit for the SFR and sSFR.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.ALPHA_BLITZ","page":"Global constants","title":"GalaxyInspector.ALPHA_BLITZ","text":"Reference exponent for the molecular fraction-pressure relation, from Blitz et al. (2006) (Table 2, \"Mean\" row, Second column).\n\nWe use -α here.\n\nReferences\n\nL. Blitz et al. (2006). The Role of Pressure in GMC Formation II: The H2-Pressure Relation. The Astrophysical Journal, 650(2), 933. doi:10.1086/505417\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.ATOMIC_WEIGHTS","page":"Global constants","title":"GalaxyInspector.ATOMIC_WEIGHTS","text":"Standard atomic weights.\n\nReferences\n\nT. Prohaska et al. (2022). Standard atomic weights of the elements 2021 (IUPAC Technical Report). Pure and Applied Chemistry, 94(5), 573-600. doi:10.1515/pac-2019-0603\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.A_BIGIEL2008_BF_MOLECULAR","page":"Global constants","title":"GalaxyInspector.A_BIGIEL2008_BF_MOLECULAR","text":"Kennicutt-Schmidt law best-fit for molecular gas, from Bigiel et al. (2008) (Section 4.3, Equation 3).\n\nPower-law index, N, and A = log_10(a), where a is Sigma_mathrmSFR at the fiducial gas surface density of 10  mathrmM_odot  pc^-2 are given.\n\nSigma_mathrmSFR = a left( fracSigma_mathrmH_210  mathrmM_odot  pc^-2 right)^N  \n\nReferences\n\nF. Bigiel et al. (2008). THE STAR FORMATION LAW IN NEARBY GALAXIES ON SUB-KPC SCALES. The Astrophysical Journal, 136(6), 2846. doi:10.1088/0004-6256/136/6/2846\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.A_BIGIEL2008_MOLECULAR","page":"Global constants","title":"GalaxyInspector.A_BIGIEL2008_MOLECULAR","text":"Kennicutt-Schmidt law fits for molecular and neutral gas, from Bigiel et al. (2008) (Table 2, Average).\n\nPower-law index, N, and A = log_10(a), where a is Sigma_mathrmSFR at the fiducial gas surface density of 10  mathrmM_odot  pc^-2 are given.\n\nSigma_mathrmSFR = a left( fracSigma_mathrmHI H_2 gas10  mathrmM_odot  pc^-2 right)^N  \n\nReferences\n\nF. Bigiel et al. (2008). THE STAR FORMATION LAW IN NEARBY GALAXIES ON SUB-KPC SCALES. The Astrophysical Journal, 136(6), 2846. doi:10.1088/0004-6256/136/6/2846\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.BIGIEL2008_SFR_RANGE","page":"Global constants","title":"GalaxyInspector.BIGIEL2008_SFR_RANGE","text":"Range of values for\n\nSigma_mathrmSFR  mathrmM_odot  yr^-1  kpc^-2  \n\nin the seven spirals in Table 1 of Bigiel et al. (2008), with associated molecular data.\n\nThe actual values for the SFR density are taken from Table 2 in Bigiel et al. (2010), using only the ones with associated molecular data.\n\nReferences\n\nF. Bigiel et al. (2008). THE STAR FORMATION LAW IN NEARBY GALAXIES ON SUB-KPC SCALES. The Astrophysical Journal, 136(6), 2846. doi:10.1088/0004-6256/136/6/2846\n\nF. Bigiel et al. (2010). EXTREMELY INEFFICIENT STAR FORMATION IN THE OUTER DISKS OF NEARBY GALAXIES. The Astrophysical Journal, 140(5), 1194. doi:10.1088/0004-6256/140/5/1194\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.BIGIEL2010_TABLE_2","page":"Global constants","title":"GalaxyInspector.BIGIEL2010_TABLE_2","text":"Path to Table 2 from Bigiel et al. (2010).\n\nReferences\n\nF. Bigiel et al. (2010). EXTREMELY INEFFICIENT STAR FORMATION IN THE OUTER DISKS OF NEARBY GALAXIES. The Astrophysical Journal, 140(5), 1194. doi:10.1088/0004-6256/140/5/1194\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.BIGIEL2010_TABLE_3","page":"Global constants","title":"GalaxyInspector.BIGIEL2010_TABLE_3","text":"Path to Table 3 from Bigiel et al. (2010).\n\nReferences\n\nF. Bigiel et al. (2010). EXTREMELY INEFFICIENT STAR FORMATION IN THE OUTER DISKS OF NEARBY GALAXIES. The Astrophysical Journal, 140(5), 1194. doi:10.1088/0004-6256/140/5/1194\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.BIGIEL_PX_SIZE","page":"Global constants","title":"GalaxyInspector.BIGIEL_PX_SIZE","text":"Spatial resolution used in Bigiel et al. (2008).\n\nReferences\n\nF. Bigiel et al. (2008). THE STAR FORMATION LAW IN NEARBY GALAXIES ON SUB-KPC SCALES. The Astrophysical Journal, 136(6), 2846. doi:10.1088/0004-6256/136/6/2846\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.BOX_L","page":"Global constants","title":"GalaxyInspector.BOX_L","text":"Characteristic box size.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.CYCLE","page":"Global constants","title":"GalaxyInspector.CYCLE","text":"Default cycler.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.ColorType","page":"Global constants","title":"GalaxyInspector.ColorType","text":"Color type.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.DEFAULT_THEME","page":"Global constants","title":"GalaxyInspector.DEFAULT_THEME","text":"Default plot theme.\n\nRegarding the graphic units used, we know that 1  mathrmmm = 283466  mathrmpt and 1  mathrmin = 254  mathrmmm. Then, if we want 1  mathrmcodeunit = 01  mathrmmm in vector graphics, we have to use pt_per_unit = 0.283466.\n\nFor pixel images, we control the ppi with px_per_unit. A reasonable high ppi is 600. So, using px_per_unit = 23622 we get 23622  mathrmpxmm sim 600  mathrmpxin (remember that 1  mathrmcodeunit = 01  mathrmmm).\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.DISK_HEIGHT","page":"Global constants","title":"GalaxyInspector.DISK_HEIGHT","text":"Characteristic height.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.DISK_R","page":"Global constants","title":"GalaxyInspector.DISK_R","text":"Characteristic radius.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.FELDMANN2020_DATA_PATH","page":"Global constants","title":"GalaxyInspector.FELDMANN2020_DATA_PATH","text":"Path to the file with the global galactic properties from Feldmann (2020).\n\nReferences\n\nR. Feldmann (2020). The link between star formation and gas in nearby galaxies. Communications Physics 3(226). doi:10.1038/s42005-020-00493-0\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.GAS_ABUNDANCE","page":"Global constants","title":"GalaxyInspector.GAS_ABUNDANCE","text":"List of symbols for the gas abundance quantities.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.GAS_ABUNDANCE_SPLITS","page":"Global constants","title":"GalaxyInspector.GAS_ABUNDANCE_SPLITS","text":"Dictionary mapping each gas abundance quantity to its element.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.HESTIA_SUBHALOS","page":"Global constants","title":"GalaxyInspector.HESTIA_SUBHALOS","text":"Subhalo numbers for the MW and M31 in Hestia simulations.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.ILLUSTRIS_L_UNIT","page":"Global constants","title":"GalaxyInspector.ILLUSTRIS_L_UNIT","text":"Internal unit of length used in IllustrisTNG, equal to 10   mathrmkpc.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.ILLUSTRIS_M_UNIT","page":"Global constants","title":"GalaxyInspector.ILLUSTRIS_M_UNIT","text":"Internal unit of mass used in IllustrisTNG, equal to 10^10  mathrmM_odot.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.ILLUSTRIS_V_UNIT","page":"Global constants","title":"GalaxyInspector.ILLUSTRIS_V_UNIT","text":"Internal unit of velocity used in IllustrisTNG, equal to 10  mathrmkm  s^-1.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.INDEX_PARTICLE","page":"Global constants","title":"GalaxyInspector.INDEX_PARTICLE","text":"Type of cell/particle corresponding to each code index.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.IndexType","page":"Global constants","title":"GalaxyInspector.IndexType","text":"Index type.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.KS98_SFR_RANGE","page":"Global constants","title":"GalaxyInspector.KS98_SFR_RANGE","text":"Range of values for\n\nSigma_mathrmSFR  mathrmM_odot  yr^-1  kpc^-2  \n\nfrom the combine data (Table 1 and 2) in Kennicutt (1998).\n\nReferences\n\nR. C. Kennicutt (1998). The Global Schmidt Law in Star-forming Galaxies. The Astrophysical Journal, 498(2), 541-552. doi:10.1086/305588\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.LEROY2008_DATA_PATH","page":"Global constants","title":"GalaxyInspector.LEROY2008_DATA_PATH","text":"Path to the file with the profiles from Leroy et al. (2008).\n\nReferences\n\nA. K. Leroy et al. (2008). THE STAR FORMATION EFFICIENCY IN NEARBY GALAXIES: MEASURING WHERE GAS FORMS STARS EFFECTIVELY. The Astronomical Journal 136(6), 2782–2845. doi:10.1088/0004-6256/136/6/2782\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.LINE_STYLES","page":"Global constants","title":"GalaxyInspector.LINE_STYLES","text":"Default list of line styles.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.LineStyleType","page":"Global constants","title":"GalaxyInspector.LineStyleType","text":"Line style type.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.MARKERS","page":"Global constants","title":"GalaxyInspector.MARKERS","text":"Default list of marker types.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.MCMILLAN2011_DATA_PATH","page":"Global constants","title":"GalaxyInspector.MCMILLAN2011_DATA_PATH","text":"Path to the file with the fits from McMillan (2011).\n\nReferences\n\nP. J. McMillan (2011). Mass models of the Milky Way. Monthly Notices of the Royal Astronomical Society 414(3), 2446–2457. doi:10.1111/j.1365-2966.2011.18564.x\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.MOLLA2015_DATA_PATH","page":"Global constants","title":"GalaxyInspector.MOLLA2015_DATA_PATH","text":"Path to the file with the Milky Way profiles from Mollá et al. (2015).\n\nReferences\n\nM. Mollá et al. (2015). Galactic chemical evolution: stellar yields and the initial mass function. Monthly Notices of the Royal Astronomical Society 451(4), 3693–3708. doi:10.1093/mnras/stv1102\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.N_KS98","page":"Global constants","title":"GalaxyInspector.N_KS98","text":"Slope of the Kennicutt-Schmidt law, taken from Kennicutt (1998) (Section 4, Equation 4).\n\nSigma_mathrmSFR = a left( fracSigma_mathrmgas1  mathrmM_odot  pc^-2 right)^N mathrmM_odot  yr^-1  kpc^-2  \n\nReferences\n\nR. C. Kennicutt (1998). The Global Schmidt Law in Star-forming Galaxies. The Astrophysical Journal, 498(2), 541-552. doi:10.1086/305588\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.P0","page":"Global constants","title":"GalaxyInspector.P0","text":"Reference pressure for the molecular fraction-pressure relation, from Blitz et al. (2006) (Table 2, \"Mean\" row, Third column).\n\nReferences\n\nL. Blitz et al. (2006). The Role of Pressure in GMC Formation II: The H2-Pressure Relation. The Astrophysical Journal, 650(2), 933. doi:10.1086/505417\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.PARTICLE_CODE_NAME","page":"Global constants","title":"GalaxyInspector.PARTICLE_CODE_NAME","text":"Internal code name (data group in the HDF5 output) corresponding to each type of cell/particle.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.PARTICLE_TYPE","page":"Global constants","title":"GalaxyInspector.PARTICLE_TYPE","text":"Type of cell/particle corresponding to each internal code name (data group in the HDF5 output).\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.PASS_ALL","page":"Global constants","title":"GalaxyInspector.PASS_ALL","text":"Filter dictionary that does not exclude any cell/particle.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.PASS_NONE","page":"Global constants","title":"GalaxyInspector.PASS_NONE","text":"Filter dictionary that excludes every cell/particle.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.PHYSICAL_UNITS","page":"Global constants","title":"GalaxyInspector.PHYSICAL_UNITS","text":"If physical units (lengths) will be used, instead of comoving units (lengths).\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.ReducedIndexType","page":"Global constants","title":"GalaxyInspector.ReducedIndexType","text":"Reduced index type.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.RotationType","page":"Global constants","title":"GalaxyInspector.RotationType","text":"Rotation type\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.SOLAR_ABUNDANCE","page":"Global constants","title":"GalaxyInspector.SOLAR_ABUNDANCE","text":"Solar abundances.\n\nThey are defined as 12 + log_10(N_mathrmX  N_mathrmH), where N_mathrmX and N_mathrmH are the number densities of element mathrmX and hydrogen respectively.\n\nReferences\n\nM. Asplund et al. (2009). The Chemical Composition of the Sun. Annual Review of Astronomy and Astrophysics, 47(1), 481–522. doi:10.1146/annurev.astro.46.060407.145222\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.STELLAR_ABUNDANCE","page":"Global constants","title":"GalaxyInspector.STELLAR_ABUNDANCE","text":"List of symbols for the stellar abundance quantities.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.STELLAR_ABUNDANCE_SPLITS","page":"Global constants","title":"GalaxyInspector.STELLAR_ABUNDANCE_SPLITS","text":"Dictionary mapping each stellar abundance quantity to its element.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.SUN2023_TABLE","page":"Global constants","title":"GalaxyInspector.SUN2023_TABLE","text":"Path to Table A1 from Sun et al. (2023).\n\nReferences\n\nJ. Sun et al. (2023). Star Formation Laws and Efficiencies across 80 Nearby Galaxies. The Astrophysical Journal Letters, 945(2), L19. doi:10.3847/2041-8213/acbd9c\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.SUN_PX_SIZE","page":"Global constants","title":"GalaxyInspector.SUN_PX_SIZE","text":"Spatial resolution used in Sun et al. (2023).\n\nReferences\n\nJ. Sun et al. (2023). Star Formation Laws and Efficiencies across 80 Nearby Galaxies. The Astrophysical Journal Letters, 945(2), L19. doi:10.3847/2041-8213/acbd9c\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.TRANSFORM_LIST","page":"Global constants","title":"GalaxyInspector.TRANSFORM_LIST","text":"List of symbols for the transformation presets.\n\nThe options have the form :{component}_{group} selecting which cells/particle to consider for the center of mass (new origin for the translation) and principal axis (new reference system for the rotation), where component can be:\n\n  + :all         -> Every component present in data_dict\n  + :{component} -> One of the keys of PARTICLE_INDEX\n\nand group can be:\n  + :box     -> Whole simulation box\n  + :halo    -> Main halo\n  + :subhalo -> Main subhalo\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.TRANSFORM_SPLITS","page":"Global constants","title":"GalaxyInspector.TRANSFORM_SPLITS","text":"Dictionary mapping each transformation to its component and group.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.TranslationType","page":"Global constants","title":"GalaxyInspector.TranslationType","text":"Translation type\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.WONG_BLUE","page":"Global constants","title":"GalaxyInspector.WONG_BLUE","text":"Default colors.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.a_KS98","page":"Global constants","title":"GalaxyInspector.a_KS98","text":"Intercept of the Kennicutt-Schmidt law, taken from Kennicutt (1998) (Section 4, Equation 4).\n\nSigma_mathrmSFR = a left( fracSigma_mathrmgas1  mathrmM_odot  pc^-2 right)^N mathrmM_odot  yr^-1  kpc^-2  \n\nReferences\n\nR. C. Kennicutt (1998). The Global Schmidt Law in Star-forming Galaxies. The Astrophysical Journal, 498(2), 541-552. doi:10.1086/305588\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.logging","page":"Global constants","title":"GalaxyInspector.logging","text":"If logging messages will be printed out.\n\n\n\n\n\n","category":"constant"},{"location":"api/constants/globals/#GalaxyInspector.CircularGrid","page":"Global constants","title":"GalaxyInspector.CircularGrid","text":"Circular grid (2D or 3D).\n\nSeries of concentric rings or spherical shells.\n\nFields\n\ngrid::Vector{<:Number}: Distance of (the center of) each bin to the center of the grid.\nedges::Vector{<:Number}: Distance of the edges of the bins to the center of the grid.\ncenter::Vector{<:Number}: 3D location of the center of the grid. In the 2D case the grid is assumed to be in the xy plane.\nbin_area::Vector{<:Number}: Area of each ring.\nbin_volumes::Vector{<:Number}: Volume of each spherical shell.\nlog::Bool: If the grid is logarithmic.\nregular::Bool: If the grid is regular.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.CubicGrid","page":"Global constants","title":"GalaxyInspector.CubicGrid","text":"Cubic grid (3D).\n\nFields\n\ngrid::Array{NTuple{3,<:Number},3}: Matrix with the coordinates of (the center of) each bin.\nx_bins::Vector{<:Number}: x coordinates of the bins.\ny_bins::Vector{<:Number}: y coordinates of the bins.\nz_bins::Vector{<:Number}: z coordinates of the bins.\ncenter::Vector{<:Number}: 3D location of the center of the grid.\ngrid_size::Number: Side length of the grid.\nn_bins::Int: Number of bins per side.\nbin_width::Number: Side length of each bin.\nbin_area::Number: Face area of each bin.\nbin_volume::Number: Volume of each bin.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.GroupCatHeader","page":"Global constants","title":"GalaxyInspector.GroupCatHeader","text":"Data in the \"Header\" group of a HDF5 group catalog file.\n\nThe default values are for when there are no group catalog files.\n\nFields\n\nbox_size::Float64 = NaN: Total size of the simulation box, in internal units of length.\nh::Float64 = NaN: Dimensionless Hubble parameter, \"little h\".\nn_groups_part::Int32 = -1: Number of halos (FoF groups) in this file chunk.\nn_groups_total::Int32 = -1: Total number of halos (FoF groups) in this snapshot.\nn_subgroups_part::Int32 = -1: Number of subhalos (subfind) in this file chunk.\nn_subgroups_total::Int32 = -1: Total number of subhalos (subfind) in this snapshot.\nnum_files::Int32 = -1: Number of file chunks per snapshot.\nomega_0::Float64 = NaN: The cosmological density parameter for matter.\nomega_l::Float64 = NaN: The cosmological density parameter for the cosmological constant.\nredshift::Float64 = NaN: The redshift.\ntime::Float64 = NaN: The physical time or the scale factor, depending on the type of simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.GroupCatalog","page":"Global constants","title":"GalaxyInspector.GroupCatalog","text":"Metadata for a group catalog file.\n\nFields\n\npath::Union{String,Missing}: Full path to the group catalog file.\nheader::GroupCatHeader: Header.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.InternalUnits","page":"Global constants","title":"GalaxyInspector.InternalUnits","text":"Unit conversion factors.\n\nFields\n\nx_cgs::Unitful.Length: From internal units of length to mathrmcm.\nx_cosmo::Unitful.Length: From internal units of length to mathrmkpc.\nx_comoving::Unitful.Length: From internal units of length to mathrmckpc.\nv_cgs::Unitful.Velocity: From internal units of velocity to mathrmcm  s^-1.\nv_cosmo::Unitful.Velocity: From internal units of velocity to mathrmkm  s^-1.\nm_cgs::Unitful.Mass: From internal units of mass to mathrmg.\nm_cosmo::Unitful.Mass: From internal units of mass to mathrmM_odot.\nt_cgs::Unitful.Time: From internal units of time to mathrms.\nt_cosmo::Unitful.Time: From internal units of time to mathrmMyr.\nt_newton::Unitful.Time: From internal units (non-cosmological simulations) of time to mathrmMyr.\nU_cgs::Unitful.Energy: From internal units of specific energy to mathrmerg  g^-1.\nrho_cgs::Unitful.Density: From internal units of density to mathrmg  cm^-3.\nP_Pa::Unitful.Pressure: From internal units of pressure to mathrmPa.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.LinearGrid","page":"Global constants","title":"GalaxyInspector.LinearGrid","text":"Linear grid (1D).\n\nFields\n\ngrid::Vector{<:Number}: Position of (the center of) each bin.\nedges::Vector{<:Number}: Edges of the bins.\nbin_widths::Vector{<:Number}: Widths of the bins.\nlog::Bool: If the grid is logarithmic.\nregular::Bool: If the grid is regular.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.LinearGrid2","page":"Global constants","title":"GalaxyInspector.LinearGrid2","text":"Linear grid (1D).\n\nFields\n\ngrid::Vector{<:Number}: Position of (the center of) each bin.\nedges::Vector{<:Number}: Edges of the bins.\nbin_widths::Vector{<:Number}: Widths of the bins.\nlog::Bool: If the grid is logarithmic.\nregular::Bool: If the grid is regular.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.PlotParams","page":"Global constants","title":"GalaxyInspector.PlotParams","text":"Plotting parameters for a quantity.\n\nFields\n\nrequest::Dict{Symbol,Vector{String}} = Dict{Symbol,Vector{String}}(): Data request for readSnapshot. It must have the shape cell/particle type -> [block name, block name, block name, ...].\nvar_name::AbstractString = \"\": Name of the quantity for the axis label. It should not include units or scaling factors.\nexp_factor::Int = 0: Numerical exponent to scale down the axis, e.g. if exp_factor = 10 the values will be divided by 10^10. The default is no scaling.\nunit::Unitful.Units = Unitful.NoUnits: Target unit for the axis.\naxis_label::AbstractString = \"auto_label\": Label for the axis. It can contain the string auto_label, which will be replaced by the default label: var_name / 10^exp_factor unit.\ncp_type::Union{Symbol,Nothing} = nothing: Cell/particle type corresponding to the quantity. It can be any of the keys of PARTICLE_INDEX.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.Qty","page":"Global constants","title":"GalaxyInspector.Qty","text":"Dimensional information about a physical quantity.\n\nFields\n\nhdf5_name::String: HDF5 block name.\ndimensions::Unitful.Dimensions: Physical dimensions of the quantity, e.g. Unitful.𝐋 * Unitful.𝐓^-1.\nunit::Union{Unitful.Units,Symbol}: Units of the quantity within the simulation code. It can be a unit from Unitful or UnitfulAstro, or it can be the symbol :internal which denotes internal code units.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.Simulation","page":"Global constants","title":"GalaxyInspector.Simulation","text":"Metadata for a simulation.\n\nFields\n\npath::String: Full path to the simulation directory.\nindex::Int: An index associated with the simulation.\nslice::IndexType: Slice of the simulation, i.e. which snapshots will be read. It can be an integer (a single snapshot), a vector of integers (several snapshots), an UnitRange (e.g. 5:13), an StepRange (e.g. 5:2:13) or (:) (all snapshots).\ncosmological::Bool: If the simulation is cosmological,\nfalse -> Newtonian simulation    (ComovingIntegrationOn = 0).\ntrue  -> Cosmological simulation (ComovingIntegrationOn = 1).\nsnapshot_table::DataFrame: A dataframe where each row is a snapshot, and the colums are\n:ids            -> Dataframe index, i.e. if there are 10 snapshots in total it runs from 1 to 10.\n:numbers        -> Number in the file name.\n:scale_factors  -> Scale factor.\n:redshifts      -> Redshift.\n:physical_times -> Physical time since the Big Bang.\n:lookback_times -> Physical time left to reach the last snapshot.\n:snapshot_paths -> Full path to each snapshots.\n:groupcat_paths -> Full path to each group catalog files.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.Snapshot","page":"Global constants","title":"GalaxyInspector.Snapshot","text":"Metadata for a snapshot.\n\nFields\n\npath::String: Full path to the snapshot.\nglobal_index::Int: Index of the snapshot in the context of the whole simulation.\nslice_index::Int: Index of the snapshot in the context of the simulation slice.\nphysical_time::Unitful.Time: Physical time since the Big Bang.\nlookback_time::Unitful.Time: Physical time left to reach the last snapshot.\nscale_factor::Float64: Scale factor.\nredshift::Float64: Redshift.\nheader::SnapshotHeader: Header.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.SnapshotHeader","page":"Global constants","title":"GalaxyInspector.SnapshotHeader","text":"Data in the \"Header\" group of a HDF5 snapshot file.\n\nFields\n\nbox_size::Float64: Total size of the simulation box, in internal units of length.\nh::Float64: Dimensionless Hubble parameter, \"little h\".\nmass_table::Vector{Float64}: Masses of particle/cell types which have a constant mass, in internal units of mass.\nnum_files::Int32: Number of file chunks per snapshot.\nnum_part::Vector{Int32}: Number of particles/cells (of each type) included in this file chunk.\nnum_total::Vector{UInt32}: Total number of particles/cells (of each type) for this snapshot.\nomega_0::Float64: The cosmological density parameter for matter.\nomega_l::Float64: The cosmological density parameter for the cosmological constant.\nredshift::Float64: The redshift.\ntime::Float64: The physical time or the scale factor, depending on the type of simulation.\nl_unit::Unitful.Length: Conversion factor from internal units of length to centimeters.\nm_unit::Unitful.Mass: Conversion factor from internal units of mass to grams.\nv_unit::Unitful.Velocity: Conversion factor from internal units of velocity to centimeters per second.\n\n\n\n\n\n","category":"type"},{"location":"api/constants/globals/#GalaxyInspector.SquareGrid","page":"Global constants","title":"GalaxyInspector.SquareGrid","text":"Square grid (2D).\n\nFields\n\ngrid::Matrix{NTuple{2,<:Number}}: Matrix with the coordinates of (the center of) each bin.\nx_bins::Vector{<:Number}: x coordinates of the bins.\ny_bins::Vector{<:Number}: y coordinates of the bins.\ncenter::Vector{<:Number}: 3D location of the center of the grid. The z axis is taken as the normal vector of the grid.\ngrid_size::Number: Side length of the grid.\nn_bins::Int: Number of bins per side.\nbin_width::Number: Side length of each bin.\nbin_area::Number: Area of each bin.\n\n\n\n\n\n","category":"type"},{"location":"api/auxiliary_functions/plotting/#Plotting-utilities","page":"Plotting utilities","title":"Plotting utilities","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.KSLawBigiel2008-Tuple{Vector{<:Union{Unitful.Quantity{T, 𝐌 𝐋^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-2, U}} where {L, S}} where {T, U}}}","page":"Plotting utilities","title":"GalaxyInspector.KSLawBigiel2008","text":"KSLawBigiel2008(\n    ΣH::Vector{<:SurfaceDensity};\n    <keyword arguments>\n)::Vector{<:Number}\n\nEvaluate the Kennicutt-Schmidt law for the molecular or neutral gas, taken from Bigiel et al. (2008).\n\nFrom Bigiel et al. (2008) (Section 3.1), we have\n\nSigma_mathrmSFR = a left( fracSigma_mathrmHI H_2 gas10  mathrmM_odot  pc^-2 right)^N  \n\nwhere N is the power-law index, and A = log_10(a), where a is Sigma_mathrmSFR at the fiducial gas surface density of 10  mathrmM_odot  pc^-2.\n\nArguments\n\nΣH::Vector{<:SurfaceDensity}: Values of the molecular or neutral gas surface density.\nmolecular::Bool=true: If ΣH is the surface density of molecular hydrogen, or of neutral hydrogen.\nlog_output::Bool=true: If the output will the log_10  Sigma_textSFR, or Sigma_textSFR. If log_output = true, the implied units are mathrmM_odot  yr^-1  kpc^-2\n\nReturns\n\nThe SFR surface density.\n\nReferences\n\nF. Bigiel et al. (2008). THE STAR FORMATION LAW IN NEARBY GALAXIES ON SUB-KPC SCALES. The Astrophysical Journal, 136(6), 2846. doi:10.1088/0004-6256/136/6/2846\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.KSLawKennicutt1998-Tuple{Vector{<:Union{Unitful.Quantity{T, 𝐌 𝐋^-2, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-2, U}} where {L, S}} where {T, U}}}","page":"Plotting utilities","title":"GalaxyInspector.KSLawKennicutt1998","text":"KSLawKennicutt1998(Σgas::Vector{<:SurfaceDensity}; <keyword arguments>)::Vector{<:Number}\n\nEvaluate the Kennicutt-Schmidt law, taken from Kennicutt (1998).\n\nFrom Kennicutt (1998) (Section 4, Eq. 4), we have\n\nSigma_mathrmSFR = a left( fracSigma_mathrmgas1  mathrmM_odot  pc^-2 right)^N mathrmM_odot  yr^-1  kpc^-2  \n\nwhere N is the power-law index and a is Sigma_mathrmSFR at the fiducial gas surface density of 1  mathrmM_odot  pc^-2.\n\nArguments\n\nΣgas::Vector{<:SurfaceDensity}: Values of the gas mass surface density.\nlog_output::Bool=true: If the output will the log_10  Sigma_textSFR, or Sigma_textSFR. If log_output = true, the implied units are mathrmM_odot  yr^-1  kpc^-2\n\nReturns\n\nThe SFR surface density.\n\nReferences\n\nR. C. Kennicutt (1998). The Global Schmidt Law in Star-forming Galaxies. The Astrophysical Journal, 498(2), 541-552. doi:10.1086/305588\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.absCoor-Tuple{Union{Makie.Axis, Makie.Figure, Makie.FigureAxisPlot}, Real, Real}","page":"Plotting utilities","title":"GalaxyInspector.absCoor","text":"absCoor(\n    plot::Union{Makie.FigureAxisPlot,Makie.Axis,Makie.Figure},\n    r_x::Real,\n    r_y::Real,\n)::NTuple{2,Float64}\n\nCompute the absolute x and y coordinates of a plot, from the relative ones.\n\nArguments\n\nplot::Union{Makie.FigureAxisPlot,Makie.Axis,Makie.Figure}: Plot, axis, or figure for which the absolute coordinates will be calculated. In the case of a figure, it will use the limits from the current axis object.\nr_x::Real: Relative x coordinate.\nr_y::Real: Relative y coordinate.\n\nReturns\n\nA tuple with the absolute coordinates, (x, y).\n\nExamples\n\njulia> absCoor(lines(rand(100)), 0.5, 0.5)\n(50.50000071525574, 0.48792968317866325)\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.barPlotLabelFormater-Tuple{LaTeXStrings.LaTeXString}","page":"Plotting utilities","title":"GalaxyInspector.barPlotLabelFormater","text":"barPlotLabelFormater(x::LaTeXString)::LaTeXString\n\nFormat a number to be a barplot label.\n\nMethod for compatibility with the barplot! function of Makie.\n\nArguments\n\nx::Number: Value to be formatted.\n\nReturns\n\nThe bar label.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.barPlotLabelFormater-Tuple{Number}","page":"Plotting utilities","title":"GalaxyInspector.barPlotLabelFormater","text":"barPlotLabelFormater(x::Number)::LaTeXString\n\nFormat a number to be a barplot label.\n\nFor values between 0 and 0.01 the label will be \"< 0.01\", otherwise it will be the value itself with 2 digits.\n\nArguments\n\nx::Number: Value to be formatted.\n\nReturns\n\nThe bar label.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.cleanPlot!-Tuple{Any}","page":"Plotting utilities","title":"GalaxyInspector.cleanPlot!","text":"Default function to end cleanPlot! recursion if an unknown type is encountered.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.cleanPlot!-Tuple{Makie.Axis}","page":"Plotting utilities","title":"GalaxyInspector.cleanPlot!","text":"cleanPlot!(ax::Makie.Axis)::Bool\n\nEmpty an axis.\n\nArguments\n\nax::Makie.Axis: Axis to be emptied.\n\nReturns\n\nFlag to indicate that an axis has been emptied.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.cleanPlot!-Tuple{Makie.Figure}","page":"Plotting utilities","title":"GalaxyInspector.cleanPlot!","text":"cleanPlot!(figure::Makie.Figure)::Nothing\n\nDelete all the legends of a figure and empty all its axes.\n\nArguments\n\nfigure::Makie.Figure: Figure to be cleaned.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.cleanPlot!-Tuple{Union{Makie.Colorbar, Makie.Legend}}","page":"Plotting utilities","title":"GalaxyInspector.cleanPlot!","text":"cleanPlot!(legend::Union{Makie.Legend,Makie.Colorbar})::Bool\n\nDelete a legend or colorbar.\n\nArguments\n\nlegend::Union{Makie.Legend,Makie.Colorbar}: Legend or colorbar to be deleted.\n\nReturns\n\nFlag to indicate that a legend or colorbar has been deleted.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.derivedQtyPlotParams-Tuple{Symbol, Symbol}","page":"Plotting utilities","title":"GalaxyInspector.derivedQtyPlotParams","text":"derivedQtyPlotParams(magnitude::Symbol, component::Symbol)::PlotParams\n\nReturn the plotting parameters for a given magnitude of component.\n\nArguments\n\nmagnitude::Symbol: One of the physical magnitudes in MAGNITUDES.\ncomponent::Symbol: One of the physical components in COMPONENTS.\n\nReturns\n\nA PlotParams object.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.derivedSFMQtyPlotParams-Tuple{Symbol}","page":"Plotting utilities","title":"GalaxyInspector.derivedSFMQtyPlotParams","text":"derivedSFMQtyPlotParams(quantity::Symbol)::PlotParams\n\nReturn the plotting parameters for a given derived code quantity of our SF model.\n\nArguments\n\nquantity::Symbol: One of the quantities in SFM_DERIVED_QTY.\n\nReturns\n\nA PlotParams object.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.formatError-Tuple{Number, Number}","page":"Plotting utilities","title":"GalaxyInspector.formatError","text":"formatError(q_mean::Number, q_error::Number)::NTuple{2,<:Number}\n\nNicely format a magnitude with uncertainty.\n\nIt follows the traditional rules for error presentation: the error has only one significant digit, unless such digit is a one, in which case two significant digits are used. The mean will have as many digits as to match the last significant position of the error. An error equal to 0 will leave the mean unchanged.\n\nArguments\n\nq_mean::Number: Mean value.\nq_error::Number: Error value. It must be positive.\n\nReturns\n\nA tuple with the formatted mean and error values.\n\nExamples\n\njulia> formatError(69.42069, 0.038796)\n(69.42, 0.04)\n\njulia> formatError(69.42069, 0.018796)\n(69.421, 0.019)\n\njulia> formatError(15.42, 0.00004)\n(15.42, 4.0e-5)\n\njulia> formatError(69.42069, 0.0)\n(69.42069, 0.0)\n\njulia> formatError(69.42069, 93.4)\n(70.0, 90.0)\n\njulia> formatError(69.42069, 123.4)\n(70.0, 120.0)\n\njulia> formatError(15.42069, 16.4)\n(15.0, 16.0)\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.getLabel-Tuple{AbstractString, Int64, Unitful.Units}","page":"Plotting utilities","title":"GalaxyInspector.getLabel","text":"getLabel(\n    label::AbstractString,\n    factor::Int,\n    unit::Unitful.Units;\n    <keyword arguments>\n)::AbstractString\n\nConstruct an axis label.\n\nArguments\n\nlabel::AbstractString: Variable name.\nfactor::Int: Exponential factor to scale down the units. If different from 0, a term of the form 10^factor will be added to the label.\nunit::Unitful.Units: Unit of the axis.\nlatex::Bool=true: If the output will be a LaTeXString or a plain String.\n\nReturns\n\nThe LaTeXString or String: \"label [10^factor unit]\". If label is \"\", an empty string is returned. The factor term only appears if factor != 0, the unit term only appears if unit != Unitful.NoUnits, and the brackets only appears if there are a factor and/or a unit term.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.getUnitLabel-Tuple{Int64, Unitful.Units}","page":"Plotting utilities","title":"GalaxyInspector.getUnitLabel","text":"getUnitLabel(factor::Int, unit::Unitful.Units; <keyword arguments>)::AbstractString\n\nConstruct the unit part of an axis label.\n\nArguments\n\nfactor::Int: Exponential factor to scale down the units. If different from 0, a term of the form 10^factor will be added to the label.\nunit::Unitful.Units: Unit of the axis.\nlatex::Bool=true: If the output will be a LaTeXString or a plain String.\n\nReturns\n\nThe LaTeXString or String: \"10^factor unit\". The factor term only appears if factor != 0, the unit term only appears if unit != Unitful.NoUnits.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.haloQtyPlotParams-Tuple{Symbol}","page":"Plotting utilities","title":"GalaxyInspector.haloQtyPlotParams","text":"haloQtyPlotParams(quantity::Symbol)::PlotParams\n\nReturn the plotting parameters for a given halo magnitude.\n\nArguments\n\nquantity::Symbol: Target halo and halo quantity, e.g., :halo_mass_12. The index of the target halo starts at 1 and the halo quantity has to be one of the keys of HALO_KEYS.\n\nReturns\n\nA PlotParams object.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.invKSLawBigiel2008-Tuple{Vector{<:Union{Unitful.Quantity{T, 𝐌 𝐋^-2 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-2 𝐓^-1, U}} where {L, S}} where {T, U}}}","page":"Plotting utilities","title":"GalaxyInspector.invKSLawBigiel2008","text":"invKSLawBigiel2008(\n    Σsfr ::Vector{<:MassFlowDensity};\n    <keyword arguments>\n)::Vector{<:Number}\n\nEvaluate the inverse Kennicutt-Schmidt law for the molecular or neutral gas, taken from Bigiel et al. (2008).\n\nFrom Bigiel et al. (2008) (Section 3.1, Eq. 2), we have\n\nSigma_mathrmSFR = a left( fracSigma_mathrmHI H_2 gas10  mathrmM_odot  pc^-2 right)^N  \n\nwhere N is the power-law index, and A = log_10(a), where a is Sigma_mathrmSFR at the fiducial gas surface density of 10  mathrmM_odot  pc^-2.\n\nArguments\n\nΣsfr ::Vector{<:MassFlowDensity}: Values of the SFR surface density.\nmolecular::Bool=true: If the output will be the surface density of molecular hydrogen, or of neutral hydrogen.\nlog_output::Bool=true: If the output will the log_10  Sigma_textH, or Sigma_textH. If log_output = true, the implied units are 10  mathrmM_odot  pc^-2\n\nReturns\n\nThe molecular or neutral gas surface density.\n\nReferences\n\nF. Bigiel et al. (2008). THE STAR FORMATION LAW IN NEARBY GALAXIES ON SUB-KPC SCALES. The Astrophysical Journal, 136(6), 2846. doi:10.1088/0004-6256/136/6/2846\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.invKSLawKennicutt1998-Tuple{Vector{<:Union{Unitful.Quantity{T, 𝐌 𝐋^-2 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-2 𝐓^-1, U}} where {L, S}} where {T, U}}}","page":"Plotting utilities","title":"GalaxyInspector.invKSLawKennicutt1998","text":"invKSLawKennicutt1998(\n    Σsfr::Vector{<:MassFlowDensity};\n    <keyword arguments>\n)::Vector{<:Number}\n\nEvaluate the inverse Kennicutt-Schmidt law, taken from Kennicutt (1998).\n\nFrom Kennicutt (1998) (Section 4, Eq. 4), we have\n\nSigma_mathrmSFR = a left( fracSigma_mathrmgas1  mathrmM_odot  pc^-2 right)^N mathrmM_odot  yr^-1  kpc^-2  \n\nwhere N is the power-law index and a is Sigma_mathrmSFR at the fiducial gas surface density of 1  mathrmM_odot  pc^-2.\n\nArguments\n\nΣsfr::Vector{<:MassFlowDensity}: Values of the SFR surface density..\nlog_output::Bool=true: If the output will the log_10  Sigma_textgas, or Sigma_textgas. If log_output = true, the implied units are mathrmM_odot  pc^-2\n\nReturns\n\nThe gas mass surface density.\n\nReferences\n\nR. C. Kennicutt (1998). The Global Schmidt Law in Star-forming Galaxies. The Astrophysical Journal, 498(2), 541-552. doi:10.1086/305588\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.plotParams-Tuple{Symbol}","page":"Plotting utilities","title":"GalaxyInspector.plotParams","text":"plotParams(quantity::Symbol)::PlotParams\n\nReturn the plotting parameters for a given quantity.\n\nArguments\n\nquantity::Symbol: Target quantity. Some of the options are the quantities in DERIVED_QTY, MAGNITUDES, SFM_QTY, GAS_ABUNDANCE, and STELLAR_ABUNDANCE.\n\nReturns\n\nA PlotParams object.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.pointData-Tuple{Makie.Axis}","page":"Plotting utilities","title":"GalaxyInspector.pointData","text":"Extract all the data points in a Makie plot, axis, or figure. In the case of a figure, it will only take the data from the current axis object. It only works for scatter, line, and scatterline plots.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.reduceTicks-Tuple{Vector{<:Number}, Int64}","page":"Plotting utilities","title":"GalaxyInspector.reduceTicks","text":"reduceTicks(hr_ticks::Vector{<:Number}, factor::Int)::Vector{<:Number}\n\nReduce the length of a given list of axis ticks, while keeping the total length of the axis the same.\n\nArguments\n\nhr_ticks::Vector{<:Number}: Original \"high resolution\" list of ticks. It has to be regularly spaced\nfactor::Int: Factor by which the number of values will be reduced. It has to divide the size of hr_ticks exactly.\n\nReturns\n\nThe new shorter list of ticks.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.sfmQtyPlotParams-Tuple{Symbol}","page":"Plotting utilities","title":"GalaxyInspector.sfmQtyPlotParams","text":"sfmQtyPlotParams(quantity::Symbol)::PlotParams\n\nReturn the plotting parameters for a given base code quantity of our SF model.\n\nArguments\n\nquantity::Symbol: One of the quantities in SFM_QTY.\n\nReturns\n\nA PlotParams object.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.validatePlotData-Tuple{Function, Vararg{VecOrMat{<:Number}}}","page":"Plotting utilities","title":"GalaxyInspector.validatePlotData","text":"validatePlotData(\n    plot_function::Function,\n    plot_data::VecOrMat{<:Number}...;\n    <keyword arguments>\n)::Tuple{Vector{<:VecOrMat{<:Number}},Bool,Bool}\n\nAdapt plot_data to be plotted with plot_function.\n\nThis function strips the units of every argument in plot_data, and it may trims down the first two arguments in plot_data.\n\nArguments\n\nplot_function::Function: Target plotting function from Makie. The supported functions are:\nscatter!      -> Scatter plot.\nlines!        -> Line plot.\nscatterlines! -> Scatter plot with lines between the markers.\nhist!         -> Histogram.\nheatmap!      -> Heatmap.\narrows2d!     -> 2D vector field.\nbarplot!      -> Bar plots.\nband!         -> Band plots.\nerrorbars!    -> Error bars.\nplot_data::VecOrMat{<:Number}: Raw plot data.\nx_unit::Unitful.Units=Unitful.NoUnits: Target unit for the x axis data (first arguments in plot_data). The values will be converted accordingly. Use the default value of Unitful.NoUnits for dimensionless quantities.\ny_unit::Unitful.Units=Unitful.NoUnits: Target unit for the y axis data (second arguments in plot_data). The values will be converted accordingly. Use the default value of Unitful.NoUnits for dimensionless quantities.\nx_exp_factor::Int=0: Numerical exponent to scale down the x axis data (first arguments in plot_data), e.g. if x_exp_factor = 10 the values will be divided by 10^10. The default is no scaling.\ny_exp_factor::Int=0: Numerical exponent to scale down the y axis data (second arguments in plot_data), e.g. if y_exp_factor = 10 the values will be divided by 10^10. The default is no scaling.\nx_trim::NTuple{2,<:Real}=(-Inf, Inf): The data (first arguments in plot_data) will be trim down so the x coordinates fit within x_trim, in the units given by x_unit.\ny_trim::NTuple{2,<:Real}=(-Inf, Inf): The data (second arguments in plot_data) will be trim down so the y coordinates fit within y_trim, in the units given by y_unit. This option does not affect histograms.\nx_edges::Bool=false: Set it to true if you want to keep the borders of x_trim.\ny_edges::Bool=false: Set it to true if you want to keep the borders of y_trim.\nx_scale_func::Function=identity: Scaling function for the x axis (first arguments in plot_data). The options are the scaling functions accepted by Makie: log10, log2, log, sqrt, Makie.logit, Makie.Symlog10, Makie.pseudolog10, and identity. The data will be trimmed down to fit within the domain of x_scale_func.\ny_scale_func::Function=identity: Scaling function for the y axis (second arguments in plot_data). The options are the scaling functions accepted by Makie: log10, log2, log, sqrt, Makie.logit, Makie.Symlog10, Makie.pseudolog10, and identity. The data will be trimmed down to fit within the domain of y_scale_func.\n\nReturns\n\nA tuple with three elements:\nA vector with the elements of plot_data ready to be plotted by plot_function.\nIf plot_data[1] was mutated to fit within the domain of x_scale_func.\nIf plot_data[2] was mutated to fit within the domain of y_scale_func (only relevant if length(plot_data) > 1).\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.xlimits!-Tuple{Makie.Axis}","page":"Plotting utilities","title":"GalaxyInspector.xlimits!","text":"Extract the limits of the x axis, from a Makie plot, axis, or figure. In the case of a figure, it will take the limits from the current axis object.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.xscale-Tuple{Makie.Axis}","page":"Plotting utilities","title":"GalaxyInspector.xscale","text":"Extract the scale function of the x axis, from a Makie plot, axis, or figure. In the case of a figure, it will take the scale from the current axis object.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.ylimits!-Tuple{Makie.Axis}","page":"Plotting utilities","title":"GalaxyInspector.ylimits!","text":"Extract the limits of the y axis, from a Makie plot, axis, or figure. In the case of a figure, it will take the limits from the current axis object.\n\n\n\n\n\n","category":"method"},{"location":"api/auxiliary_functions/plotting/#GalaxyInspector.yscale-Tuple{Makie.Axis}","page":"Plotting utilities","title":"GalaxyInspector.yscale","text":"Extract the scale function of the y axis, from a Makie plot, axis, or figure. In the case of a figure, it will take the scale from the current axis object.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#Computation-of-characteristic-velocities-and-momentums","page":"Computation of characteristic velocities and momentums","title":"Computation of characteristic velocities and momentums","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeAngularMomentum-Tuple{Dict, Symbol}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeAngularMomentum","text":"computeAngularMomentum(\n    data_dict::Dict,\n    component::Symbol,\n)::Vector{<:AngularMomentum}\n\nCompute the angular momentum in the z direction with respect to the origin, for each cell/particle of the given component.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present for the cell/particle type corresponding to component:\ncell/particle type => [\"POS \", \"VEL \", \"MASS\"].\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nThe angular momentum of each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeAngularMomentum-Tuple{Matrix{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Matrix{<:Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeAngularMomentum","text":"computeAngularMomentum(\n    positions::Matrix{<:Unitful.Length},\n    velocities::Matrix{<:Unitful.Velocity},\n    masses::Vector{<:Unitful.Mass},\n)::Vector{<:AngularMomentum}\n\nCompute the angular momentum in the z direction with respect to the origin.\n\nArguments\n\npositions::Matrix{<:Unitful.Length}: Positions of the cells/particles. Each column is a cell/particle and each row a dimension.\nvelocities::Matrix{<:Unitful.Velocity}: Velocities of the cells/particles. Each column is a cell/particle and each row a dimension.\nmasses::Vector{<:Unitful.Mass}: Mass of every cell/particle.\n\nReturns\n\nThe angular momentum in the z direction of each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeCircularity-Tuple{Dict, Symbol}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeCircularity","text":"computeCircularity(data_dict::Dict, component::Symbol)::Vector{Float64}\n\nCompute the circularity of each cell/particle, with respect to the origin and the z direction.\n\nThe circularity of a cell/particle is,\n\nepsilon = j_z  j_mathrmcirc  \n\nwhere j_z is the z component of its specific angular momentum, and j_mathrmcirc is the specific angular momentum of a circular orbit,\n\nj_mathrmcirc = r  v_mathrmcirc = sqrtmathrmG  r  M(r)  \n\nwhere r is the radial distance of the particle, and M(r) is the total mass within a sphere of radius r.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present for every cell/particle that you want to be taken into account:\ncell/particle type => [\"VEL \", \"POS \", \"MASS\"].\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nThe circularity of each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeCircularity-Tuple{Vector{<:Union{Unitful.Quantity{T, 𝐋^2 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋^2 𝐓^-1, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeCircularity","text":"computeCircularity(\n    jzs::Vector{<:Unitful.KinematicViscosity},\n    rs::Vector{<:Unitful.Length},\n    vcircs::Vector{<:Unitful.Velocity},\n)::Vector{Float64}\n\nCompute the circularity with respect to the origin and the z direction.\n\nThe circularity of a cell/particle is,\n\nepsilon = j_z  j_mathrmcirc  \n\nwhere j_z is the z component of its specific angular momentum, and j_mathrmcirc is the specific angular momentum of a circular orbit,\n\nj_mathrmcirc = r  v_mathrmcirc = sqrtmathrmG  r  M(r)  \n\nwhere r is the radial distance of the particle, and M(r) is the total mass within a sphere of radius r.\n\nArguments\n\njzs::Vector{<:Unitful.KinematicViscosity}: Specific angular momentum in the z direction of each cell/particle.\nrs::Vector{<:Unitful.Length}: Radial distances of each cell/particle to the origin.\nvcircs::Vector{<:Unitful.Velocity}: Circular velocity of each cell/particle.\n\nReturns\n\nThe circularity of each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeGlobalAngularMomentum-Tuple{Dict}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeGlobalAngularMomentum","text":"computeGlobalAngularMomentum(data_dict::Dict; <keyword arguments>)::Vector{<:Number}\n\nCompute the total angular momentum of the system, with respect to the origin\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present for every cell/particle that you want to be taken into account:\ncell/particle type => [\"POS \", \"VEL \", \"MASS\"].\nnormal::Bool=true: If the result will be normalized.\n\nReturns\n\nThe angular momentum.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeGlobalSpinParameter-Tuple{Dict}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeGlobalSpinParameter","text":"computeGlobalSpinParameter(data_dict::Dict; <keyword arguments>)::Float64\n\nCompute the spin parameter of the whole system.\n\nThe spin parameter was originally defined by Peebles (1969) as,\n\nlambda = fracJ  sqrtEG  M^52  \n\nwhere J is the norm of the total angular momentum, M the total mass, G the gravitational constant, and\n\nE = E_P + E_k  \n\nwhere E_P is the total potential energy and E_k is the total kinetic energy (including thermal energy of the gas).\n\nDue to the computational complexity of calculating E_P for a large group of particles, Bullock et al. (2001) proposed an alternative definition of the spin parameter,\n\nlambda = fracJsqrt2  M  R  V  \n\nwhere J is the norm of the total angular momentum inside a sphere of radius R containing mass M, and\n\nV = sqrtfracG  MR  \n\nis the circular velocity.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present for every cell/particle that you want to be taken into account:\ncell/particle type => [\"POS \", \"VEL \", \"MASS\"].\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\nR::Unitful.Length=DISK_R: Characteristic radius.\n\nReturns\n\nThe spin parameter of the cell/particles within radius R.\n\nReferences\n\nP. J. E. Peebles (1969). Origin of the Angular Momentum of Galaxies. Astrophysical Journal, 155, 393. doi:10.1086/149876\n\nJ. S. Bullock et al. (2001). A Universal Angular Momentum Profile for Galactic Halos. The Astrophysical Journal, 555(1), 240. doi:10.1086/321477\n\nJ. Zjupa et al. (2017). Angular momentum properties of haloes and their baryon content in the Illustris simulation. Monthly Notices of the Royal Astronomical Society, 466(2), 1625–1647. doi:10.1093/mnras/stw2945\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeSpecificAngularMomentum-Tuple{Dict, Symbol}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeSpecificAngularMomentum","text":"computeSpecificAngularMomentum(\n    data_dict::Dict,\n    component::Symbol,\n)::Vector{<:Unitful.KinematicViscosity}\n\nCompute the specific angular momentum in the z direction with respect to the origin, for each cell/particle of the given component.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present for the cell/particle type corresponding to component:\ncell/particle type => [\"POS \", \"VEL \"].\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nThe specific angular momentum of each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeSpecificAngularMomentum-Tuple{Matrix{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Matrix{<:Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeSpecificAngularMomentum","text":"computeSpecificAngularMomentum(\n    positions::Matrix{<:Unitful.Length},\n    velocities::Matrix{<:Unitful.Velocity},\n)::Vector{<:Unitful.KinematicViscosity}\n\nCompute the specific angular momentum in the z direction with respect to the origin.\n\nArguments\n\npositions::Matrix{<:Unitful.Length}: Positions of the cells/particles. Each column is a cell/particle and each row a dimension.\nvelocities::Matrix{<:Unitful.Velocity}: Velocities of the cells/particles. Each column is a cell/particle and each row a dimension.\n\nReturns\n\nThe specific angular momentum in the z direction of each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeSpinParameter-Tuple{Dict, Symbol}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeSpinParameter","text":"computeSpinParameter(data_dict::Dict, component::Symbol; <keyword arguments>)::Float64\n\nCompute the spin parameter of the given component, with respect to the origin\n\nThe spin parameter was originally defined by Peebles (1969) as,\n\nlambda = fracJ  sqrtEG  M^52  \n\nwhere J is the norm of the total angular momentum, M the total mass, G the gravitational constant, and\n\nE = E_P + E_k  \n\nwhere E_P is the total potential energy and E_k is the total kinetic energy (including thermal energy of the gas).\n\nDue to the computational complexity of calculating E_P for a large group of particles, Bullock et al. (2001) proposed an alternative definition of the spin parameter,\n\nlambda = fracJsqrt2  M  R  V  \n\nwhere J is the norm of the total angular momentum inside a sphere of radius R containing mass M, and\n\nV = sqrtfracG  MR  \n\nis the circular velocity.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present for the cell/particle type corresponding to component:\ncell/particle type => [\"POS \", \"VEL \", \"MASS\"].\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\nR::Unitful.Length=DISK_R: Characteristic radius.\n\nReturns\n\nThe spin parameter of the cell/particles within radius R.\n\nReferences\n\nP. J. E. Peebles (1969). Origin of the Angular Momentum of Galaxies. Astrophysical Journal, 155, 393. doi:10.1086/149876\n\nJ. S. Bullock et al. (2001). A Universal Angular Momentum Profile for Galactic Halos. The Astrophysical Journal, 555(1), 240. doi:10.1086/321477\n\nJ. Zjupa et al. (2017). Angular momentum properties of haloes and their baryon content in the Illustris simulation. Monthly Notices of the Royal Astronomical Society, 466(2), 1625–1647. doi:10.1093/mnras/stw2945\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeSpinParameter-Tuple{Matrix{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Matrix{<:Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeSpinParameter","text":"computeSpinParameter(\n    positions::Matrix{<:Unitful.Length},\n    velocities::Matrix{<:Unitful.Velocity},\n    masses::Vector{<:Unitful.Mass};\n    <keyword arguments>\n)::Float64\n\nCompute the spin parameter with respect to the origin.\n\nThe spin parameter was originally defined by Peebles (1969) as,\n\nlambda = fracJ  sqrtEG  M^52  \n\nwhere J is the norm of the total angular momentum, M the total mass, G the gravitational constant, and\n\nE = E_P + E_k  \n\nwhere E_P is the total potential energy and E_k is the total kinetic energy (including thermal energy of the gas).\n\nDue to the computational complexity of calculating E_P for a large group of particles, Bullock et al. (2001) proposed an alternative definition of the spin parameter,\n\nlambda = fracJsqrt2  M  R  V  \n\nwhere J is the norm of the total angular momentum inside a sphere of radius R containing mass M, and\n\nV = sqrtfracG  MR  \n\nis the circular velocity.\n\nArguments\n\npositions::Matrix{<:Unitful.Length}: Positions of the cells/particles. Each column is a cell/particle and each row a dimension.\nvelocities::Matrix{<:Unitful.Velocity}: Velocities of the cells/particles. Each column is a cell/particle and each row a dimension.\nmasses::Vector{<:Unitful.Mass}: Mass of every cell/particle.\nR::Unitful.Length=DISK_R: Characteristic radius.\n\nReturns\n\nThe spin parameter of the cell/particles within radius R.\n\nReferences\n\nP. J. E. Peebles (1969). Origin of the Angular Momentum of Galaxies. Astrophysical Journal, 155, 393. doi:10.1086/149876\n\nJ. S. Bullock et al. (2001). A Universal Angular Momentum Profile for Galactic Halos. The Astrophysical Journal, 555(1), 240. doi:10.1086/321477\n\nJ. Zjupa et al. (2017). Angular momentum properties of haloes and their baryon content in the Illustris simulation. Monthly Notices of the Royal Astronomical Society, 466(2), 1625–1647. doi:10.1093/mnras/stw2945\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeTotalAngularMomentum-Tuple{Matrix{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Matrix{<:Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeTotalAngularMomentum","text":"computeTotalAngularMomentum(\n    positions::Matrix{<:Unitful.Length},\n    velocities::Matrix{<:Unitful.Velocity},\n    masses::Vector{<:Unitful.Mass};\n    <keyword arguments>\n)::Vector{<:Number}\n\nCompute the total angular momentum vector with respect to the origin.\n\nArguments\n\npositions::Matrix{<:Unitful.Length}: Positions of the cells/particles. Each column is a cell/particle and each row a dimension.\nvelocities::Matrix{<:Unitful.Velocity}: Velocities of the cells/particles. Each column is a cell/particle and each row a dimension.\nmasses::Vector{<:Unitful.Mass}: Mass of every cell/particle.\nnormal::Bool=true: If the result will be normalized.\n\nReturns\n\nThe total angular momentum vector.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeVcirc-Tuple{Dict, Symbol}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeVcirc","text":"computeVcirc(\n    data_dict::Dict,\n    component::Symbol,\n)::Tuple{Vector{<:Unitful.Length},Vector{<:Unitful.Velocity}}\n\nCompute the circular velocity of each cell/particle of the given component, with respect to the origin.\n\nThe circular velocity of a cell/particle is,\n\nv_mathrmcirc = sqrtfracmathrmG  M(r)r  \n\nwhere r is the radial distance of the cell/particle, and M(r) is the total mass within a sphere of radius r.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present for every cell/particle that you want to be taken into account:\ncell/particle type => [\"POS \", \"MASS\"].\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nA tuple with two elements:\nA vector with the radial distance of the target cells/particles to the origin.\nA vector with the circular velocity of the target cells/particles.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeVcirc-Tuple{Vector{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeVcirc","text":"computeVcirc(\n    distances::Vector{<:Unitful.Length},\n    masses::Vector{<:Unitful.Mass},\n    rs::Vector{<:Unitful.Length},\n)::Tuple{Vector{<:Unitful.Length},Vector{<:Unitful.Velocity}}\n\nCompute the circular velocity.\n\nThe circular velocity of a cell/particle is,\n\nv_mathrmcirc = sqrtfracmathrmG  M(r)r  \n\nwhere r is the radial distance of the cell/particle, and M(r) is the total mass within a sphere of radius r.\n\nArguments\n\ndistances::Vector{<:Unitful.Length}: Radial distances of all the cells/particles in the system.\nmasses::Vector{<:Unitful.Mass}: Mass of every cell/particle in the system.\nrs::Vector{<:Unitful.Length}: Radial distances of the target cells/particles.\n\nReturns\n\nA tuple with two elements:\nA vector with the radial distance of the target cells/particles to the origin.\nA vector with the circular velocity of the target cells/particles.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeVcm-Tuple{Dict, Int64, Int64}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeVcm","text":"computeVcm(\n    data_dict::Dict,\n    halo_idx::Int,\n    subhalo_rel_idx::Int,\n)::Vector{<:Unitful.Velocity}\n\nReturn the velocity of the center of mass of a given halo or subhalo.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present:\n:group   => [\"G_Nsubs\", \"G_Vel\"]\n:subhalo => [\"S_Vel\"]\nhalo_idx::Int: Index of the target halo (FoF group). Starts at 1.\nsubhalo_rel_idx::Int: Index of the target subhalo (subfind), relative to the target halo. Starts at 1. If set to 0, the halo potential minimum is returned.\n\nReturns\n\nThe velocity of the center of mass.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeVcm-Tuple{Dict, Int64}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeVcm","text":"computeVcm(data_dict::Dict, subhalo_abs_idx::Int)::Vector{<:Unitful.Velocity}\n\nReturn the velocity of the center of mass of a given subhalo.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present:\n:subhalo => [\"S_Vel\"]\nsubhalo_abs_idx::Int: Absolute index of the target subhalo (subfind). Starts at 1.\n\nReturns\n\nThe velocity of the center of mass.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeVcm-Tuple{Dict, Symbol}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeVcm","text":"computeVcm(data_dict::Dict, cm_type::Symbol)::Vector{<:Unitful.Velocity}\n\nCompute a characteristic velocity for the system.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of cm_type:\nIf cm_type == :all:\n[\"VEL \", \"MASS\"] for every cell/particle type in the snapshot.\nIf haskey(PARTICLE_INDEX, cm_type):\ncm_type => [\"VEL \", \"MASS\"].\nIf cm_type == :zero:\nNo blocks are required\ncm_type::Symbol: It can be:\n:all         -> Velocity of the center of mass of the whole system.\n:{component} -> Velocity of the center of mass of the given component (e.g. :stellar, :gas, :darkmatter, etc). It can be any of the keys of [`PARTICLEINDEX`](@ref).\n:zero        -> 0 velocity.\n\nReturns\n\nThe velocity.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeVcm-Tuple{Matrix{<:Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeVcm","text":"computeVcm(\n    velocities::Matrix{<:Unitful.Velocity},\n    masses::Vector{<:Unitful.Mass},\n)::Vector{<:Unitful.Velocity}\n\nCompute the velocity of the center of mass.\n\nArguments\n\nvelocities::Matrix{<:Unitful.Velocity}: Velocities of the cells/particles. Each column is a cell/particle and each row a dimension.\nmasses::Vector{<:Unitful.Mass}: Mass of every cell/particle.\n\nReturns\n\nThe velocity of the center of mass of the cells/particles.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeVpolar-Tuple{Dict, Symbol, Symbol}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeVpolar","text":"computeVpolar(\n    data_dict::Dict,\n    component::Symbol,\n    vel_type::Symbol,\n)::Vector{<:Unitful.Velocity}\n\nCompute the cylindrical components of the velocity, mathbfvecv = v_r  mathbfe_r + v_theta  mathbfe_theta + v_z  mathbfe_z, for each cell/particle of the given component.\n\nThe speed in the radial direction expressed in Cartesian coordinates is\n\nv_r = fracx  v_x + y  v_ysqrt(x^2 + y^2)  \n\nin the tangential direction is\n\nv_tau = fracx  v_y - y  v_xsqrt(x^2 + y^2)  \n\nand the speed in the z direction will be computes as\n\nv^*_z = v_z  mathrmsign(z)  \n\nin order to distinguish between inflows (v^*_z  0) and outflows (v^*_z  0).\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present for the cell/particle type corresponding to component:\ncell/particle type => [\"POS \", \"VEL \"].\nvel_type::Symbol: Which velocity will be calculated. The options are:\n:radial     -> Stellar radial speed (v_r).\n:tangential -> Stellar tangential speed (v_theta).\n:zstar      -> Stellar speed in the z direction, computed as v_z  mathrmsign(z).\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nThe chosen cylindrical velocity.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/velocities/#GalaxyInspector.computeVpolar-Tuple{Matrix{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Matrix{<:Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}, Symbol}","page":"Computation of characteristic velocities and momentums","title":"GalaxyInspector.computeVpolar","text":"computeVpolar(\n    positions::Matrix{<:Unitful.Length},\n    velocities::Matrix{<:Unitful.Velocity},\n    vel_type::Symbol,\n)::Vector{<:Unitful.Velocity}\n\nCompute the cylindrical components of the velocity, mathbfvecv = v_r  mathbfe_r + v_theta  mathbfe_theta + v_z  mathbfe_z.\n\nThe speed in the radial direction expressed in Cartesian coordinates is\n\nv_r = fracx  v_x + y  v_ysqrt(x^2 + y^2)  \n\nin the tangential direction is\n\nv_tau = fracx  v_y - y  v_xsqrt(x^2 + y^2)  \n\nand the speed in the z direction will be computes as\n\nv^*_z = v_z  mathrmsign(z)  \n\nin order to distinguish between inflows (v^*_z  0) and outflows (v^*_z  0).\n\nArguments\n\npositions::Matrix{<:Unitful.Length}: Positions of the cells/particles. Each column is a cell/particle and each row a dimension.\nvelocities::Matrix{<:Unitful.Velocity}: Velocities of the cells/particles. Each column is a cell/particle and each row a dimension.\nvel_type::Symbol: Which velocity will be calculated. The options are:\n:radial     -> Radial speed (v_r).\n:tangential -> Tangential speed (v_theta).\n:zstar      -> Speed in the z direction, computed as v_z  mathrmsign(z).\n\nReturns\n\nThe chosen cylindrical velocity of each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/transformations/#Coordinate-transformation-functions","page":"Coordinate transformation functions","title":"Coordinate transformation functions","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/analysis/transformations/#GalaxyInspector.computeRotation-Tuple{Dict, Symbol, Symbol, Function}","page":"Coordinate transformation functions","title":"GalaxyInspector.computeRotation","text":"computeRotation(\n    data_dict::Dict,\n    z_axis::Symbol,\n    component::Symbol,\n    filter_function::Function,\n)::Union{Matrix{Float64},UniformScaling{Bool}}\n\nCompute the corresponding rotation matrix.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nz_axis::Symbol: Target reference system axis. The options are:\n:zero -> No rotation is applied.\n:am   -> The angular momentum will be used as the new z axis.\n:pa   -> The principal axes will be used as the new coordinate system.\ncomponent::Symbol: Which component will be considered to compute the angular momentum or the principal axes. The options are:\n:all         -> Every component present in data_dict.\n:{component} -> Any of the keys of PARTICLE_INDEX, if present in data_dict.\nfilter_function::Function: A function with the signature:\nfilter_function(data_dict::Dict) -> filter_dict::Dict{Symbol,IndexType}\nDetermines which cell/particles will be considered to compute the angular momentum or the principal axes.\n\nReturns\n\nThe rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/transformations/#GalaxyInspector.rotateData!-Tuple{Dict, Symbol, Symbol, Function}","page":"Coordinate transformation functions","title":"GalaxyInspector.rotateData!","text":"rotateData!(\n    data_dict::Dict,\n    z_axis::Symbol,\n    component::Symbol,\n    filter_function::Function,\n)::Nothing\n\nRotate the positions and velocities of the cells/particles in data_dict.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nz_axis::Symbol: Target reference system axis. The options are:\n:zero -> No rotation is applied.\n:am   -> The angular momentum will be used as the new z axis.\n:pa   -> The principal axes will be used as the new coordinate system.\ncomponent::Symbol: Which component will be considered to compute the angular momentum or the principal axes. The options are:\n:all         -> Every component present in data_dict.\n:{component} -> Any of the keys of PARTICLE_INDEX, if present in data_dict.\nfilter_function::Function: A function with the signature:\nfilter_function(data_dict::Dict) -> filter_dict::Dict{Symbol,IndexType}\nDetermines which cell/particles will be considered to compute the angular momentum or the principal axes.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/transformations/#GalaxyInspector.rotateData!-Tuple{Dict, Union{LinearAlgebra.UniformScaling{Bool}, Matrix{Float64}}}","page":"Coordinate transformation functions","title":"GalaxyInspector.rotateData!","text":"rotateData!(\n    data_dict::Dict,\n    rotation_matrix::Union{Matrix{Float64},UniformScaling{Bool}},\n)::Nothing\n\nRotate the positions and velocities of the cells/particles in data_dict.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\nrotation_matrix::Union{Matrix{Float64},UniformScaling{Bool}}: Rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/transformations/#GalaxyInspector.selectTransformation-Tuple{Symbol, Dict{Symbol, Vector{String}}}","page":"Coordinate transformation functions","title":"GalaxyInspector.selectTransformation","text":"selectTransformation(\n    trans_mode::Symbol,\n    base_request::Dict{Symbol,Vector{String}},\n)::Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}\n\nSelect a translation and rotation from a list of premade ones.\n\nCreates a request dictionary, using request as a base, adding what is necessary for the corresponding transformations.\n\nArguments\n\ntrans_mode::Symbol: How to translate and rotate the cells/particles, after filtering with filter_mode. The options are the elements of TRANSFORM_LIST which have the form :{component}_{group} selecting which cells/particle to consider for the center of mass (new origin for the translation) and principal axis (new reference system for the rotation), where component can be:\n:all         -> Every component present in data_dict\n:{component} -> One of the keys of PARTICLE_INDEX\nand group can be:\n:box     -> Whole simulation box\n:halo    -> Main halo\n:subhalo -> Main subhalo\nAlternatively, it can be :zero, in which case no translation nor rotation is applied.\nbase_request::Dict{Symbol,Vector{String}}: Base request dictionary.\n\nReturns\n\nA Tuple with tree elements:\nThe translation (see the posible arguments of translateData!).\nThe rotation (see the posible arguments of rotateData!).\nThe new request dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/transformations/#GalaxyInspector.selectTransformation-Tuple{Tuple{Union{Int64, Tuple{Int64, Int64}, Symbol, Tuple{Vector{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}}}, Union{Tuple{LinearAlgebra.UniformScaling{Bool}}, Tuple{Matrix{Float64}}, Tuple{Symbol, Symbol, Function}}, Dict{Symbol, Vector{String}}}, Dict{Symbol, Vector{String}}}","page":"Coordinate transformation functions","title":"GalaxyInspector.selectTransformation","text":"selectTransformation(\n    trans_mode::Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}},\n    base_request::Dict{Symbol,Vector{String}},\n)::Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}\n\nCompatibility method to pass personalized transformations to functions that only use the trans_mode argument.\n\nArguments\n\ntrans_mode::Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}: Translation, rotation, and the request that goes with them. See the posible arguments of translateData! and rotateData!.\nbase_request::Dict{Symbol,Vector{String}}: Base request dictionary.\n\nReturns\n\nA Tuple with tree elements:\nThe translation (see the posible arguments of translateData!).\nThe rotation (see the posible arguments of rotateData!).\nThe new request dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/transformations/#GalaxyInspector.translateData!-Tuple{Dict, Vararg{Union{Int64, Tuple{Int64, Int64}, Symbol}}}","page":"Coordinate transformation functions","title":"GalaxyInspector.translateData!","text":"translateData!(data_dict::Dict, translation::Union{Symbol,NTuple{2,Int},Int}...)::Nothing\n\nTranslate the positions and velocities of the cells/particles in data_dict.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\ntranslation::Union{Symbol,NTuple{2,Int},Int}: Target translation. The options are:\n:zero                       -> No translation is applied.\n:all                        -> Sets the center of mass of the whole system as the new origin.\n:{component}                -> Sets the center of mass of the given component (e.g. :stellar, :gas, :darkmatter, etc) as the new origin. It can be any of the keys of [`PARTICLEINDEX`](@ref).\n(halo_idx, subhalo_rel_idx) -> Sets the position of the potential minimum for the subhalo_rel_idx::Int subhalo (of the halo_idx::Int halo) as the new origin.\n(halo_idx, 0)               -> Sets the center of mass of the halo_idx::Int halo as the new origin.\nsubhalo_abs_idx             -> Sets the center of mass of the subhalo_abs_idx::Int as the new origin.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/transformations/#GalaxyInspector.translateData!-Tuple{Dict, Vector{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐋 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}}","page":"Coordinate transformation functions","title":"GalaxyInspector.translateData!","text":"translateData!(\n    data_dict::Dict,\n    origin::Vector{<:Unitful.Length},\n    vcm::Vector{<:Unitful.Velocity},\n)::Nothing\n\nTranslate the positions and velocities of the cells/particles in data_dict such that origin and vcm end up both being [0, 0, 0].\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\norigin::Vector{<:Unitful.Length}: Target origin.\nvcm::Vector{<:Unitful.Velocity}: Velocity of the center of mass.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/transformations/#GalaxyInspector.translatePoints!-Tuple{Matrix{<:Number}, Vector{<:Number}}","page":"Coordinate transformation functions","title":"GalaxyInspector.translatePoints!","text":"translatePoints!(points::Matrix{<:Number}, origin::Vector{<:Number})::Nothing\n\nTranslate a system of points, moving origin to [0, 0, 0].\n\nArguments\n\npoints::Matrix{<:Number}: Points to be translated. Each column is a point and each row a dimension.\norigin::Vector{<:Number}: Target origin.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/times/#Computation-of-time-related-quantities","page":"Computation of time related quantities","title":"Computation of time related quantities","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/analysis/compute_quantities/times/#GalaxyInspector.computeDepletionTime-Tuple{Dict, Symbol}","page":"Computation of time related quantities","title":"GalaxyInspector.computeDepletionTime","text":"computeDepletionTime(data_dict::Dict, component::Symbol)::Vector{<:Unitful.Time}\n\nCompute the depletion time,\n\nt_mathrmff = fracM_mathrmgasdotM_star  \n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component:\nIf component ∈ [:gas, :hydrogen, :helium]:\n:gas => [\"SFR \", \"MASS\"]\nIf component == :Z_gas:\n:gas => [\"SFR \", \"MASS\", \"GZ  \"]\nIf component ∈ [:ionized, :neutral]:\n:gas => [\"SFR \", \"MASS\", \"NH  \", \"NHP \"]\nIf component ∈ [:bratomic, :brmolecular]:\n:gas => [\"SFR \", \"MASS\", \"NH  \", \"NHP \", \"PRES\"]\nIf component ∈ [:odeionized, :odeatomic, :odemetals, :odedust, :ode_neutral]:\n:gas => [\"SFR \", \"MASS\", \"NH  \", \"NHP \", \"FRAC\", \"RHO \", \"GZ  \"]\nIf component ∈ [:odemolecular, :odestellar]:\n:gas => [\"SFR \", \"MASS\", \"FRAC\", \"RHO \"]\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nThe depletion time of component.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/times/#GalaxyInspector.computeDepletionTime-Tuple{Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐌 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐓^-1, U}} where {L, S}} where {T, U}}}","page":"Computation of time related quantities","title":"GalaxyInspector.computeDepletionTime","text":"computeDepletionTime(\n    masses::Vector{<:Unitful.Mass},\n    sfrs::Vector{<:Unitful.MassFlow},\n)::Vector{<:Unitful.Time}\n\nCompute the depletion time,\n\nt_mathrmff = fracM_mathrmgasdotM_star  \n\nArguments\n\nmasses::Vector{<:Unitful.Mass}: Mass of every cell.\nsfrs::Vector{<:Unitful.MassFlow}: The SFR associated to each cell.\n\nReturns\n\nThe depletion times.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/times/#GalaxyInspector.computeSFR-Tuple{Dict}","page":"Computation of time related quantities","title":"GalaxyInspector.computeSFR","text":"computeSFR(\n    data_dict::Dict;\n    <keyword arguments>\n)::Vector{<:Unitful.MassFlow}\n\nCompute the star formation rate of each stellar particle.\n\nFor stellar particles younger than age_limit, the SFR is its mass divided by age_limit. For older particles it is 0.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present:\n:stellar => [\"MASS\", \"GAGE\"]\nage_limit::Unitful.Time=AGE_RESOLUTION: Age limit for the SFR.\n\nReturns\n\nThe star formation rate of each stellar particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/times/#GalaxyInspector.computeSSFR-Tuple{Dict}","page":"Computation of time related quantities","title":"GalaxyInspector.computeSSFR","text":"computeSSFR(\n    data_dict::Dict;\n    <keyword arguments>\n)::Vector{<:Unitful.MassFlow}\n\nCompute the specific star formation rate of each stellar particle.\n\nFor stellar particles younger than age_limit, the sSFR is 1 / age_limit. For older particles it is 0.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present:\n:stellar => [\"MASS\", \"GAGE\"]\nage_limit::Unitful.Time=AGE_RESOLUTION: Age limit for the SFR.\n\nReturns\n\nThe specific star formation rate of each stellar particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/times/#GalaxyInspector.computeStellarAge-Tuple{Dict}","page":"Computation of time related quantities","title":"GalaxyInspector.computeStellarAge","text":"computeStellarAge(data_dict::Dict)::Vector{<:Unitful.Time}\n\nCompute the age of the stars.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present:\n:stellar => [\"GAGE\"]\n\nReturns\n\nThe stellar ages.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/times/#GalaxyInspector.computeStellarBirthTime-Tuple{Dict}","page":"Computation of time related quantities","title":"GalaxyInspector.computeStellarBirthTime","text":"computeStellarBirthTime(data_dict::Dict)::Vector{<:Unitful.Time}\n\nCompute the stellar birth times.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present:\n:stellar => [\"GAGE\"]\n\nReturns\n\nThe stellar birth times.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/times/#GalaxyInspector.computeTime-Tuple{Real, GalaxyInspector.SnapshotHeader}","page":"Computation of time related quantities","title":"GalaxyInspector.computeTime","text":"computeTime(a::Real, header::SnapshotHeader; <keyword arguments>)::Unitful.Time\n\nCompute the physical time corresponding to the scale factor a.\n\nTo get the physical time t from the scale factor a, one does the integral\n\nt = frac1H_0 int_0^a fracmathrmdaa  sqrtmathcalE(a)  \n\nwhere\n\nmathcalE(a) = Omega_Lambda + Omega_m  a^-3 + Omega_r  a^-4 + Omega_K  a^-2  \n\nArguments\n\na::Real: Scale factor.\nheader::SnapshotHeader: Header of the relevant snapshot file, containing the cosmological parameters.\na0::Float64=0.0: Initial scale factor.\n\nReturns\n\nThe physical time.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/times/#GalaxyInspector.computeTime-Tuple{Vector{<:Real}, GalaxyInspector.SnapshotHeader}","page":"Computation of time related quantities","title":"GalaxyInspector.computeTime","text":"computeTime(\n    scale_factors::Vector{<:Real},\n    header::SnapshotHeader;\n    <keyword arguments>\n)::Vector{<:Unitful.Time}\n\nCompute the physical time corresponding to each of the scale_factors.\n\nTo get the physical time t from the scale factor a, one does the integral\n\nt = frac1H_0 int_0^a fracmathrmdaa  sqrtmathcalE(a)  \n\nwhere\n\nmathcalE(a) = Omega_Lambda + Omega_m  a^-3 + Omega_r  a^-4 + Omega_K  a^-2  \n\nArguments\n\nscale_factors::Vector{<:Real}: Scale factors.\nheader::SnapshotHeader: Header of the relevant snapshot file, containing the cosmological parameters.\na0::Float64=0.0: Initial scale factor.\n\nReturns\n\nThe physical times.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/times/#GalaxyInspector.computeTimeStamps-Tuple{Vector{<:Union{Missing, String}}}","page":"Computation of time related quantities","title":"GalaxyInspector.computeTimeStamps","text":"computeTimeStamps(\n    paths::Vector{<:Union{Missing,String}},\n)::Tuple{Vector{Float64},Vector{Float64},Vector{<:Unitful.Time},Vector{<:Unitful.Time}}\n\nCompute the different times stamps associated with each snapshot in paths.\n\nArguments\n\npaths::Vector{<:Union{Missing,String}}: Paths to the snapshots.\n\nReturns\n\nA tuple with four elements:\nA vector with the scale factors.\nA vector with the redshifts.\nA vector with the physical times (physical time since the Big Bang).\nA vector with the lookback times (physical time left to reach the last snapshot).\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/times/#GalaxyInspector.energyIntegrand-Tuple{Real, GalaxyInspector.SnapshotHeader}","page":"Computation of time related quantities","title":"GalaxyInspector.energyIntegrand","text":"energyIntegrand(a::Real, header::SnapshotHeader)::Float64\n\nThe integrand of the integral that converts scale factors into physical times,\n\nfrac1HsqrtmathcalE  \n\nwhere\n\nmathcalE = Omega_Lambda + (1 - Omega_Lambda - Omega_m)  a^-2 + Omega_m  a^-3  \n\nH = H_0  a  \n\nArguments\n\na::Real: Scale factor.\nheader::SnapshotHeader: Header of the relevant snapshot file, containing the cosmological parameters.\n\nReturns\n\nThe integrand evaluated at a, in mathrmGyr.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#Post-processing-functions","page":"Post processing functions","title":"Post processing functions","text":"These functions are used internally and none are exported. \n\nA post-processing function must take a Makie figure, add something to it, and return how to label the additions (or nothing when no new labels should be drawn).","category":"section"},{"location":"api/plotting/post_processing/#Expected-signature:","page":"Post processing functions","title":"Expected signature:","text":"  post_processing(figure, args...; kwargs...) -> ([marker, ...], [label, ...])\n\nwhere:\n\nfigure::Makie.Figure\nmarker::LegendElement\nlabel::String\n\n","category":"section"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppABFlags!-Tuple{Makie.Figure, Vector{<:Real}, Vector{<:Real}}","page":"Post processing functions","title":"GalaxyInspector.ppABFlags!","text":"ppABFlags!(\n    figure::Makie.Figure,\n    slopes::Vector{<:Real}\n    intercepts::Vector{<:Real};\n    <keyword arguments>\n)::Nothing\n\nDraw lines defined by f(x) = slope * x + intercept.\n\nArguments\n\nfigure::Makie.Figure: Makie figure to be drawn over.\nslopes::Vector{<:Real}: List of slopes.\nintercepts::Vector{<:Real}: List of intercepts.\ncolors::Vector{<:ColorType}=[:red]: Colors of the lines.\nline_styles::Vector{<:LineStyleType}=[:solid]: Styles of the lines.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppAgertz2021!-Tuple{Makie.Figure}","page":"Post processing functions","title":"GalaxyInspector.ppAgertz2021!","text":"ppAgertz2021!(\n    figure::Makie.Figure;\n    <keyword arguments>\n)::Tuple{Vector{<:LegendElement},Vector{AbstractString}}\n\nDraw the stellar density profiles from McMillan (2011) and Leroy et al. (2008), show in Agertz et al. (2021).\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\ngalaxies::Vector=[\"MW\"]: Target galaxies. The options are:\nOne of the 23 galaxies in Leroy et al. (2008), e.g. \"DDO154\", \"HOI\", \"HOII\", \"IC2574\", \"NGC0628\", \"NGC0925\", etc. For a full list see Agertz et al. (2021).\n:all: All 23 galaxies in the dataset of Leroy et al. (2008) (this options will plot the data as an scatter plot with transparency instead of a line plot).\n\"MW\": The Milky Way fits from McMillan (2011).\nx_unit::Unitful.Units=u\"kpc\": Unit for the x axis in figure.\ny_unit::Unitful.Units=u\"Msun * kpc^-2\": Unit for the y axis in figure.\nx_log::Bool=false: If the x axis will be plotted as the log_10 of the galactocentric radius.\ny_log::Bool=true: If the y axis will be plotted as the log_10 of the stellar surface density.\nerror_band::Bool=true: If the error band will be plotted.\ncolors::Vector{<:ColorType}=[WONG_RED]: Colors for stellar profiles.\nlinestyle::LineStyleType=:solid: Style of the line.\nlinewidth::Int=3: Width of the lines.\n\nReturns\n\nA tuple with the elements for the legend:\nA LineElement to be used as the marker.\nThe label.\n\nReferences\n\nO. Agertz et al. (2021). VINTERGATAN – I. The origins of chemically, kinematically, and structurally distinct discs in a simulated Milky Way-mass galaxy. Monthly Notices of the Royal Astronomical Society. **503(4), 5826–5845. doi:10.1093/mnras/stab322\n\nA. K. Leroy et al. (2008). THE STAR FORMATION EFFICIENCY IN NEARBY GALAXIES: MEASURING WHERE GAS FORMS STARS EFFECTIVELY. The Astronomical Journal 136(6), 2782–2845. doi:10.1088/0004-6256/136/6/2782\n\nP. J. McMillan (2011). Mass models of the Milky Way. Monthly Notices of the Royal Astronomical Society 414(3), 2446–2457. doi:10.1111/j.1365-2966.2011.18564.x\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppAnnotation!-Tuple{Makie.Figure, AbstractString}","page":"Post processing functions","title":"GalaxyInspector.ppAnnotation!","text":"ppAnnotation!(figure::Makie.Figure, text::AbstractString; <keyword arguments>)::Nothing\n\nAdd an annotation to the plot.\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\ntext::AbstractString: Text to be written.\nposition::Tuple{<:Real,<:Real}=(0.04, 0.98): Relative position of the top left corner of the text box.\ncolor=:black: Text color.\nfontsize::Int=35: Font size.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppArrows!-Tuple{Makie.Figure, Vector{NTuple{4, Float64}}}","page":"Post processing functions","title":"GalaxyInspector.ppArrows!","text":"ppArrows!(\n    figure::Makie.Figure,\n    positions::Vector{NTuple{4,Float64}};\n    <keyword arguments>\n)::Nothing\n\nDraw arrows.\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\npositions::Vector{NTuple{4,Float64}}: The x, y, u, and v coordinates of the arrows. x and y indicate the position of the tails, and u and v the position of the point of the arrows.\ncolors::Vector{<:ColorType}=[WONG_RED]: Colors of the arrows.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppBarPlotLabels-Tuple{Makie.Figure, Vector{Symbol}}","page":"Post processing functions","title":"GalaxyInspector.ppBarPlotLabels","text":"ppBarPlotLabels(\n    ::Makie.Figure,\n    components::Vector{Symbol};\n    <keyword arguments>\n)::Tuple{Vector{<:LegendElement},Vector{AbstractString}}\n\nReturn the legend elements for the plot made by gasBarPlot.\n\nArguments\n\n::Makie.Figure: Makie figure.\ncomponents::Vector{Symbol}: List of gas components to be considered. See COMPONENTS for options.\ncolors=Makie.wong_colors(): Colors of the bars.\n\nReturns\n\nA tuple with the elements for the legend:\nPolyElements to be used in the legend.\nThe label strings.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppBigiel2008!-Tuple{Makie.Figure, Bool}","page":"Post processing functions","title":"GalaxyInspector.ppBigiel2008!","text":"ppBigiel2008!(\n    figure::Makie.Figure,\n    molecular::Bool;\n    <keyword arguments>\n)::Union{Tuple{Vector{<:LegendElement},Vector{AbstractString}},Nothing}\n\nDraw a line plot with the fit for the Kennicutt-Schmidt relation from Bigiel et al. (2008).\n\nnote: Note\nThe resolution used in Bigiel et al. (2008) is 750 pc (see Section 1).\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\nmolecular::Bool: If the x axis will be the area mass density of molecular hydrogen, or, if set to false, the area mass density of neutral hydrogen.\nx_unit::Unitful.Units=u\"Msun * pc^-2\": Unit for the area density of gas used in figure.\ny_unit::Unitful.Units=u\"Msun * yr^-1 * kpc^-2\": Unit for the area density of star formation rate used in figure.\nx_log::Bool=true: If the x axis is log_10(Sigma_mathrmH) (x_log = true) or just Sigma_mathrmH (x_log = false).\ny_log::Bool=true: If the y axis is log_10(Sigma_mathrmSFR) (y_log = true) or just Sigma_mathrmSFR (y_log = false).\nextend::Float64=0.0: By default the y axis limits will be the vertical range of the points in the plot. This can be extended by the multiplicative factor extend of the vertical range.\ncolor::ColorType=WONG_RED: Color for the line.\nlinestyles::Vector{<:LineStyleType}=[:solid, :dash],: Styles for the lines. The first style will indicate the range for which there are experimental data, and the second one will be for the extrapolation.\nlinewidth::Int=3: Line width.\n\nReturns\n\nA tuple with the elements for the legend:\nA LineElement to be used as the marker.\nThe label.\n\nReferences\n\nF. Bigiel et al. (2008). THE STAR FORMATION LAW IN NEARBY GALAXIES ON SUB-KPC SCALES. The Astrophysical Journal, 136(6), 2846. doi:10.1088/0004-6256/136/6/2846\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppBigiel2010!-Tuple{Makie.Figure}","page":"Post processing functions","title":"GalaxyInspector.ppBigiel2010!","text":"ppBigiel2010!(\n    figure::Makie.Figure;\n    <keyword arguments>\n)::Tuple{Vector{<:LegendElement},Vector{AbstractString}}\n\nDraw a scatter plot of the SFR surface density vs gas surface density (Kennicutt-Schmidt law) for a given galaxy, using the data from Bigiel et al. (2010).\n\nnote: Note\nThe resolution used in Bigiel et al. (2010) is 600 pc (see Section 2).\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\ngalaxy::Union{String,Symbol}=\"NGC 628\": Target galaxy. The options are:\nWith molecular and and atomic data (Table 2): \"NGC 628\", \"NGC 3184\", \"NGC 3521\", \"NGC 4736\", \"NGC 5055\", \"NGC 5194\", \"NGC 6946\".\nWith only atomic data (Table 3): \"NGC 925\", \"NGC 2403\", \"NGC 2841\", \"NGC 2903\", \"NGC 3198\", \"NGC 3351\", \"NGC 3621\", \"NGC 3627\", \"NGC 5236\", \"NGC 5457\", \"NGC 7331\", \"NGC 7793\".\n:all: Every galaxy that is available for the given quantity. For more information on each galaxy see Bigiel et al. (2010).\nquantity::Symbol=:molecular: Gas quantity for the x axis. The options are:\n:molecular -> Surface density of molecular gas.\n:neutral   -> Surface density of neutral gas.\n:atomic    -> Surface density of atomic gas.\nx_unit::Unitful.Units=u\"Msun * pc^-2\": Unit for the area density of gas used in figure.\ny_unit::Unitful.Units=u\"Msun * yr^-1 * kpc^-2\": Unit for the area density of star formation rate used in figure.\nx_log::Bool=true: If the x axis will be plotted as the log_10 of the gas surface density.\ny_log::Bool=true: If the y axis will be plotted as the log_10 of the SFR surface density.\ncolor::ColorType=WONG_RED: Color of the markers.\n\nReturns\n\nA tuple with the elements for the legend:\nA MarkerElement to be used as the marker.\nThe label.\n\nReferences\n\nF. Bigiel et al. (2010). EXTREMELY INEFFICIENT STAR FORMATION IN THE OUTER DISKS OF NEARBY GALAXIES. The Astrophysical Journal, 140(5), 1194. doi:10.1088/0004-6256/140/5/1194\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppCross!-Tuple{Makie.Figure, Tuple{Real, Real}}","page":"Post processing functions","title":"GalaxyInspector.ppCross!","text":"ppCross!(\n    figure::Makie.Figure,\n    cross_point::Tuple{<:Real,<:Real};\n    <keyword arguments>\n)::Union{Tuple{Vector{<:LegendElement},Vector{AbstractString}},Nothing}\n\nDraw two lines, one horizontal and one vertical.\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\ncross_point::Tuple{<:Real,<:Real}: Crossing point of the lines.\ncolor::ColorType=WONG_RED: Color of the lines.\nlinestyle::LineStyleType=:solid: Style of the lines.\nlabel::Union{AbstractString,Nothing}=nothing: Label for the lines. If set to nothing no label is printed.\n\nReturns\n\nA tuple with the elements for the legend:\nA LineElement to be used as the marker.\nThe label.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppFeldmann2020!-Tuple{Makie.Figure, Symbol, Symbol}","page":"Post processing functions","title":"GalaxyInspector.ppFeldmann2020!","text":"ppFeldmann2020!(\n    figure::Makie.Figure,\n    x_quantity::Symbol,\n    y_quantity::Symbol;\n    <keyword arguments>\n)::Tuple{Vector{<:LegendElement},Vector{AbstractString}}\n\nDraw the experimental data from xGASS and xCOLD GASS, compiled by Feldmann (2020), as a line or scatter plot.\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\nx_quantity::Symbol: Quantity for the x axis. The options are:\n:stellar   -> Stellar mass.\n:molecular -> Molecular mass.\n:atomic    -> Atomic mass.\n:sfr       -> Star formation rate of the last AGE_RESOLUTION.\ny_quantity::Symbol: Quantity for the y axis. The options are:\n:stellar   -> Stellar mass.\n:molecular -> Molecular mass.\n:atomic    -> Atomic mass.\n:sfr       -> Star formation rate of the last AGE_RESOLUTION.\nscatter::Bool=false: If the data will be presented as a line plot with error bands (default), or alternatively, a scatter plot.\nxlog::Bool=true: If the x axis will be plotted as the log_10 of the x quantity.\nylog::Bool=true: If the y axis will be plotted as the log_10 of the y quantity.\n\nReturns\n\nA tuple with the elements for the legend:\nA MarkerElement to be used as the marker.\nThe label.\n\nReferences\n\nR. Feldmann (2020). The link between star formation and gas in nearby galaxies. Communications Physics 3(226). doi:10.1038/s42005-020-00493-0\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppFillBelowLine!-Tuple{Makie.Figure}","page":"Post processing functions","title":"GalaxyInspector.ppFillBelowLine!","text":"ppFillBelowLine!(\n    figure::Makie.Figure;\n    <keyword arguments>\n)::Union{Tuple{Vector{<:LegendElement},Vector{AbstractString}},Nothing}\n\nFill the space below a line plot with a solid color down to a lower_limit.\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\nlower_limit::Number=0.0: Lower bound.\ncolor::ColorType=WONG_RED: Color.\nalpha::Float64=0.3: Level of transparency. 1.0 is completely opaque and 0.0 is completely transparent.\nlabel::Union{AbstractString,Nothing}=nothing: Label for the shaded region. If set to nothing no label is printed.\n\nReturns\n\nA tuple with the elements for the legend:\nA MarkerElement to be used as the marker.\nThe label.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppFitLine!-Tuple{Makie.Figure}","page":"Post processing functions","title":"GalaxyInspector.ppFitLine!","text":"ppFitLine!(\n    figure::Makie.Figure;\n    <keyword arguments>\n)::Union{Tuple{Vector{<:LegendElement},Vector{AbstractString}},Nothing}\n\nDraw a linear fit for the data in figure.\n\nAn annotation with the equation y = a  x + b, and the fitted values for a and b, will be positioned in the upper right corner of the plot.\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\ntext_position::Tuple{<:Real,<:Real}=(0.04, 0.98): Relative position of the top left corner of the text box.\ntext_align::NTuple{2,Symbol}=(:left, :top): Corner of the legend box whose positions is set with text_position.\nwts::Union{Vector{Float64},Nothing}=nothing: Weights for the fits. Set to nothing for a non-weighted fit.\nerror_formating::Symbol=:std_error: Error format for the annotation. The options are:\n:std_error     -> mean ± standard_error.\n:conf_interval -> mean ± max(upper_95 - mean, mean - lower_95).\ncolor::ColorType=WONG_RED: Color of the line.\nlinestyle::LineStyleType=:solid: Style of the line.\nlinewidth::Int=3: Line width.\n\nReturns\n\nA tuple with the elements for the legend:\nA LineElement to be used as the marker.\nThe label.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppHorizontalFlags!-Tuple{Makie.Figure, Vector{<:Real}}","page":"Post processing functions","title":"GalaxyInspector.ppHorizontalFlags!","text":"ppHorizontalFlags!(\n    figure::Makie.Figure,\n    positions::Vector{<:Real};\n    <keyword arguments>\n)::Union{Tuple{Vector{<:LegendElement},Vector{AbstractString}},Nothing}\n\nDraw horizontal lines.\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\npositions::Vector{<:Real}: The y coordinates of the lines.\ncolors::Vector{<:ColorType}=[WONG_RED]: Colors of the lines.\nline_styles::Vector{<:LineStyleType}=[:solid]: Styles of the lines.\nlabels::Union{Vector{AbstractString},Nothing}=nothing: Labels for the lines. If set to nothing no label is printed.\n\nReturns\n\nA tuple with the elements for the legend:\nLineElements to be used as the marker.\nThe labels.\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppKennicutt1998!-Tuple{Makie.Figure}","page":"Post processing functions","title":"GalaxyInspector.ppKennicutt1998!","text":"ppKennicutt1998!(\n    figure::Makie.Figure;\n    <keyword arguments>\n)::Union{Tuple{Vector{<:LegendElement},Vector{AbstractString}},Nothing}\n\nDraw a line plot with the fit for the Kennicutt-Schmidt relation from Kennicutt (1998).\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\nx_unit::Unitful.Units=u\"Msun * pc^-2\": Unit for the area density of gas used in figure.\ny_unit::Unitful.Units=u\"Msun * yr^-1 * kpc^-2\": Unit for the area density of star formation rate used in figure.\nx_log::Bool=true: If the x axis is log_10(Sigma_mathrmHI + H_2) (x_log = true) or just Sigma_mathrmHI + H_2 (x_log = false).\ny_log::Bool=true: If the y axis is log_10(Sigma_mathrmSFR) (y_log = true) or just Sigma_mathrmSFR (y_log = false).\nextend::Float64=0.0: By default the y axis limits of the line will be the vertical range of points in the plot. This can be extended by the fraction extend of the vertical range.\ncolor::ColorType=WONG_RED: Color for the line.\nlinestyles::Vector{<:LineStyleType}=[:solid, :dash],: Styles for the lines. The first style will indicate the range for which there are experimental data, and the second one will be for the extrapolation.\nlinewidth::Int=3: Line width.\n\nReturns\n\nA tuple with the elements for the legend:\nA LineElement to be used as the marker.\nThe label.\n\nReferences\n\nR. C. Kennicutt (1998). The Global Schmidt Law in Star-forming Galaxies. The Astrophysical Journal, 498(2), 541-552. doi:10.1086/305588\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppLeroy2008!-Tuple{Makie.Figure}","page":"Post processing functions","title":"GalaxyInspector.ppLeroy2008!","text":"ppLeroy2008!(\n    figure::Makie.Figure;\n    <keyword arguments>\n)::Tuple{Vector{<:LegendElement},Vector{AbstractString}}\n\nDraw a scatter plot of the SFR surface density vs gas surface density (Kennicutt-Schmidt law) for a given galaxy, using the data from Leroy et al. (2008).\n\nnote: Note\nThe resolution used in Leroy et al. (2008) is 800 pc for spirals and 400 pc for dwarf galaxies (Section 3.1).\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\nquantity::Symbol=:molecular: Gas quantity for the x axis. The options are:\n:molecular -> Surface density of molecular gas.\n:neutral   -> Surface density of neutral gas.\n:atomic    -> Surface density of atomic gas.\ngalaxies::Vector=[\"MW\"]: Target galaxies. The options are:\nOne of the 23 galaxies in Leroy et al. (2008), e.g. \"DDO154\", \"HOI\", \"HOII\", \"IC2574\", \"NGC0628\", \"NGC0925\", etc. For a full list see Leroy et al. (2008).\n:all: All 23 galaxies in Leroy et al. (2008).\nx_unit::Unitful.Units=u\"Msun * pc^-2\": Unit for the area density of gas used in figure.\ny_unit::Unitful.Units=u\"Msun * yr^-1 * kpc^-2\": Unit for the area density of star formation rate used in figure.\nx_log::Bool=true: If the x axis will be plotted as the log_10 of the gas surface density.\ny_log::Bool=true: If the y axis will be plotted as the log_10 of the SFR surface density.\nerror_bars::Bool=false: If error bars will be plotted.\ncolor::ColorType=WONG_RED,: Color for the markers.\n\nReturns\n\nA tuple with the elements for the legend:\nA MarkerElement to be used as the marker.\nThe label.\n\nReferences\n\nA. K. Leroy et al. (2008). THE STAR FORMATION EFFICIENCY IN NEARBY GALAXIES: MEASURING WHERE GAS FORMS STARS EFFECTIVELY. The Astronomical Journal 136(6), 2782–2845. doi:10.1088/0004-6256/136/6/2782\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppMolla2015!-Tuple{Makie.Figure, Symbol}","page":"Post processing functions","title":"GalaxyInspector.ppMolla2015!","text":"ppMolla2015!(\n    figure::Makie.Figure,\n    quantity::Symbol,\n    <keyword arguments>\n)::Tuple{Vector{<:LegendElement},Vector{AbstractString}}\n\nDraw a profile for the Milky Way using the data compiled by Mollá et al. (2015).\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\nquantity::Symbol: Quantity for the y axis. The options are:\n:stellar_area_density   -> Stellar mass surface density, as log10(Sigma_star).\n:molecular_area_density -> Molecular mass surface density, as log10(Sigma_textH2).\n:atomic_area_density    -> Atomic mass surface density, as log10(Sigma_textHI).\n:sfr_area_density       -> Star formation rate surface density, as log10(Sigma_textSFR).\n:X_stellar_abundance    -> Stellar abundance of element mathrmX, as ABUNDANCE_SHIFT + log_10(mathrmX    H). mathrmX can be O (oxygen), N (nitrogen), or C (carbon).\ny_unit::Unitful.Units=Unitful.NoUnits: Target unit for quantity.\ncolor::ColorType=WONG_RED: Color of the line.\nlinestyle::LineStyleType=:solid: Style of the line.\nerror_bars::Bool=true: If the error bars will be plotted.\n\nReturns\n\nA tuple with the elements for the legend:\nA MarkerElement to be used as the marker.\nThe label.\n\nReferences\n\nM. Mollá et al. (2015). Galactic chemical evolution: stellar yields and the initial mass function. Monthly Notices of the Royal Astronomical Society 451(4), 3693–3708. doi:10.1093/mnras/stv1102\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppSun2023!-Tuple{Makie.Figure}","page":"Post processing functions","title":"GalaxyInspector.ppSun2023!","text":"ppSun2023!(\n    figure::Makie.Figure;\n    <keyword arguments>\n)::Tuple{Vector{<:LegendElement},Vector{AbstractString}}\n\nDraw a scatter plot of the SFR surface density vs molecular surface density (molecular Kennicutt-Schmidt law) for a given galaxy, using the data from Sun et al. (2023).\n\nnote: Note\nThe resolution used in Sun et al. (2023) is 1.5 kpc (see Section 2).\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\ngalaxy::Union{String,Symbol}=:main: Target galaxy. The options are:\nOne of the 80 galaxies in the dataset, e.g. \"ESO097-013\", \"IC1954\", \"IC5273\", \"NGC1546\", \"NGC1559\", \"NGC1566\", etc. For a full list see the reference below.\n:main: Every galaxy with -20  log_10(t_mathrmdep    mathrmGyr)  20, where t_mathrmdep = Sigma_mathrmH_2  Sigma_mathrmSFR is the depletion time.\n:all: All 80 galaxies in the dataset. For more information on each galaxy see Sun et al. (2023).\nsfr_calibration::Symbol=:Halpha: SFR calibration for combining UV, optical, and/or IR data. The options are: :Halpha, :FUV, and :AV_corrected_Halpha. For an explanation of each one see section 2 of Sun et al. (2023).\nh2_prescription::Symbol=:S20: Prescription for the CO-to-H₂ conversion factor. The options are: :S20, :Mw, :B13, and :G20. For an explanation of each one see section 2 of Sun et al. (2023).\nx_unit::Unitful.Units=u\"Msun * pc^-2\": Unit for the area density of gas used in figure.\ny_unit::Unitful.Units=u\"Msun * yr^-1 * kpc^-2\": Unit for the area density of star formation rate used in figure.\nx_log::Bool=true: If the x axis will be plotted as the log_10 of the gas surface density.\ny_log::Bool=true: If the y axis will be plotted as the log_10 of the SFR surface density.\ncolor::ColorType=WONG_RED: Color of the markers.\n\nReturns\n\nA tuple with the elements for the legend:\nA MarkerElement to be used as the marker.\nThe label.\n\nReferences\n\nJ. Sun et al. (2023). Star Formation Laws and Efficiencies across 80 Nearby Galaxies. The Astrophysical Journal Letters, 945(2), L19. doi:10.3847/2041-8213/acbd9c\n\n\n\n\n\n","category":"method"},{"location":"api/plotting/post_processing/#GalaxyInspector.ppVerticalFlags!-Tuple{Makie.Figure, Vector{<:Real}}","page":"Post processing functions","title":"GalaxyInspector.ppVerticalFlags!","text":"ppVerticalFlags!(\n    figure::Makie.Figure,\n    positions::Vector{<:Real};\n    <keyword arguments>\n)::Union{Tuple{Vector{<:LegendElement},Vector{AbstractString}},Nothing}\n\nDraw vertical lines.\n\nArguments\n\nfigure::Makie.Figure: Makie figure.\npositions::Vector{<:Real}: The x coordinates of the lines.\ncolors::Vector{<:ColorType}=[WONG_RED]: Colors of the lines.\nline_styles::Vector{<:LineStyleType}=[:solid]: Styles of the lines.\nlabels::Union{Vector{AbstractString},Nothing}=nothing: Labels for the lines. If set to nothing no label is printed.\n\nReturns\n\nA tuple with the elements for the legend:\nLineElements to be used as the marker.\nThe labels.\n\n\n\n\n\n","category":"method"},{"location":"#GalaxyInspector","page":"Introduction","title":"GalaxyInspector","text":"GalaxyInspector is a Julia module for the analysis and visualization of galaxy simulation data, with a focus on snapshots produced by the Arepo code in HDF5 format.\n\nThis module provides a collection of scripts and functions for reading, filtering, analyzing, and plotting simulation outputs. It is designed for flexibility and extensibility, allowing users to adapt it to their own simulation setups and scientific needs.\n\n⚠️ Caution: This code is written for my personal use and is a work in progress, thus it may break at any moment. Use it at your own risk.\n\nℹ️ Note: There are other tools to analyze/plot simulations (you can see here). This module was written not only as a basic plotting tool, but as an exercise to learn Julia and software development in general.","category":"section"},{"location":"#License","page":"Introduction","title":"License","text":"GalaxyInspector is free software, released under the GNU General Public License v3.0.","category":"section"},{"location":"api/analysis/data_acquisition/#Data-acquisition-functions","page":"Data acquisition functions","title":"Data acquisition functions","text":"These functions are used internally and some are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\nThese function read the different output files from the simulation (snapshots, FoF catalogs, sfr.txt, etc.), and load the data into memory as dictionaries.\n\n","category":"section"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.addRequest-Tuple{Dict{Symbol, Vector{String}}, Dict{Symbol, Vector{String}}}","page":"Data acquisition functions","title":"GalaxyInspector.addRequest","text":"addRequest(\n    request::Dict{Symbol,Vector{String}},\n    addition::Dict{Symbol,Vector{String}},\n)::Dict{Symbol,Vector{String}}\n\nAdd the blocks in addition to request, only for the types already present in request.\n\nArguments\n\nrequest::Dict{Symbol,Vector{String}}: The request dictionary for readSnapshot.\naddition::Dict{Symbol,Vector{String}}: Request dictionary with the blocks to be added, only for the types already present in request.\n\nReturns\n\nA new dictionary with all the requests.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.countSnapshot-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.countSnapshot","text":"countSnapshot(simulation_path::String)::Int\n\nCount the number of snapshots in simulation_path.\n\nnote: Note\nThis function counts the number of snapshots, not the number of snapshot files. So if each snapshot is made of more than one files, the count will not change.\n\nArguments\n\nsimulation_path::String: Path to the simulation directory, set in the code variable OutputDir.\n\nReturns\n\nThe number of snapshots.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.countStars-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.countStars","text":"countStars(path::String)::Int\n\nCount the number of stars in a snapshot, excluding wind particles.\n\nArguments\n\npath::String: Path to the snapshot file or folder.\n\nReturns\n\nThe number of stars.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.findClosestSnapshot-Tuple{DataFrames.DataFrame, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"Data acquisition functions","title":"GalaxyInspector.findClosestSnapshot","text":"findClosestSnapshot(simulation_table::DataFrame, time::Unitful.Time)::Int\n\nFind the global index, in the context of the simulation, of the snapshot with a physical time closest to time.\n\nnote: Note\nThis methods uses a precomputed simulation table, made with makeSimulationTable.\n\nArguments\n\nsimulation_table::DataFrame: Dataframe with the path, time stamps, and number of each snapshot and group catalog file in simulation_path. It must have the same shape as the one returned by makeSimulationTable.\ntime::Unitful.Time: Target physical time.\n\nReturns\n\nThe index of the snapshot with a physical time closest to time.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.findClosestSnapshot-Tuple{DataFrames.DataFrame, Vector{<:Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}}","page":"Data acquisition functions","title":"GalaxyInspector.findClosestSnapshot","text":"findClosestSnapshot(\n    simulation_table::DataFrame,\n    times::Vector{<:Unitful.Time},\n)::Vector{Int}\n\nFind the global index, in the context of the simulation, of the snapshot with a physical time closest to each of the ones given in times.\n\nnote: Note\nThis methods uses a precomputed simulation table, made with makeSimulationTable.\n\nArguments\n\nsimulation_table::DataFrame: Dataframe with the path, time stamps, and number of each snapshot and group catalog file in simulation_path. It must have the same shape as the one returned by makeSimulationTable.\ntimes::Vector{<:Unitful.Time}: Target physical times.\n\nReturns\n\nThe indices of the snapshots with physical times closest to times.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.findClosestSnapshot-Tuple{String, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"Data acquisition functions","title":"GalaxyInspector.findClosestSnapshot","text":"findClosestSnapshot(simulation_path::String, time::Unitful.Time)::Int\n\nFind the global index, in the context of the simulation, of the snapshot with a physical time closest to time.\n\nArguments\n\nsimulation_path::String: Path to the simulation directory, set in the code variable OutputDir.\ntime::Unitful.Time: Target physical time.\n\nReturns\n\nThe index of the snapshot with a physical time closest to time.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.findClosestSnapshot-Tuple{String, Vector{<:Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}}","page":"Data acquisition functions","title":"GalaxyInspector.findClosestSnapshot","text":"findClosestSnapshot(simulation_path::String, times::Vector{<:Unitful.Time})::Vector{Int}\n\nFind the global index, in the context of the simulation, of the snapshot with a physical time closest to each of the ones given in times.\n\nArguments\n\nsimulation_path::String: Path to the simulation directory, set in the code variable OutputDir.\ntimes::Vector{<:Unitful.Time}: Target physical times.\n\nReturns\n\nThe indices of the snapshots with physical times closest to times.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.findQtyExtrema-Tuple{String, Int64, Symbol, String}","page":"Data acquisition functions","title":"GalaxyInspector.findQtyExtrema","text":"findQtyExtrema(\n    simulation_path::String,\n    snapshot_n::Int,\n    component::Symbol,\n    block::String;\n    <keyword arguments>\n)::NTuple{2,<:Number}\n\nCompute the minimum and maximum values of block in a snapshot or simulation.\n\nArguments\n\nsimulation_path::String: Path to the simulation directory, set in the code variable OutputDir.\nsnapshot_n::Int: Selects which snapshot to plot, starts at 1 and is independent of the number in the file name. If every snapshot is present, the relation is snapshot_n = (number in filename) + 1. If set to a negative number, the values in the whole simulation will be compared.\ncomponent::Symbol: Cell/particle type. The possibilities are the keys of PARTICLE_INDEX.\nblock::String: Target block. The possibilities are the keys of QUANTITIES.\nf::Function=identity: A function with the signature:\nf(data) -> values\nwhere\ndata::VecOrMat{<:Number}: Data returned by getBlock.\nvalues::Vector{<:Number}: A vector with the values to be compared.\n\nReturns\n\nTuple with the minimum and maximum values.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.findRealStars-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.findRealStars","text":"findRealStars(path::String)::Vector{Bool}\n\nFind which stellar particles are real stars and not wind particles.\n\nArguments\n\npath::String: Path to the snapshot file or folder.\n\nReturns\n\nA boolean vector with true for stars and false for wind particles.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.getBlock-Tuple{String, Symbol, String}","page":"Data acquisition functions","title":"GalaxyInspector.getBlock","text":"getBlock(path::String, component::Symbol, block::String)::VecOrMat{<:Number}\n\nConvenience function to directly get the data associated with one block.\n\nArguments\n\npath::String: Path to the snapshot file or folder.\ncomponent::Symbol: Type of cell/particle. The possibilities are the keys of PARTICLE_INDEX.\nblock::String: Target block. The possibilities are the keys of QUANTITIES.\n\nReturns\n\nThe data for block.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.getGroupCatPaths-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.getGroupCatPaths","text":"getGroupCatPaths(simulation_path::String)::Dict{Symbol,Vector{String}}\n\nFind the path and number of every group catalog in simulation_path.\n\nnote: Note\nIf each group catalog is made of multiple files, the :paths field will have paths to folders, each one containing the sub-files of the corresponding group catalog.\n\nArguments\n\nsimulation_path::String: Path to the simulation directory, set in the code variable OutputDir.\n\nReturns\n\nA dictionary with the following shape:\n:numbers -> The number that characterize each group catalog.\n:paths   -> The full path to each group catalog.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.getSnapshotPaths-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.getSnapshotPaths","text":"getSnapshotPaths(simulation_path::String)::Dict{Symbol,Vector{String}}\n\nFind the path and number of every snapshot in simulation_path.\n\nnote: Note\nIf each snapshot is made of multiple files, the :paths field will have paths to folders, each one containing the sub-files of the corresponding snapshot.\n\nArguments\n\nsimulation_path::String: Path to the simulation directory, set in the code variable OutputDir.\n\nReturns\n\nA dictionary with the following shape:\n:numbers -> The number that characterize each snapshot.\n:paths   -> The full path to each snapshot.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.groupCatTypes-Tuple{Dict}","page":"Data acquisition functions","title":"GalaxyInspector.groupCatTypes","text":"groupCatTypes(data_dict::Dict)::Vector{Symbol}\n\nFind which group catalog data types are part of the keys of data_dict.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\n\nReturns\n\nA vector with the group catalog data types.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.groupCatTypes-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.groupCatTypes","text":"groupCatTypes(path::String)::Vector{Symbol}\n\nFind which group catalog data types are part of the snapshot in path.\n\nnote: Note\nIf each snapshot is made of multiple files, the function will only check the first file.\n\nArguments\n\npath::String: Path to the snapshot file or folder.\n\nReturns\n\nA vector with the group catalog data types.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.internalUnits-Tuple{String, String}","page":"Data acquisition functions","title":"GalaxyInspector.internalUnits","text":"internalUnits(quantity::String, path::String)::Union{Unitful.Quantity,Unitful.Units}\n\nGet the factor to convert a plain number into a Unitful quantity, using the correct internal code units.\n\nArguments\n\nquantity::String: Target quantity. The options are the keys of QUANTITIES.\npath::String: Path to the snapshot file or folder.\n\nReturns\n\nA Unitful quantity or unit.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.isBlockPresent-Tuple{String, HDF5.Group}","page":"Data acquisition functions","title":"GalaxyInspector.isBlockPresent","text":"isBlockPresent(block::String, group::HDF5.Group)::Bool\n\nChecks if a given data block exists in a HDF5 group.\n\nArguments\n\nblock::String: Target block. The possibilities are the keys of QUANTITIES.\ngroup::HDF5.Group: HDF5 group.\n\nReturns\n\nIf block exists in group.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.isBlockPresent-Tuple{Symbol, String, String}","page":"Data acquisition functions","title":"GalaxyInspector.isBlockPresent","text":"isBlockPresent(component::Symbol, block::String, path::String)::Bool\n\nChecks if a given block exists in a snapshot.\n\nnote: Note\nIf each snapshot is made of multiple files, the function will only check the first file.\n\nArguments\n\ncomponent::Symbol: The cell/particle type of the target block. The possibilities are the keys of PARTICLE_INDEX.\nblock::String: Target block. The possibilities are the keys of QUANTITIES.\npath::String: Path to the snapshot file or folder.\n\nReturns\n\nIf block exists in the snapshot.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.isSimCosmological-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.isSimCosmological","text":"isSimCosmological(simulation_path::String)::Bool\n\nCheck if the simulation in simulation_path is cosmological.\n\nnote: Note\nThis function will only read the first snapshot, and if each snapshot is made of multiple files, the function will only read the first file.\n\nArguments\n\nsimulation_path::String: Path to the simulation directory, set in the code variable OutputDir.\n\nReturns\n\nIf the simulation is cosmological\nfalse -> Newtonian simulation    (ComovingIntegrationOn = 0, Redshift = 0.0).\ntrue  -> Cosmological simulation (ComovingIntegrationOn = 1, Redshift != 0.0).\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.isSimSFM-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.isSimSFM","text":"isSimSFM(simulation_path::String)::Bool\n\nCheck if the simulation in simulation_path has our star formation model.\n\nnote: Note\nThis function will only read the first snapshot, and if each snapshot is made of multiple files, the function will only read the first file.\n\nArguments\n\nsimulation_path::String: Path to the simulation directory, set in the code variable OutputDir.\n\nReturns\n\nIf the simulation has our star formation model.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.isSnapCosmological-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.isSnapCosmological","text":"isSnapCosmological(path::String)::Bool\n\nCheck if the snapshot in path comes from a cosmological simulation.\n\nnote: Note\nIf each snapshot is made of multiple files, the function will only read the first file.\n\nArguments\n\npath::String: Path to the snapshot file or folder.\n\nReturns\n\nIf the simulation is cosmological\nfalse -> Newtonian simulation    (ComovingIntegrationOn = 0, Redshift = 0.0).\ntrue  -> Cosmological simulation (ComovingIntegrationOn = 1, Redshift != 0.0).\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.isSnapSFM-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.isSnapSFM","text":"isSnapSFM(path::String)::Bool\n\nCheck if the snapshot in path comes from a simulation with our star formation model.\n\nnote: Note\nIf each snapshot is made of multiple files, the function will only read the first file.\n\nArguments\n\npath::String: Path to the snapshot file or folder.\n\nReturns\n\nIf the simulation has our star formation model.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.isSubfindActive-Tuple{Missing}","page":"Data acquisition functions","title":"GalaxyInspector.isSubfindActive","text":"isSubfindActive(path::Missing)::Bool\n\nDefault method of isSubfindActive for a missing group catalog file.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.isSubfindActive-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.isSubfindActive","text":"isSubfindActive(path::String)::Bool\n\nCheck if the group catalog file has information or is empty.\n\nArguments\n\npath::String: Path to the group catalog file or folder.\n\nReturns\n\nIf there are halo and subhalo information in the group catalog file.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}","page":"Data acquisition functions","title":"GalaxyInspector.makeDataDict","text":"makeDataDict(\n    simulation_path::String,\n    snapshot_n::Int,\n    request::Dict{Symbol,Vector{String}},\n    simulation_table::DataFrame,\n)::Dict\n\nConstruct a data dictionary for a single snapshot.\n\nnote: Note\nThis methods uses a precomputed simulation table, made with makeSimulationTable.\n\nArguments\n\nsimulation_path::String: Path to the simulation directory, set in the code variable OutputDir.\nsnapshot_n::Int: Selects the target snapshot. Starts at 1 and is independent of the number in the file name. If every snapshot is present, the relation is snapshot_n = (number in filename) + 1.\nrequest::Dict{Symbol,Vector{String}}: Dictionary with the shape cell/particle type -> [block, block, ...], where the possible types are the keys of PARTICLE_INDEX, and the possible quantities are the keys of QUANTITIES.\nsimulation_table::DataFrame: Dataframe with the path, time stamps, and number of each snapshot and group catalog file in simulation_path. It must have the same shape as the one returned by makeSimulationTable.\n\nReturns\n\nA dictionary with the following shape:\n:sim_data          -> ::Simulation (see Simulation).\n:snap_data         -> ::Snapshot (see Snapshot).\n:gc_data           -> ::GroupCatalog (see GroupCatalog).\ncell/particle type -> (block -> data of block, block -> data of block, ...).\ncell/particle type -> (block -> data of block, block -> data of block, ...).\ncell/particle type -> (block -> data of block, block -> data of block, ...).\n...\ngroupcat type      -> (block -> data of block, block -> data of block, ...).\ngroupcat type      -> (block -> data of block, block -> data of block, ...).\ngroupcat type      -> (block -> data of block, block -> data of block, ...).\n...\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}}","page":"Data acquisition functions","title":"GalaxyInspector.makeDataDict","text":"makeDataDict(\n    simulation_path::String,\n    snapshot_n::Int,\n    request::Dict{Symbol,Vector{String}},\n)::Dict\n\nConstruct a data dictionary for a single snapshot.\n\nArguments\n\nsimulation_path::String: Path to the simulation directory, set in the code variable OutputDir.\nsnapshot_n::Int: Selects the target snapshot. Starts at 1 and is independent of the number in the file name. If every snapshot is present, the relation is snapshot_n = (number in filename) + 1.\nrequest::Dict{Symbol,Vector{String}}: Dictionary with the shape cell/particle type -> [block, block, ...], where the possible types are the keys of PARTICLE_INDEX, and the possible quantities are the keys of QUANTITIES.\n\nReturns\n\nA dictionary with the following shape:\n:sim_data          -> ::Simulation (see Simulation).\n:snap_data         -> ::Snapshot (see Snapshot).\n:gc_data           -> ::GroupCatalog (see GroupCatalog).\ncell/particle type -> (block -> data of block, block -> data of block, ...).\ncell/particle type -> (block -> data of block, block -> data of block, ...).\ncell/particle type -> (block -> data of block, block -> data of block, ...).\n...\ngroupcat type      -> (block -> data of block, block -> data of block, ...).\ngroupcat type      -> (block -> data of block, block -> data of block, ...).\ngroupcat type      -> (block -> data of block, block -> data of block, ...).\n...\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.makeSimulationTable-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.makeSimulationTable","text":"makeSimulationTable(simulation_path::String)::DataFrame\n\nConstruct a dataframe with the path, time stamps, and number of each snapshot and group catalog file in simulation_path.\n\nArguments\n\nsimulation_path::String: Path to the simulation directory, set in the code variable OutputDir.\n\nReturns\n\nA dataframe with 8 columns:\n:row_id         -> Dataframe index of each snapshot, i.e. if there are 10 snapshots in total it runs from 1 to 10.\n:numbers        -> Number in the file name of each snapshot.\n:scale_factors  -> Scale factor of each snapshot.\n:redshifts      -> Redshift of each snapshot.\n:physical_times -> Physical time since the Big Bang of each snapshot.\n:lookback_times -> Physical time left to reach the last snapshot.\n:snapshot_paths -> Full path to the snapshots.\n:groupcat_paths -> Full path to the group catalog files.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.mergeRequests-Tuple","page":"Data acquisition functions","title":"GalaxyInspector.mergeRequests","text":"mergeRequests(requests...)::Dict{Symbol,Vector{String}}\n\nMerge several request dictionaries, ignoring duplicates.\n\nArguments\n\nrequests: The request dictionaries for readSnapshot.\n\nReturns\n\nA new dictionary with all the requests.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.readCpuFile-Tuple{String, Vector{String}}","page":"Data acquisition functions","title":"GalaxyInspector.readCpuFile","text":"readCpuFile(\n    file_path::String,\n    targets::Vector{String};\n    <keyword arguments>\n)::Dict{String,Matrix{Float64}}\n\nRead the cpu.txt file.\n\nFor each process in targets a matrix with all the CPU usage data is returned.\n\nArguments\n\nfile_path::String: Path to the cpu.txt file.\ntargets::Vector{String}: Target processes.\nstep::Int=1: Step used to traverse the rows.\n\nReturns\n\nA dictionary with the following shape:\ntarget process -> matrix with columns:\nTime step.\nSimulation time (scale factor for cosmological simulations and physical time for non-cosmological simulations).\nClock time in seconds.\nClock time as a percentage.\nTotal clock time in seconds.\nTotal clock time as a percentage.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.readGoupCatBlocks-Tuple{String, String, Dict{Symbol, Vector{String}}}","page":"Data acquisition functions","title":"GalaxyInspector.readGoupCatBlocks","text":"readGoupCatBlocks(\n    file_path::String,\n    snapshot_path::String,\n    request::Dict{Symbol,Vector{String}},\n)::Dict{Symbol,Dict{String,VecOrMat{<:Number}}}\n\nRead the specified blocks from a group catalog file.\n\nArguments\n\nfile_path::String: Path to the group catalog file.\nsnapshot_path::String: Path to the corresponding snapshot file or folder. This is needed for unit conversion.\nrequest::Dict{Symbol,Vector{String}}: The blocks to be read. It must have the shape group type -> [block, block, block].\n\nReturns\n\nA dictionary with the following shape: group type -> (block -> data of block).\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.readGroupCatHeader-Tuple{Union{Missing, String}}","page":"Data acquisition functions","title":"GalaxyInspector.readGroupCatHeader","text":"readGroupCatHeader(path::Union{String,Missing})::GroupCatHeader\n\nRead the header of a group catalog file in the HDF5 format.\n\nnote: Note\nIf each group catalog is made of multiple files, the function will read the header of the first one.\n\nArguments\n\npath::Union{String,Missing}: Path to the group catalog file or folder.\n\nReturns\n\nA GroupCatHeader.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.readGroupCatalog-Tuple{Union{Missing, String}, String, Dict{Symbol, Vector{String}}}","page":"Data acquisition functions","title":"GalaxyInspector.readGroupCatalog","text":"readGroupCatalog(\n    path::Union{String,Missing},\n    snapshot_path::String,\n    request::Dict{Symbol,Vector{String}},\n)::Dict{Symbol,Dict{String,VecOrMat{<:Number}}}\n\nRead the specified blocks from a group catalog file or folder.\n\nArguments\n\npath::Union{String,Missing}: Path to the group catalog file or folder.\nsnapshot_path::String: Path to the corresponding snapshot file or folder. This is needed for unit conversion.\nrequest::Dict{Symbol,Vector{String}}: Which blocks will be read. It must have the shape group type -> [block, block, block].\n\nReturns\n\nA dictionary with the following shape: group type -> (block -> data of block).\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.readSfrFile-Tuple{String, String}","page":"Data acquisition functions","title":"GalaxyInspector.readSfrFile","text":"readSfrFile(\n    file_path::String,\n    snap_path::String,\n)::DataFrame\n\nRead the sfr.txt file.\n\nArguments\n\nfile_path::String: Path to the sfr.txt file.\nsnapshot_path::String: Path to one snapshot file or folder of the simulation. This is needed for unit conversion.\n\nReturns\n\nA DataFrame with the following columns:\nTime or scale factor (internal units).\nTotal stellar mass to be formed prior to stochastic sampling (internal units).\nInstantaneous star formation rate of all cells (mathrmM_odot  yr^-1).\nInstantaneous star formation rate of active cells (mathrmM_odot  yr^-1).\nTotal mass in stars formed after stochastic sampling (internal units).\nCumulative stellar mass formed (internal units).\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.readSnapBlocks-Tuple{String, Dict{Symbol, Vector{String}}}","page":"Data acquisition functions","title":"GalaxyInspector.readSnapBlocks","text":"readSnapBlocks(\n    file_path::String,\n    request::Dict{Symbol,Vector{String}},\n)::Dict{Symbol,Dict{String,VecOrMat{<:Number}}}\n\nRead the specified blocks from a snapshot file.\n\nArguments\n\nfile_path::String: Path to the snapshot file.\nrequest::Dict{Symbol,Vector{String}}: The blocks to be read. It must have the shape cell/particle type -> [block, block, block].\n\nReturns\n\nA dictionary with the following shape: cell/particle type -> (block -> data of block).\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.readSnapHeader-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.readSnapHeader","text":"readSnapHeader(path::String)::SnapshotHeader\n\nRead the header of a snapshot file in the HDF5 format.\n\nnote: Note\nIf each snapshot is made of multiple files, the function will read the header of the first chunk.\n\nArguments\n\npath::String: Path to the snapshot file or folder.\n\nReturns\n\nA SnapshotHeader structure.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.readSnapshot-Tuple{Union{Missing, String}, Dict{Symbol, Vector{String}}}","page":"Data acquisition functions","title":"GalaxyInspector.readSnapshot","text":"readSnapshot(\n    path::Union{String,Missing},\n    request::Dict{Symbol,Vector{String}},\n)::Dict{Symbol,Dict{String,VecOrMat{<:Number}}}\n\nRead the specified blocks from a snapshot file or folder.\n\nArguments\n\npath::Union{String,Missing}: Path to the snapshot file or folder.\nrequest::Dict{Symbol,Vector{String}}: Which blocks will be read. It must have the shape cell/particle type -> [block, block, block].\n\nReturns\n\nA dictionary with the following shape: cell/particle type -> (block -> data of block).\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.readTemperature-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.readTemperature","text":"readTemperature(file_path::String)::Vector{<:Unitful.Temperature}\n\nCompute the temperature of the gas cells in a snapshot.\n\nArguments\n\nfile_path::String: Path to the snapshot file.\n\nReturns\n\nThe temperature of the gas cells.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.readTime-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.readTime","text":"readTime(path::String)::Float64\n\nRead the \"Time\" field in the header of a snapshot file.\n\nnote: Note\nIf each snapshot is made of multiple files, the function will only read the first file.\n\nArguments\n\npath::String: Path to the snapshot file or folder.\n\nReturns\n\nThe \"Time\" field in the header (for cosmological simulations it is the scale factor).\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.snapshotTypes-Tuple{Dict}","page":"Data acquisition functions","title":"GalaxyInspector.snapshotTypes","text":"snapshotTypes(data_dict::Dict)::Vector{Symbol}\n\nFind which cell/particle types are part of the keys of data_dict.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description).\n\nReturns\n\nA vector with the cell/particle types.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/data_acquisition/#GalaxyInspector.snapshotTypes-Tuple{String}","page":"Data acquisition functions","title":"GalaxyInspector.snapshotTypes","text":"snapshotTypes(path::String)::Vector{Symbol}\n\nFind which cell/particle types are part of the snapshot in path.\n\nnote: Note\nIf each snapshot is made of multiple files, the function will only check the first file.\n\nArguments\n\npath::String: Path to the snapshot file or folder.\n\nReturns\n\nA vector with the cell/particle types.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#Computation-of-characteristic-masses-and-mass-related-quantities","page":"Computation of characteristic masses and mass related quantities","title":"Computation of characteristic masses and mass related quantities","text":"These functions are used internally and none are exported. \n\nThey may depend on the particulars of the simulation code (e.g. internal units).\n\n","category":"section"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeAbundance-Tuple{Dict, Symbol, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeAbundance","text":"computeAbundance(\n    data_dict::Dict,\n    type::Symbol,\n    element::Symbol;\n    <keyword arguments>\n)::Vector{Float64}\n\nCompute the abundance of a given element in each cell/particle. The abundance is defined as n_X  n_H where n_X is the number of atoms of element X and n_H the number of hydrogen atoms.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of type:\nIf type == :stellar:\n:stellar => [\"MASS\", \"GME2\"]\nIf type == :gas:\n:gas => [\"MASS\", \"GMET\"]\ntype::Symbol: For which cell/particle type the abundance will be calculated. The possibilities are :stellar and :gas.\nelement::Symbol: Target element. The possibilities are the keys of ELEMENT_INDEX.\nsolar::Bool=false: If the result will be normalized to the solar abundance.\n\nReturns\n\nThe abundance of element in each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeClumpingFactor-Tuple{Dict, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeClumpingFactor","text":"computeClumpingFactor(data_dict::Dict, component::Symbol)::Float64\n\nCompute the clumping factor,\n\nC_rho = fraclangle rho^2 ranglelangle rho rangle^2  \n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component:\nIf component ∈ [:gas, :hydrogen, :helium]:\n:gas => [\"MASS\", \"RHO \"]\nIf component == :Z_gas:\n:gas => [\"MASS\", \"GZ  \", \"RHO \"]\nIf component ∈ [:ionized, :neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"RHO \"]\nIf component ∈ [:bratomic, :brmolecular]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"PRES\", \"RHO \"]\nIf component ∈ [:odeionized, :odeatomic, :odemetals, :odedust, :ode_neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"FRAC\", \"RHO \", \"GZ  \"]\nIf component ∈ [:odemolecular, :odestellar]:\n:gas => [\"MASS\", \"FRAC\", \"RHO \"]\ncomponent::Symbol: Target component. It can only be one of the gas elements of COMPONENTS.\n\nReturns\n\nThe clumping factor.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeClumpingFactor-Tuple{Vector{<:Number}}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeClumpingFactor","text":"computeClumpingFactor(density::Vector{<:Number})::Float64\n\nCompute the clumping factor,\n\nC_rho = fraclangle rho^2 ranglelangle rho rangle^2  \n\nArguments\n\ndensity::Vector{<:Number}: The density of the cells/particles.\n\nReturns\n\nThe clumping factor.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeDiskAccretion-Tuple{Dict, Dict, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeDiskAccretion","text":"computeDiskAccretion(\n    present_dd::Dict,\n    past_dd::Dict;\n    <keyword arguments>\n)::NTuple{3,Unitful.Mass}\n\nCompute the inflow, outflow, or net gain of mass for a given galactic disk, between two snapshots.\n\nnote: Note\nIt is assumed that the center of the disk is the origin.\n\nArguments\n\npresent_dd::Dict: Data dictionary, for the present snapshot (see makeDataDict for the canonical description). This function requires the following blocks to be present for every cell/particle that you want to be taken into account:\ncell/particle type => [\"POS \", \"ID  \", \"MASS\"]\n:group             => [\"GRCrit200\", \"GNsubs\", \"GPos\"]\n:subhalo           => [\"S_Pos\"]\n:tracer            => [\"PAID\", \"TRID\"]\npast_dd::Dict: Data dictionary, for the past snapshot (see makeDataDict for the canonical description). This function requires the following blocks to be present for every cell/particle that you want to be taken into account:\ncell/particle type => [\"POS \", \"ID  \", \"MASS\"]\n:group             => [\"GRCrit200\", \"GNsubs\", \"GPos\"]\n:subhalo           => [\"S_Pos\"]\n:tracer            => [\"PAID\", \"TRID\"]\ncomponent::Symbol: Component to compute the accreted mass for. The options are:\n:dark_matter -> Dark matter.\n:black_hole  -> Black holes.\n:gas         -> Gas.\n:stellar     -> Stars.\nmax_r::Unitful.Length=DISK_R: Radius of the disk.\nmax_z::Unitful.Length=5.0u\"kpc\": Half height of the disk.\ntracers::Bool=false: Whether to compute the accretion using tracer particles (true) or the actual component particles (false).\n\nReturns\n\nA tuple with three elements:\nThe net increase in mass.\nThe inflow mass.\nThe outflow mass.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeEfficiencyFF-Tuple{Dict, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeEfficiencyFF","text":"computeEfficiencyFF(data_dict::Dict, component::Symbol)::Vector{Float64}\n\nCompute the star formation efficiency per free-fall time, according to the definition in eq. 1 of Krumholz et al. (2012),\n\nepsilon_mathrmff = fract_mathrmfft_mathrmdep  \n\nwhere\n\nt_mathrmff = sqrtfrac3  pi32  G  rho  \n\nis the free-fall time, and\n\nt_mathrmdep = fracMdotM_star  \n\nis the depletion time. M and rho are the mass and density of the target gas phase, and dotM_star is the SFR.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component:\nIf `component == :stellar\n:stellar => [\"RHOC\", \"GMAS\", \"GSFR\"]\nIf component ∈ [:gas, :hydrogen, :helium]:\n:gas => [\"SFR \", \"MASS\", \"RHO \"]\nIf component == :Z_gas:\n:gas => [\"SFR \", \"MASS\", \"GZ  \", \"RHO \"]\nIf component ∈ [:ionized, :neutral]:\n:gas => [\"SFR \", \"MASS\", \"NH  \", \"NHP \", \"RHO \"]\nIf component ∈ [:bratomic, :brmolecular]:\n:gas => [\"SFR \", \"MASS\", \"NH  \", \"NHP \", \"PRES\", \"RHO \"]\nIf component ∈ [:odeionized, :odeatomic, :odemetals, :odedust, :ode_neutral]:\n:gas => [\"SFR \", \"MASS\", \"NH  \", \"NHP \", \"FRAC\", \"RHO \", \"GZ  \"]\nIf component ∈ [:odemolecular, :odestellar]:\n:gas => [\"SFR \", \"MASS\", \"FRAC\", \"RHO \"]\ncomponent::Symbol: Target component. It can only be one of the gas elements of COMPONENTS.\n\nReturns\n\nThe star formation efficiency per free-fall time.\n\nReferences\n\nM. R. Krumholz et al. (2012). A UNIVERSAL, LOCAL STAR FORMATION LAW IN GALACTIC CLOUDS, NEARBY GALAXIES, HIGH-REDSHIFT DISKS, AND STARBURSTS. The Astrophysical Journal, 745(1), 69. doi:10.1088/0004-637X/745/1/69\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeEfficiencyFF-Tuple{Vector{<:Union{Unitful.Quantity{T, 𝐌 𝐋^-3, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐋^-3, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐌 𝐓^-1, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌 𝐓^-1, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeEfficiencyFF","text":"computeEfficiencyFF(\n    densities::Vector{<:Unitful.Density},\n    masses::Vector{<:Unitful.Mass},\n    sfrs::Vector{<:Unitful.MassFlow},\n)::Vector{Float64}\n\nCompute the star formation efficiency per free-fall time, according to the definition in eq. 1 of Krumholz et al. (2012),\n\nepsilon_mathrmff = fract_mathrmfft_mathrmdep  \n\nwhere\n\nt_mathrmff = sqrtfrac3  pi32  G  rho  \n\nis the free-fall time, and\n\nt_mathrmdep = fracMdotM_star  \n\nis the depletion time. M and rho are the mass and density of the target gas phase, and dotM_star is the SFR.\n\nArguments\n\ndensities::Vector{<:Unitful.Density}: Densities of the cells.\nmasses::Vector{<:Unitful.Mass}: Masses of the cells.\nsfrs::Vector{<:Unitful.MassFlow}: The SFR associated to each cell.\n\nReturns\n\nThe star formation efficiency per free-fall time.\n\nReferences\n\nM. R. Krumholz et al. (2012). A UNIVERSAL, LOCAL STAR FORMATION LAW IN GALACTIC CLOUDS, NEARBY GALAXIES, HIGH-REDSHIFT DISKS, AND STARBURSTS. The Astrophysical Journal, 745(1), 69. doi:10.1088/0004-637X/745/1/69\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeElementMass-Tuple{Dict, Symbol, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeElementMass","text":"computeElementMass(\n    data_dict::Dict,\n    type::Symbol,\n    element::Symbol,\n)::Vector{<:Unitful.Mass}\n\nCompute the total mass of element in each cell/particle.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of type:\nIf type == :stellar:\n:stellar => [\"MASS\", \"GME2\"]\nIf type == :gas:\n:gas => [\"MASS\", \"GMET\"]\ntype::Symbol: For which cell/particle type the mass will be calculated. The possibilities are :stellar and :gas.\nelement::Symbol: Target element. The possibilities are the keys of ELEMENT_INDEX.\n\nReturns\n\nThe total mass of element in each cell/particle.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeFraction-Tuple{Dict, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeFraction","text":"computeFraction(data_dict::Dict, component::Symbol)::Vector{Float64}\n\nCompute the fraction of a given component in each cell/particle.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component:\nIf component == :Z_stellar\n:stellar => [\"GZ2 \"]\nIf component ∈ [:gas, :hydrogen, :helium]:\n:gas => [\"MASS\"]\nIf component == :Z_gas:\n:gas => [\"MASS\", \"GZ  \"]\nIf component ∈ [:ionized, :neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \"]\nIf component ∈ [:bratomic, :brmolecular]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"PRES\"]\nIf component ∈ [:odeionized, :odeatomic, :odemetals, :odedust, :ode_neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"FRAC\", \"RHO \", \"GZ  \"]\nIf component ∈ [:odemolecular, :odestellar]:\n:gas => [\"MASS\", \"FRAC\", \"RHO \"]\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nThe fraction of component in each cell/particle.\n\nReferences\n\nL. Blitz et al. (2006). The Role of Pressure in GMC Formation II: The H2-Pressure Relation. The Astrophysical Journal, 650(2), 933. doi:10.1086/505417\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeFractionWithin-Tuple{Vector{<:Number}, Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}, Tuple{Number, Number}}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeFractionWithin","text":"computeFractionWithin(\n    quantity::Vector{<:Number},\n    masses::Vector{<:Unitful.Mass},\n    qty_limits::Tuple{<:Number,<:Number},\n)::Float64\n\nCompute the fraction of the total mass \"contained\" within a given range of quantity.\n\nArguments\n\nquantity::Vector{<:Number}: Target quantity.\nmasses::Vector{<:Unitful.Mass}: Masses of the cells/particles.\nqty_limits::Tuple{<:Number,<:Number}: Range of the target quantity.\n\nReturns\n\nThe fraction of the total mass \"contained\" within a given range of quantity.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeGlobalAbundance-Tuple{Dict, Symbol, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeGlobalAbundance","text":"computeGlobalAbundance(\n    data_dict::Dict,\n    type::Symbol,\n    element::Symbol;\n    <keyword arguments>\n)::Float64\n\nCompute the total abundance of a given element, as n_X  n_H where n_X is the number of atoms of element X and n_H the number of hydrogen atoms.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of type:\nIf type == :stellar:\n:stellar => [\"MASS\", \"GME2\"]\nIf type == :gas:\n:gas => [\"MASS\", \"GMET\"]\ntype::Symbol: For which cell/particle type the abundance will be calculated. The possibilities are :stellar and :gas.\nelement::Symbol: Target element. The possibilities are the keys of ELEMENT_INDEX.\nsolar::Bool=false: If the result will be normalized to the solar abundance or not.\n\nReturns\n\nThe total abundance of element.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeMass-Tuple{Dict, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeMass","text":"computeMass(data_dict::Dict, component::Symbol)::Vector{<:Unitful.Mass}\n\nCompute the mass in each cell/particle of a given component.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component:\nIf component ∈ [:stellar, :darkmatter, :blackhole, :gas]:\ncomponent => [\"MASS\"]\nIf component == :Z_stellar\n:stellar => [\"MASS\", \"GZ2 \"]\nIf component ∈ [:hydrogen, :helium]:\n:gas => [\"MASS\"]\nIf component == :Z_gas:\n:gas => [\"MASS\", \"GZ  \"]\nIf component ∈ [:ionized, :neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \"]\nIf component ∈ [:bratomic, :brmolecular]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"PRES\"]\nIf component ∈ [:odeionized, :odeatomic, :odemetals, :odedust, :ode_neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"FRAC\", \"RHO \", \"GZ  \"]\nIf component ∈ [:odemolecular, :odestellar]:\n:gas => [\"MASS\", \"FRAC\", \"RHO \"]\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nThe mass of component in each cell/particle.\n\nReferences\n\nL. Blitz et al. (2006). The Role of Pressure in GMC Formation II: The H2-Pressure Relation. The Astrophysical Journal, 650(2), 933. doi:10.1086/505417\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeMassDensity-Tuple{Dict, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeMassDensity","text":"computeMassDensity(data_dict::Dict, component::Symbol)::Vector{<:Unitful.Density}\n\nCompute the mass density of a given gas component for each cell.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component:\nIf component ∈ [:gas, :hydrogen, :helium]:\n:gas => [\"MASS\", \"RHO \"]\nIf component == :Z_gas:\n:gas => [\"MASS\", \"GZ  \", \"RHO \"]\nIf component ∈ [:ionized, :neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"RHO \"]\nIf component ∈ [:bratomic, :brmolecular]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"PRES\", \"RHO \"]\nIf component ∈ [:odeionized, :odeatomic, :odemetals, :odedust, :ode_neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"FRAC\", \"RHO \", \"GZ  \"]\nIf component ∈ [:odemolecular, :odestellar]:\n:gas => [\"MASS\", \"FRAC\", \"RHO \"]\ncomponent::Symbol: Target component. It can only be one of the gas elements of COMPONENTS.\n\nReturns\n\nThe mass density of component for each cell.\n\nReferences\n\nL. Blitz et al. (2006). The Role of Pressure in GMC Formation II: The H2-Pressure Relation. The Astrophysical Journal, 650(2), 933. doi:10.1086/505417\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeMassHeight-Tuple{Matrix{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeMassHeight","text":"computeMassHeight(\n    positions::Matrix{<:Unitful.Length},\n    masses::Vector{<:Unitful.Mass};\n    <keyword arguments>\n)::Unitful.Length\n\nCompute the total height of a cylinder, of infinite radius, containing percent% of the total mass.\n\nArguments\n\npositions::Matrix{<:Unitful.Length}: Positions of the cells/particles. Each column is a cell/particle and each row a dimension.\nmasses::Vector{<:Unitful.Mass}: Masses of the cells/particles.\npercent::Float64=90.0: Target percentage of the total mass.\n\nReturns\n\nThe height containing percent% of the total mass.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeMassQty-Tuple{Vector{<:Number}, Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeMassQty","text":"computeMassQty(\n    quantity::Vector{<:Number},\n    masses::Vector{<:Unitful.Mass};\n    <keyword arguments>\n)::Number\n\nCompute the minimum value of quantity that \"contains\" percent% of the total mass.\n\nArguments\n\nquantity::Vector{<:Number}: Target quantity.\nmasses::Vector{<:Unitful.Mass}: Masses of the cells/particles.\npercent::Float64=90.0: Target percentage of the total mass.\n\nReturns\n\nThe minimum value of quantity that \"contains\" percent% of the total mass.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeMassRadius-Tuple{Matrix{<:Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Vector{<:Union{Unitful.Quantity{T, 𝐌, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐌, U}} where {L, S}} where {T, U}}}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeMassRadius","text":"computeMassRadius(\n    positions::Matrix{<:Unitful.Length},\n    masses::Vector{<:Unitful.Mass};\n    <keyword arguments>\n)::Unitful.Length\n\nCompute the radius containing percent% of the total mass.\n\nArguments\n\npositions::Matrix{<:Unitful.Length}: Positions of the cells/particles. Each column is a cell/particle and each row a dimension.\nmasses::Vector{<:Unitful.Mass}: Masses of the cells/particles.\npercent::Float64=90.0: Target percentage of the total mass.\n\nReturns\n\nThe radius containing percent% of the total mass.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeNumber-Tuple{Dict, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeNumber","text":"computeNumber(data_dict::Dict, component::Symbol)::Vector{Int64}\n\nCompute the number of a given component.\n\nnote: Note\nWhat number means changes depending on the component, see the comments in the code.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component:\nIf component ∈ [:stellar, :darkmatter, :blackhole, :gas]:\ncomponent => [\"MASS\"]\nIf component ∈ [:Z_stellar]:\n:stellar => [\"MASS\"]\nIf component ∈ [:hydrogen, :helium]:\n:gas => [\"MASS\"]\nIf component == :Z_gas:\n:gas => [\"MASS\", \"GZ  \"]\nIf component ∈ [:ionized, :neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \"]\nIf component ∈ [:bratomic, :brmolecular]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"PRES\"]\nIf component ∈ [:odeionized, :odeatomic, :odemetals, :odedust, :ode_neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"FRAC\", \"RHO \", \"GZ  \"]\nIf component ∈ [:odemolecular, :odestellar]:\n:gas => [\"MASS\", \"FRAC\", \"RHO \"]\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\n\nReturns\n\nThe number of component.\n\nReferences\n\nL. Blitz et al. (2006). The Role of Pressure in GMC Formation II: The H2-Pressure Relation. The Astrophysical Journal, 650(2), 933. doi:10.1086/505417\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeNumberDensity-Tuple{Dict, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeNumberDensity","text":"computeNumberDensity(data_dict::Dict, component::Symbol)::Vector{<:NumberDensity}\n\nCompute the number density of a given gas component for each cell.\n\nnote: Note\nWhat number density means changes depending on the component, see the comments in the code.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component:\nIf component ∈ [:gas, :hydrogen, :helium]:\n:gas => [\"MASS\", \"RHO \"]\nIf component == :Z_gas:\n:gas => [\"MASS\", \"GZ  \", \"RHO \"]\nIf component ∈ [:ionized, :neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"RHO \"]\nIf component ∈ [:bratomic, :brmolecular]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"PRES\", \"RHO \"]\nIf component ∈ [:odeionized, :odeatomic, :odemetals, :odedust, :ode_neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"FRAC\", \"RHO \", \"GZ  \"]\nIf component ∈ [:odemolecular, :odestellar]:\n:gas => [\"MASS\", \"FRAC\", \"RHO \"]\ncomponent::Symbol: Target component. It can only be one of the gas elements of COMPONENTS.\n\nReturns\n\nThe number density of component for each cell.\n\nReferences\n\nL. Blitz et al. (2006). The Role of Pressure in GMC Formation II: The H2-Pressure Relation. The Astrophysical Journal, 650(2), 933. doi:10.1086/505417\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.computeVirialAccretion-Tuple{Dict, Dict, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.computeVirialAccretion","text":"computeVirialAccretion(\n    present_dd::Dict,\n    past_dd::Dict;\n    <keyword arguments>\n)::NTuple{3,Unitful.Mass}\n\nCompute the inflow, outflow, or net gain of mass for a given halo virial radius (R_200), between two snapshots.\n\nArguments\n\npresent_dd::Dict: Data dictionary, for the present snapshot (see makeDataDict for the canonical description). This function requires the following blocks to be present for every cell/particle that you want to be taken into account:\ncell/particle type => [\"POS \", \"ID  \", \"MASS\"]\n:group             => [\"GRCrit200\", \"GNsubs\", \"GPos\"]\n:subhalo           => [\"S_Pos\"]\n:tracer            => [\"PAID\", \"TRID\"]\npast_dd::Dict: Data dictionary, for the past snapshot (see makeDataDict for the canonical description). This function requires the following blocks to be present for every cell/particle that you want to be taken into account:\ncell/particle type => [\"POS \", \"ID  \", \"MASS\"]\n:group             => [\"GRCrit200\", \"GNsubs\", \"GPos\"]\n:subhalo           => [\"S_Pos\"]\n:tracer            => [\"PAID\", \"TRID\"]\ncomponent::Symbol: Component to compute the accreted mass for. The options are:\n:dark_matter -> Dark matter.\n:black_hole  -> Black holes.\n:gas         -> Gas.\n:stellar     -> Stars.\nhalo_idx::Int=1: Index of the target halo (FoF group). Starts at 1.\ntracers::Bool=false: Whether to compute the accretion using tracer particles (true) or the actual component particles (false).\n\nReturns\n\nA tuple with three elements:\nThe net increase in mass.\nThe inflow mass.\nThe outflow mass.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.density2DProjection-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.density2DProjection","text":"density2DProjection(\n    data_dict::Dict,\n    grid::CubicGrid,\n    component::Symbol,\n    field_type::Symbol;\n    <keyword arguments>\n)::Matrix{<:SurfaceDensity}\n\nSample the 3D density field of a given quantity using a cubic grid and then project the field into a given plane.\n\nnote: Note\nIf the source of the field is a set of particles, a simple 3D histogram is used. If instead they are Voronoi cells, the density of the cell that intersects each voxel is used.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component:\nIf component ∈ [:stellar, :darkmatter, :blackhole, :gas]:\ncomponent => [\"MASS\", \"POS \", \"RHO \"]\nIf component == :Z_stellar\n:stellar => [\"MASS\", \"GZ2 \", \"POS \", \"RHO \"]\nIf component ∈ [:hydrogen, :helium]:\n:gas => [\"MASS\", \"POS \", \"RHO \"]\nIf component == :Z_gas:\n:gas => [\"MASS\", \"GZ  \", \"POS \", \"RHO \"]\nIf component ∈ [:ionized, :neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"POS \", \"RHO \"]\nIf component ∈ [:bratomic, :brmolecular]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"PRES\", \"POS \", \"RHO \"]\nIf component ∈ [:odeionized, :odeatomic, :odemetals, :odedust, :ode_neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"FRAC\", \"RHO \", \"GZ  \", \"POS \"]\nIf component ∈ [:odemolecular, :odestellar]:\n:gas => [\"MASS\", \"FRAC\", \"RHO \", \"POS \"]\ngrid::CubicGrid: Cubic grid.\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\nfield_type::Symbol: If the source of the field are :particles or Voronoi :cells.\nprojection_plane::Symbol=:xy: Projection plane. The options are :xy, :xz, and :yz.\nm_unit::Unitful.Units=u\"Msun\": Mass unit.\nl_unit::Unitful.Units=u\"kpc\": Length unit.\nempty_nan::Bool=true: If NaN will be put into empty bins, 0 is used otherwise.\n\nReturns\n\nA 2D array with the surface density at each point of the projected 3D grid.\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/compute_quantities/masses/#GalaxyInspector.density3DProjection-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol, Symbol}","page":"Computation of characteristic masses and mass related quantities","title":"GalaxyInspector.density3DProjection","text":"density3DProjection(\n    data_dict::Dict,\n    grid::CubicGrid,\n    component::Symbol,\n    field_type::Symbol;\n    <keyword arguments>\n)::Array{Float64,3}\n\nSample the 3D density field of a given quantity using a cubic grid.\n\nnote: Note\nIf the source of the field is a set of particles, a simple 3D histogram is used. If instead they are Voronoi cells, the density of the cell that intersects each voxel is used.\n\nArguments\n\ndata_dict::Dict: Data dictionary (see makeDataDict for the canonical description). This function requires the following blocks to be present, depending on the value of component:\nIf component ∈ [:stellar, :darkmatter, :blackhole, :gas]:\ncomponent => [\"MASS\", \"POS \", \"RHO \"]\nIf component == :Z_stellar\n:stellar => [\"MASS\", \"GZ2 \", \"POS \", \"RHO \"]\nIf component ∈ [:hydrogen, :helium]:\n:gas => [\"MASS\", \"POS \", \"RHO \"]\nIf component == :Z_gas:\n:gas => [\"MASS\", \"GZ  \", \"POS \", \"RHO \"]\nIf component ∈ [:ionized, :neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"POS \", \"RHO \"]\nIf component ∈ [:bratomic, :brmolecular]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"PRES\", \"POS \", \"RHO \"]\nIf component ∈ [:odeionized, :odeatomic, :odemetals, :odedust, :ode_neutral]:\n:gas => [\"MASS\", \"NH  \", \"NHP \", \"FRAC\", \"RHO \", \"GZ  \", \"POS \"]\nIf component ∈ [:odemolecular, :odestellar]:\n:gas => [\"MASS\", \"FRAC\", \"RHO \", \"POS \"]\ngrid::CubicGrid: Cubic grid.\ncomponent::Symbol: Target component. It can only be one of the elements of COMPONENTS.\nfield_type::Symbol: If the source of the field are :particles or Voronoi :cells.\nm_unit::Unitful.Units=u\"Msun\": Mass unit.\nl_unit::Unitful.Units=u\"kpc\": Length unit.\nempty_nan::Bool=true: If NaN will be put into empty bins, 0 is used otherwise.\n\nReturns\n\nA 3D array with the density at each point of the 3D grid.\n\n\n\n\n\n","category":"method"}]
}
