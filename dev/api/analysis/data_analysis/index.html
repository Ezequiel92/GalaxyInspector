<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data analysis functions · GalaxyInspector.jl</title><meta name="title" content="Data analysis functions · GalaxyInspector.jl"/><meta property="og:title" content="Data analysis functions · GalaxyInspector.jl"/><meta property="twitter:title" content="Data analysis functions · GalaxyInspector.jl"/><meta name="description" content="Documentation for GalaxyInspector.jl."/><meta property="og:description" content="Documentation for GalaxyInspector.jl."/><meta property="twitter:description" content="Documentation for GalaxyInspector.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/GI-docs.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="GalaxyInspector.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">GalaxyInspector.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../function_index/">Function Index</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../plotting/pipelines/">Pipeline functions</a></li><li><a class="tocitem" href="../../plotting/convenience/">Convenience functions</a></li><li><a class="tocitem" href="../../plotting/post_processing/">Post processing functions</a></li><li><a class="tocitem" href="../../constants/globals/">Global constants</a></li><li><a class="tocitem" href="../../constants/quantities/">Quantities</a></li><li><a class="tocitem" href="../../constants/arepo/">Arepo constants</a></li><li class="is-active"><a class="tocitem" href>Data analysis functions</a></li><li><a class="tocitem" href="../data_acquisition/">Data acquisition functions</a></li><li><a class="tocitem" href="../compute_quantities/energies/">Computation of energy related quantities</a></li><li><a class="tocitem" href="../compute_quantities/masses/">Computation of characteristic masses and mass related quantities</a></li><li><a class="tocitem" href="../compute_quantities/positions/">Computation of characteristic positions</a></li><li><a class="tocitem" href="../compute_quantities/sfm/">Compute derived code quantities for our star formation model</a></li><li><a class="tocitem" href="../compute_quantities/times/">Computation of time related quantities</a></li><li><a class="tocitem" href="../compute_quantities/velocities/">Computation of characteristic velocities and momentums</a></li><li><a class="tocitem" href="../compute_quantities/aggregators/">Aggregator function</a></li><li><a class="tocitem" href="../../auxiliary_functions/histograms/">Histogram utilities</a></li><li><a class="tocitem" href="../../auxiliary_functions/grid/">Grid utilities</a></li><li><a class="tocitem" href="../../auxiliary_functions/plotting/">Plotting utilities</a></li><li><a class="tocitem" href="../../auxiliary_functions/other/">Auxiliary functions</a></li><li><a class="tocitem" href="../filters/">Filter functions</a></li><li><a class="tocitem" href="../tracers/">Tracer functions</a></li><li><a class="tocitem" href="../transformations/">Coordinate transformation functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Data analysis functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data analysis functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Ezequiel92/GalaxyInspector" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Ezequiel92/GalaxyInspector/blob/main/docs/src/api/analysis/data_analysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-analysis-functions"><a class="docs-heading-anchor" href="#Data-analysis-functions">Data analysis functions</a><a id="Data-analysis-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Data-analysis-functions" title="Permalink"></a></h1><p>These functions are used internally and none are exported. </p><p>They may depend on the particulars of the simulation code (e.g. internal units).</p><p>These functions read the data generated by the <a href="https://ezequiel92.github.io/GalaxyInspector/dev/api/analysis/data_acquisition/">data acquisition</a> functions, and produce the values that will be plotted.</p><h3 id="Signature-for-the-[plotSnapshot](@ref)-function"><a class="docs-heading-anchor" href="#Signature-for-the-[plotSnapshot](@ref)-function">Signature for the <a href="../../plotting/pipelines/#GalaxyInspector.plotSnapshot-Tuple{Vector{String}, Dict{Symbol, Vector{String}}, Vector{&lt;:Function}}"><code>plotSnapshot</code></a> function</a><a id="Signature-for-the-[plotSnapshot](@ref)-function-1"></a><a class="docs-heading-anchor-permalink" href="#Signature-for-the-[plotSnapshot](@ref)-function" title="Permalink"></a></h3><pre><code class="language-julia hljs">  da_function(data_dict, args...; kwargs...) -&gt; (processed_data, ...)</code></pre><p>where:</p><ul><li><code>data_dict::Dict</code></li><li><code>processed_data::Union{VecOrMat{&lt;:Number},Nothing}</code></li></ul><p>A data analysis functions for the <a href="https://ezequiel92.github.io/GalaxyInspector/dev/api/plotting/pipelines/">pipeline</a> <a href="../../plotting/pipelines/#GalaxyInspector.plotSnapshot-Tuple{Vector{String}, Dict{Symbol, Vector{String}}, Vector{&lt;:Function}}"><code>plotSnapshot</code></a> must take a dictionary with the following shape:</p><ul><li><code>:sim_data</code>          -&gt; <code>::Simulation</code> (see <a href="https://ezequiel92.github.io/GalaxyInspector/dev/api/constants/globals/#GalaxyInspector.Simulation"><code>Simulation</code></a>).</li><li><code>:snap_data</code>         -&gt; <code>::Snapshot</code> (see <a href="https://ezequiel92.github.io/GalaxyInspector/dev/api/constants/globals/#GalaxyInspector.Snapshot"><code>Snapshot</code></a>).</li><li><code>:gc_data</code>           -&gt; <code>::GroupCatalog</code> (see <a href="https://ezequiel92.github.io/GalaxyInspector/dev/api/constants/globals/#GalaxyInspector.GroupCatalog"><code>GroupCatalog</code></a>).</li><li><code>cell/particle type</code> -&gt; (<code>block name</code> -&gt; data for <code>block name</code>, <code>block name</code> -&gt; data of <code>block name</code>, ...).</li><li><code>cell/particle type</code> -&gt; (<code>block name</code> -&gt; data for <code>block name</code>, <code>block name</code> -&gt; data of <code>block name</code>, ...).</li><li><code>cell/particle type</code> -&gt; (<code>block name</code> -&gt; data for <code>block name</code>, <code>block name</code> -&gt; data of <code>block name</code>, ...).<ul><li>...</li></ul></li><li><code>groupcat type</code>      -&gt; (<code>block name</code> -&gt; data for <code>block name</code>, <code>block name</code> -&gt; data of <code>block name</code>, ...).</li><li><code>groupcat type</code>      -&gt; (<code>block name</code> -&gt; data for <code>block name</code>, <code>block name</code> -&gt; data of <code>block name</code>, ...).</li><li><code>groupcat type</code>      -&gt; (<code>block name</code> -&gt; data for <code>block name</code>, <code>block name</code> -&gt; data of <code>block name</code>, ...).</li><li>...</li></ul><p>and return one or more vectors or matrices with the processed data (see <a href="../../plotting/pipelines/#GalaxyInspector.plotSnapshot-Tuple{Vector{String}, Dict{Symbol, Vector{String}}, Vector{&lt;:Function}}"><code>plotSnapshot</code></a> for specifics). It should return <code>nothing</code> if the input data has some problem that prevents computation (e.g. it is empty).</p><h3 id="Signature-for-the-[plotTimeSeries](@ref)-function"><a class="docs-heading-anchor" href="#Signature-for-the-[plotTimeSeries](@ref)-function">Signature for the <a href="../../plotting/pipelines/#GalaxyInspector.plotTimeSeries-Tuple{Vector{String}, Vector{&lt;:Function}}"><code>plotTimeSeries</code></a> function</a><a id="Signature-for-the-[plotTimeSeries](@ref)-function-1"></a><a class="docs-heading-anchor-permalink" href="#Signature-for-the-[plotTimeSeries](@ref)-function" title="Permalink"></a></h3><pre><code class="language-julia hljs">  da_function(sim_data, args...; kw_args...) -&gt; (processed_data_x, processed_data_y)</code></pre><p>where:</p><ul><li><code>sim_data::Simulation</code>, see <a href="https://ezequiel92.github.io/GalaxyInspector/dev/api/constants/globals/#GalaxyInspector.Simulation"><code>Simulation</code></a></li><li><code>processed_data_x::Vector{&lt;:Number}</code></li><li><code>processed_data_y::Vector{&lt;:Number}</code></li></ul><p>A data analysis functions for the <a href="https://ezequiel92.github.io/GalaxyInspector/dev/api/plotting/pipelines/">pipeline</a> <a href="../../plotting/pipelines/#GalaxyInspector.plotTimeSeries-Tuple{Vector{String}, Vector{&lt;:Function}}"><code>plotTimeSeries</code></a> must take a <a href="https://ezequiel92.github.io/GalaxyInspector/dev/api/constants/globals/#GalaxyInspector.Simulation"><code>Simulation</code></a> struct, and return two vectors. It should return <code>nothing</code> if the input data has some problem that prevents computation (e.g. is empty).</p><hr/><article><details class="docstring" open="true"><summary id="GalaxyInspector.daBandProfile-Tuple{Dict, Symbol, GalaxyInspector.LinearGrid}"><a class="docstring-binding" href="#GalaxyInspector.daBandProfile-Tuple{Dict, Symbol, GalaxyInspector.LinearGrid}"><code>GalaxyInspector.daBandProfile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daBandProfile(
    data_dict::Dict,
    quantity::Symbol,
    grid::LinearGrid;
    &lt;keyword arguments&gt;
)::Union{
    Tuple{Vector{&lt;:Unitful.Length},Vector{&lt;:Number},Vector{&lt;:Number},Vector{&lt;:Number}},
    Tuple{Vector{&lt;:Unitful.Length},Vector{&lt;:Number},Vector{&lt;:Number}},
    Nothing,
}</code></pre><p>Compute a profile with uncertainty bands.</p><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>quantity::Symbol</code>: Target quantity. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a>.</li><li><code>grid::LinearGrid</code>: Linear grid.</li><li><code>flat::Bool=true</code>: If the profile will be 2D (rings), or 3D (spherical shells).</li><li><code>density::Bool=false</code>: If the profile will be of the density of <code>quantity</code>.</li><li><code>ylog::Bool=false</code>: If true, returns the profile of <span>$\log_{10}$</span>(<code>quantity</code>).</li><li><code>error_bar::Bool=false</code>: If the returned values will be compatible with <code>band!</code> (default) or with <code>errorbars!</code>.</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with three elements if <code>error_bar</code> = false:</p><ul><li>A vector with the position of each ring or spherical shells.</li><li>A vector with the &quot;low&quot; value of <code>quantity</code> in each each ring or spherical shells.</li><li>A vector with the &quot;high&quot; value of <code>quantity</code> in each each ring or spherical shells.</li></ul></li><li><p>Or a tuple with four elements if <code>error_bar</code> = true:</p><ul><li>A vector with the position of each ring or spherical shells.</li><li>A vector with the central value of <code>quantity</code> in each each ring or spherical shells.</li><li>A vector with the &quot;low&quot; error of <code>quantity</code> in each each ring or spherical shells.</li><li>A vector with the &quot;high&quot; error of <code>quantity</code> in each each ring or spherical shells.</li></ul><p>It returns <code>nothing</code> if any of the necessary quantities are missing.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L507-L548">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daBarGasFractions-Tuple{Dict, Symbol, GalaxyInspector.LinearGrid}"><a class="docstring-binding" href="#GalaxyInspector.daBarGasFractions-Tuple{Dict, Symbol, GalaxyInspector.LinearGrid}"><code>GalaxyInspector.daBarGasFractions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daBarGasFractions(
    data_dict::Dict,
    quantity::Symbol,
    grid::LinearGrid;
    &lt;keyword arguments&gt;
)::Union{NTuple{2,Vector{&lt;:Number}},Nothing}</code></pre><p>Compute a bar plot, where the bins are for a given gas <code>quantity</code> and the heights are the corresponding gas fractions.</p><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>quantity::Symbol</code>: Target quantity. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a> with the cell/particle type <code>:gas</code>.</li><li><code>grid::LinearGrid</code>: Linear grid.</li><li><code>components::Vector{Symbol}=[:ode_ionized, :ode_atomic, :ode_cold]</code>: List of gas components to be considered. The fractions will be normalized to this list of components. See <a href="../../constants/quantities/#GalaxyInspector.COMPONENTS"><code>COMPONENTS</code></a> for options.</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with the two elements required by <code>barplot!</code> from <a href="https://docs.makie.org/stable/">Makie</a>:</p><ul><li>A vector with the index of each bar.</li><li>A vector with the height of each bar.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L1055-L1079">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daCPUtxt-Tuple{GalaxyInspector.Simulation, String, Symbol, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daCPUtxt-Tuple{GalaxyInspector.Simulation, String, Symbol, Symbol}"><code>GalaxyInspector.daCPUtxt</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daCPUtxt(
    sim_data::Simulation,
    target::String,
    x_quantity::Symbol,
    y_quantity::Symbol;
    &lt;keyword arguments&gt;
)::NTuple{2,Vector{&lt;:Number}}</code></pre><p>Compute the evolution of a measured quantity in the <code>cpu.txt</code> file, for a given <code>target</code> process.</p><p><strong>Arguments</strong></p><ul><li><p><code>sim_data::Simulation</code>: The <a href="../../constants/globals/#GalaxyInspector.Simulation"><code>Simulation</code></a> struct for the target simulation.</p></li><li><p><code>target::String</code>: Target process (e.g. &quot;total&quot;).</p></li><li><p><code>x_quantity::Symbol</code>: Quantity for the x axis. The options are:</p><ul><li><code>:time_step</code>              -&gt; Time step.</li><li><code>:physical_time</code>          -&gt; Physical time since the Big Bang.</li><li><code>:clock_time_s</code>           -&gt; Clock time duration of the time step in seconds.</li><li><code>:clock_time_percent</code>     -&gt; Clock time duration of the time step as a percentage.</li><li><code>:tot_clock_time_s</code>       -&gt; Total clock time in seconds.</li><li><code>:tot_clock_time_percent</code> -&gt; Total clock time as a percentage.</li></ul></li><li><p><code>y_quantity::Symbol</code>: Quantity for the y axis. The options are:</p><ul><li><code>:time_step</code>              -&gt; Time step.</li><li><code>:physical_time</code>          -&gt; Physical time since the Big Bang.</li><li><code>:clock_time_s</code>           -&gt; Clock time duration of the time step in seconds.</li><li><code>:clock_time_percent</code>     -&gt; Clock time duration of the time step as a percentage.</li><li><code>:tot_clock_time_s</code>       -&gt; Total clock time in seconds.</li><li><code>:tot_clock_time_percent</code> -&gt; Total clock time as a percentage.</li></ul></li><li><p><code>y_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for <code>y_quantity</code>, if you want to apply <span>$\log_{10}$</span> to the <code>y_quantity</code>. If set to <code>nothing</code>, the data from <code>cpu.txt</code> is left as is.</p></li><li><p><code>smooth::Int=0</code>: The result will be smoothed out using <code>smooth</code> bins. Set it to 0 if you want no smoothing.</p></li></ul><p><strong>Returns</strong></p><ul><li><p>A Tuple with two elements:</p><ul><li>A Vector with the time series of <code>x_quantity</code>.</li><li>A Vector with the time series of <code>y_quantity</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L2502-L2542">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daClumpingFactor-Tuple{Dict, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daClumpingFactor-Tuple{Dict, Symbol}"><code>GalaxyInspector.daClumpingFactor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daClumpingFactor(
    data_dict::Dict,
    component::Symbol;
    &lt;keyword arguments&gt;
)::Tuple{Vector{&lt;:Number},Vector{Float64}}</code></pre><p>Compute the clumping factor (<span>$C_\rho$</span>), for the number density of <code>component</code>, at different volume scales.</p><p class="math-container">\[C_\rho = \frac{\langle n^2 \rangle}{\langle n \rangle^2} \, ,\]</p><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>component::Symbol</code>: Target component. It can only be one of the elements of <a href="../../constants/quantities/#GalaxyInspector.COMPONENTS"><code>COMPONENTS</code></a> with cell/partcile type :gas.</li><li><code>n_neighbors::Int=32</code>: Number of neighbors.</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li><li><code>x_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for the volume, if you want to apply <span>$\log_{10}$</span> to the volume. If set to <code>nothing</code>, the volume is left as is.</li><li><code>y_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for the clumping factor, if you want to apply <span>$\log_{10}$</span> to the clumping factor<code>. If set to</code>nothing`, the clumping factor is left as is.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with two elements:</p><ul><li>A vector with the the volumes.</li><li>A vector with the clumping factors.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L3312-L3340">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daClumpingFactorProfile-Tuple{Dict, Symbol, GalaxyInspector.LinearGrid}"><a class="docstring-binding" href="#GalaxyInspector.daClumpingFactorProfile-Tuple{Dict, Symbol, GalaxyInspector.LinearGrid}"><code>GalaxyInspector.daClumpingFactorProfile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daClumpingFactorProfile(
    data_dict::Dict,
    component::Symbol,
    grid::LinearGrid;
    &lt;keyword arguments&gt;
)::Tuple{Vector{&lt;:Unitful.Length},Vector{Float64}}</code></pre><p>Compute a clumping factor (<span>$C_\rho$</span>) profile, for the number density of <code>component</code>.</p><p class="math-container">\[C_\rho = \frac{\langle n^2 \rangle}{\langle n \rangle^2} \, ,\]</p><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>component::Symbol</code>: Target component. It can only be one of the elements of <a href="../../constants/quantities/#GalaxyInspector.COMPONENTS"><code>COMPONENTS</code></a> with cell/partcile type :gas.</li><li><code>grid::LinearGrid</code>: Linear grid.</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with two elements:</p><ul><li>A vector with the central position of each bin.</li><li>A vector with the clumping factors.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L3417-L3444">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daDensity2DProjection-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daDensity2DProjection-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol, Symbol}"><code>GalaxyInspector.daDensity2DProjection</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daDensity2DProjection(
    data_dict::Dict,
    grid::CubicGrid,
    component::Symbol,
    field_type::Symbol;
    &lt;keyword arguments&gt;
)::Tuple{Vector{&lt;:Unitful.Length},Vector{&lt;:Unitful.Length},VecOrMat{Float64}}</code></pre><p>Project a 3D mass density field into a given plane.</p><div class="admonition is-info" id="Note-18994029a563c28"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-18994029a563c28" title="Permalink"></a></header><div class="admonition-body"><p>If the source of the field are particles, a simple 3D histogram is used. If they are Voronoi cells, the density of the cells that cross the line of sight of each pixel are added up.</p></div></div><p><strong>Arguments</strong></p><ul><li><p><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</p></li><li><p><code>grid::CubicGrid</code>: Cubic grid.</p></li><li><p><code>component::Symbol</code>: Target component. It can only be one of the elements of <a href="../../constants/quantities/#GalaxyInspector.COMPONENTS"><code>COMPONENTS</code></a>.</p></li><li><p><code>field_type::Symbol</code>: If the field is made up of <code>:particles</code> or Voronoi <code>:cells</code>.</p></li><li><p><code>projection_plane::Symbol=:xy</code>: Projection plane. The options are <code>:xy</code>, <code>:xz</code>, and <code>:yz</code>.</p></li><li><p><code>reduce_grid::Symbol=:square</code>: Type of 2D grid to do the final projection. The options are:</p><ul><li><code>:square</code>    -&gt; The density distribution will be projected into a regular square grid, with a resolution <code>reduce_factor</code> times lower than <code>grid</code>. <code>reduce_factor</code> = 1 means no reduction in resolution.</li><li><code>:circular</code> -&gt; The density distribution will be projected into a flat circular grid, formed by a series of <code>reduce_factor</code> concentric rings. <code>reduce_factor</code> = 1 means that the result will be a single point. Note that this behaves in the opposite way than <code>reduce_grid</code> = :square.</li><li><code>:log_circular</code> -&gt; The density distribution will be projected into a flat circular grid, formed by a series of <code>reduce_factor</code> concentric logarithmic rings. The first bin starts at 1e-3 of the radius. <code>reduce_factor</code> = 1 means that the result will be a single point. Note that this behaves in the opposite way than <code>reduce_grid</code> = :square.</li></ul></li><li><p><code>reduce_factor::Int=1</code>: Factor by which the resolution of the result will be reduced. This will be applied after the density projection. If <code>reduce_grid</code> = :square, the new values will be computed averaging the values of neighboring pixels. <code>reduce_factor</code> has to divide the size of <code>grid</code> exactly. If <code>reduce_grid</code> = :circular, the new values will be computed averaging the values of the pixels the fall within each of the <code>reduce_factor</code> concentric rings.</p></li><li><p><code>mmap_path::String=&quot;./&quot;</code>: Path to store the memory-mapped file if needed (for matrices larger than <a href="../../constants/globals/#GalaxyInspector.MMAP_THRESHOLD"><code>MMAP_THRESHOLD</code></a>).</p></li><li><p><code>m_unit::Unitful.Units=u&quot;Msun&quot;</code>: Mass unit.</p></li><li><p><code>l_unit::Unitful.Units=u&quot;pc&quot;</code>: Length unit.</p></li><li><p><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with three elements:</p><ul><li>A vector with the x coordinates of the grid.</li><li>A vector with the y coordinates of the grid.</li><li>A matrix or vector with the <span>$\log_{10}$</span> of the density at each bin of the 2D grid.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L1268-L1308">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daDiskAccretion-Tuple{GalaxyInspector.Simulation, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daDiskAccretion-Tuple{GalaxyInspector.Simulation, Symbol}"><code>GalaxyInspector.daDiskAccretion</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daDiskAccretion(
    sim_data::Simulation;
    &lt;keyword arguments&gt;
)::NTuple{2,Vector{&lt;:Number}}</code></pre><p>Compute the evolution of the accreted mass into a given galactic disc.</p><p><strong>Arguments</strong></p><ul><li><p><code>sim_data::Simulation</code>: The <a href="../../constants/globals/#GalaxyInspector.Simulation"><code>Simulation</code></a> struct for the target simulation.</p></li><li><p><code>component::Symbol</code>: Component to compute the accreted mass for. The options are:</p><ul><li><code>:dark_matter</code> -&gt; Dark matter.</li><li><code>:black_hole</code>  -&gt; Black holes.</li><li><code>:gas</code>         -&gt; Gas.</li><li><code>:stellar</code>     -&gt; Stars.</li><li><code>:all</code>         -&gt; All the matter.</li></ul></li><li><p><code>flux_direction::Symbol=:net</code>: What flux direction will be plotted. The options are:</p><ul><li><code>:net</code>     -&gt; Net accreted mass.</li><li><code>:inflow</code>  -&gt; Inflow mass only.</li><li><code>:outflow</code> -&gt; Outflow mass only.</li></ul></li><li><p><code>max_r::Unitful.Length=DISK_R</code>: Radius of the disk.</p></li><li><p><code>max_z::Unitful.Length=5.0u&quot;kpc&quot;</code>: Half height of the disk.</p></li><li><p><code>trans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box</code>: How to translate and rotate the cells/particles, before filtering with <code>filter_mode</code>. For options see <a href="../transformations/#GalaxyInspector.selectTransformation-Tuple{Symbol, Dict{Symbol, Vector{String}}}"><code>selectTransformation</code></a>.</p></li><li><p><code>trace::Symbol=:automatic</code>: How to trace the mass. The option are:</p><ul><li><code>:automatic</code> -&gt; Automatically decide whether to use tracers or not. It will use tracers for the :gas component, and the particles for every other component.</li><li><code>:tracers</code>   -&gt; Use tracers to compute the mass flux.</li><li><code>:particles</code> -&gt; Use the particles/cells directly to compute the mass flux.</li></ul></li><li><p><code>y_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for integrated mass flux, if you want to apply <span>$\log_{10}$</span> to it. If set to <code>nothing</code>, the data from <a href="../compute_quantities/masses/#GalaxyInspector.computeDiskAccretion-Tuple{Dict, Dict, Symbol}"><code>computeDiskAccretion</code></a> is left as is.</p></li><li><p><code>smooth::Int=0</code>: The time series will be smoothed out using <code>smooth</code> bins. Set it to 0 if you want no smoothing.</p></li><li><p><code>show_progress::Bool=true</code>: If a progress bar will be shown.</p></li></ul><p><strong>Returns</strong></p><ul><li><p>A Tuple with two elements:</p><ul><li>A Vector with the physical times.</li><li>A Vector with the accreted mass at each time.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L2921-L2962">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daEvolution-Tuple{GalaxyInspector.Simulation, Dict{Symbol, Vector{String}}, Tuple{Function, Function}}"><a class="docstring-binding" href="#GalaxyInspector.daEvolution-Tuple{GalaxyInspector.Simulation, Dict{Symbol, Vector{String}}, Tuple{Function, Function}}"><code>GalaxyInspector.daEvolution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daEvolution(
    sim_data::Simulation,
    qty_request::Dict{Symbol,Vector{String}},
    integration_functions::NTuple{2,Function};
    &lt;keyword arguments&gt;
)::NTuple{2,Vector{&lt;:Number}}</code></pre><p>Compute the time series of two quantities, using the provided integration functions to compute their values at each time.</p><div class="admonition is-info" id="Note-9352f6b830b21fab"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9352f6b830b21fab" title="Permalink"></a></header><div class="admonition-body"><p>The log10 operation, if requested, is applied after the integration of the quantities.</p></div></div><p><strong>Arguments</strong></p><ul><li><p><code>sim_data::Simulation</code>: The <a href="../../constants/globals/#GalaxyInspector.Simulation"><code>Simulation</code></a> struct for the target simulation.</p></li><li><p><code>qty_request::Dict{Symbol,Vector{String}}</code>: Request dictionary for both quantities.</p></li><li><p><code>integration_functions::NTuple{2,Function}</code>: Functions to compute the integral value of the x and y quantities at a given time. The functions must have the signature:</p><p><code>integration_functions(data_dict::Dict)::Number</code></p><p>where</p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li></ul></li><li><p><code>trans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box</code>: How to translate and rotate the cells/particles, before filtering with <code>filter_mode</code>. For options see <a href="../transformations/#GalaxyInspector.selectTransformation-Tuple{Symbol, Dict{Symbol, Vector{String}}}"><code>selectTransformation</code></a>.</p></li><li><p><code>filter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all</code>: Which cells/particles will be selected. For options see <a href="../filters/#GalaxyInspector.selectFilter-Tuple{Symbol, Dict{Symbol, Vector{String}}}"><code>selectFilter</code></a>.</p></li><li><p><code>extra_filter::Function=filterNothing</code>: Filter function to be applied after <code>trans_mode</code> and <code>filter_mode</code> are applied. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</p></li><li><p><code>ff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}()</code>: Request dictionary for <code>extra_filter</code>.</p></li><li><p><code>x_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for <code>x_quantity</code>, if you want to apply <span>$\log_{10}$</span> to the <code>x_quantity</code>. If set to <code>nothing</code>, the data from <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a> is left as is.</p></li><li><p><code>y_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for <code>y_quantity</code>, if you want to apply <span>$\log_{10}$</span> to the <code>y_quantity</code>. If set to <code>nothing</code>, the data from <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a> is left as is.</p></li><li><p><code>smooth::Int=0</code>: The result of <code>integration_functions</code> will be smoothed out using <code>smooth</code> bins. Set it to 0 if you want no smoothing.</p></li><li><p><code>cumulative::Bool=false</code>: If the <code>y_quantity</code> will be accumulated or not.</p></li><li><p><code>show_progress::Bool=true</code>: If a progress bar will be shown.</p></li></ul><p><strong>Returns</strong></p><ul><li><p>A Tuple with two elements:</p><ul><li>A Vector with the time series of <code>x_quantity</code>.</li><li>A Vector with the time series of <code>y_quantity</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L2190-L2231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daEvolution-Tuple{GalaxyInspector.Simulation, Symbol, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daEvolution-Tuple{GalaxyInspector.Simulation, Symbol, Symbol}"><code>GalaxyInspector.daEvolution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daEvolution(
    sim_data::Simulation,
    x_quantity::Symbol,
    y_quantity::Symbol;
    &lt;keyword arguments&gt;
)::NTuple{2,Vector{&lt;:Number}}</code></pre><p>Compute the time series of two quantities, using <a href="../compute_quantities/aggregators/#GalaxyInspector.integrateQty-Tuple{Dict, Symbol}"><code>integrateQty</code></a> to compute their values at each time.</p><div class="admonition is-info" id="Note-9352f6b830b21fab"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9352f6b830b21fab" title="Permalink"></a></header><div class="admonition-body"><p>The log10 operation, if requested, is applied after the integration of the quantities.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>sim_data::Simulation</code>: The <a href="../../constants/globals/#GalaxyInspector.Simulation"><code>Simulation</code></a> struct for the target simulation.</li><li><code>x_quantity::Symbol</code>: Quantity for the x axis.</li><li><code>y_quantity::Symbol</code>: Quantity for the y axis.</li><li><code>trans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box</code>: How to translate and rotate the cells/particles, before filtering with <code>filter_mode</code>. For options see <a href="../transformations/#GalaxyInspector.selectTransformation-Tuple{Symbol, Dict{Symbol, Vector{String}}}"><code>selectTransformation</code></a>.</li><li><code>filter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all</code>: Which cells/particles will be selected. For options see <a href="../filters/#GalaxyInspector.selectFilter-Tuple{Symbol, Dict{Symbol, Vector{String}}}"><code>selectFilter</code></a>.</li><li><code>extra_filter::Function=filterNothing</code>: Filter function to be applied after <code>trans_mode</code> and <code>filter_mode</code> are applied. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li><li><code>ff_request::Dict{Symbol,Vector{String}}=Dict{Symbol,Vector{String}}()</code>: Request dictionary for <code>extra_filter</code>.</li><li><code>x_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for <code>x_quantity</code>, if you want to apply <span>$\log_{10}$</span> to the <code>x_quantity</code>. If set to <code>nothing</code>, the data from <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a> is left as is.</li><li><code>y_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for <code>y_quantity</code>, if you want to apply <span>$\log_{10}$</span> to the <code>y_quantity</code>. If set to <code>nothing</code>, the data from <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a> is left as is.</li><li><code>smooth::Int=0</code>: The result of <a href="../compute_quantities/aggregators/#GalaxyInspector.integrateQty-Tuple{Dict, Symbol}"><code>integrateQty</code></a> will be smoothed out using <code>smooth</code> bins. Set it to 0 if you want no smoothing.</li><li><code>cumulative::Bool=false</code>: If the <code>y_quantity</code> will be accumulated or not.</li><li><code>show_progress::Bool=true</code>: If a progress bar will be shown.</li></ul><p><strong>Returns</strong></p><ul><li><p>A Tuple with two elements:</p><ul><li>A Vector with the time series of <code>x_quantity</code>.</li><li>A Vector with the time series of <code>y_quantity</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L2118-L2153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daGasSFR2DProjection-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daGasSFR2DProjection-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol}"><code>GalaxyInspector.daGasSFR2DProjection</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daGasSFR2DProjection(
    data_dict::Dict,
    grid::CubicGrid,
    field_type::Symbol;
    &lt;keyword arguments&gt;
)::Tuple{Vector{&lt;:Unitful.Length},Vector{&lt;:Unitful.Length},VecOrMat{Float64}}</code></pre><p>Project the 3D gas SFR field into a given plane.</p><div class="admonition is-info" id="Note-eb564c15892e3ef4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-eb564c15892e3ef4" title="Permalink"></a></header><div class="admonition-body"><p>If the source of the field are particles, a simple 3D histogram is used. If they are Voronoi cells instead, the SFR of the cells that cross the line of sight of each pixel are added up.</p></div></div><p><strong>Arguments</strong></p><ul><li><p><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</p></li><li><p><code>grid::CubicGrid</code>: Cubic grid.</p></li><li><p><code>field_type::Symbol</code>: If the field is made up of <code>:particles</code> or Voronoi <code>:cells</code>.</p></li><li><p><code>projection_plane::Symbol=:xy</code>: Projection plane. The options are <code>:xy</code>, <code>:xz</code>, and <code>:yz</code>.</p></li><li><p><code>reduce_grid::Symbol=:square</code>: Type of 2D grid to do the final projection. The options are:</p><ul><li><code>:square</code>    -&gt; The sfr distribution will be projected into a regular square grid, with a resolution <code>reduce_factor</code> times lower than <code>grid</code>. <code>reduce_factor</code> = 1 means no reduction in resolution.</li><li><code>:circular</code> -&gt; The sfr distribution will be projected into a flat circular grid, formed by a series of <code>reduce_factor</code> concentric rings. <code>reduce_factor</code> = 1 means that the result will be a single point. Note that this behaves in the opposite way than <code>reduce_grid</code> = :square.</li><li><code>:log_circular</code> -&gt; The sfr distribution will be projected into a flat circular grid, formed by a series of <code>reduce_factor</code> concentric logarithmic rings. The first bin starts at 1e-3 of the radius. <code>reduce_factor</code> = 1 means that the result will be a single point. Note that this behaves in the opposite way than <code>reduce_grid</code> = :square.</li></ul></li><li><p><code>reduce_factor::Int=1</code>: Factor by which the resolution of the result will be reduced. This will be applied after the sfr projection. If <code>reduce_grid</code> = :square, the new values will be computed averaging the values of neighboring pixels. <code>reduce_factor</code> has to divide the size of <code>grid</code> exactly. If <code>reduce_grid</code> = :circular, the new values will be computed averaging the values of the pixels the fall within each of the <code>reduce_factor</code> concentric rings.</p></li><li><p><code>mmap_path::String=&quot;./&quot;</code>: Path to store the memory-mapped file if needed (for matrices larger than <a href="../../constants/globals/#GalaxyInspector.MMAP_THRESHOLD"><code>MMAP_THRESHOLD</code></a>).</p></li><li><p><code>m_unit::Unitful.Units=u&quot;Msun&quot;</code>: Mass unit.</p></li><li><p><code>t_unit::Unitful.Units=u&quot;yr&quot;</code>: Time unit.</p></li><li><p><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with three elements:</p><ul><li>A vector with the x coordinates of the grid.</li><li>A vector with the y coordinates of the grid.</li><li>A matrix or vector with the <span>$\log_{10}$</span> of the gas SFR at each bin of the 2D grid.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L1439-L1477">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daHistogram-Tuple{Dict, Symbol, GalaxyInspector.LinearGrid}"><a class="docstring-binding" href="#GalaxyInspector.daHistogram-Tuple{Dict, Symbol, GalaxyInspector.LinearGrid}"><code>GalaxyInspector.daHistogram</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daHistogram(
    data_dict::Dict,
    quantity::Symbol,
    grid::LinearGrid;
    &lt;keyword arguments&gt;
)::Union{Tuple{Vector{&lt;:Number},Vector{&lt;:Number}},Nothing}</code></pre><p>Compute a 1D histogram of a given <code>quantity</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>quantity::Symbol</code>: Target quantity. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a>.</li><li><code>grid::LinearGrid</code>: Linear grid.</li><li><code>log::Bool=false</code>: If the histogram bins will be logarithmic.</li><li><code>norm::Int=0</code>: Number of counts that will be use to normalize the histogram. If left as 0, the histogram will be normalize with the maximum bin count.</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with two elements:</p><ul><li>A vector with the value of <code>quantity</code> corresponding to each bin.</li><li>A vector with the counts.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L760-L785">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daHistogram-Tuple{Dict, Symbol, Int64}"><a class="docstring-binding" href="#GalaxyInspector.daHistogram-Tuple{Dict, Symbol, Int64}"><code>GalaxyInspector.daHistogram</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daHistogram(
    data_dict::Dict,
    quantity::Symbol,
    n_bins::Int;
    &lt;keyword arguments&gt;
)::Union{Tuple{Vector{&lt;:Number},Vector{&lt;:Number}},Nothing}</code></pre><p>Compute a 1D histogram of a given <code>quantity</code>.</p><div class="admonition is-info" id="Note-7adcc5def65a6313"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-7adcc5def65a6313" title="Permalink"></a></header><div class="admonition-body"><p>This method uses the extrema of the values of <code>quantity</code> as the range of the histogram.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>quantity::Symbol</code>: Target quantity. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a>.</li><li><code>n_bins::Int</code>: Number of bins.</li><li><code>log::Bool=false</code>: If the histogram bins will be logarithmic.</li><li><code>norm::Int=0</code>: Number of count that will be use to normalize the histogram. If left as 0, the histogram will be normalize with the maximum bin count.</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with two elements:</p><ul><li>A vector with the value of <code>quantity</code> corresponding to each bin.</li><li>A vector with the counts.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L882-L911">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daIntegrateGalaxy-Tuple{Dict, Symbol, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daIntegrateGalaxy-Tuple{Dict, Symbol, Symbol}"><code>GalaxyInspector.daIntegrateGalaxy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daIntegrateGalaxy(
    data_dict::Dict,
    x_quantity::Symbol,
    y_quantity::Symbol;
    &lt;keyword arguments&gt;
)::NTuple{2,Vector{&lt;:Number}}</code></pre><p>Compute two global quantities for the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>x_quantity::Symbol</code>: Quantity for the x axis. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.integrateQty-Tuple{Dict, Symbol}"><code>integrateQty</code></a>.</li><li><code>y_quantity::Symbol</code>: Quantity for the y axis. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.integrateQty-Tuple{Dict, Symbol}"><code>integrateQty</code></a>.</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with two elements:</p><ul><li>A single element vector with the value of <code>x_quantity</code>.</li><li>A single element vector with the value of <code>y_quantity</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L94-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daMetallicity2DProjection-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daMetallicity2DProjection-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol, Symbol}"><code>GalaxyInspector.daMetallicity2DProjection</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daMetallicity2DProjection(
    data_dict::Dict,
    grid::CubicGrid,
    component::Symbol,
    field_type::Symbol;
    &lt;keyword arguments&gt;
)::Tuple{Vector{&lt;:Unitful.Length},Vector{&lt;:Unitful.Length},VecOrMat{Float64}}</code></pre><p>Project the 3D metallicity field to a given plane.</p><div class="admonition is-info" id="Note-66e4de7ba9b57fb2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-66e4de7ba9b57fb2" title="Permalink"></a></header><div class="admonition-body"><p>If <code>element</code> = :all, the total metallicity (in solar units) is computed. If <code>element</code> = :X, the abundance of element X is computed, <a href="../../constants/globals/#GalaxyInspector.ABUNDANCE_SHIFT"><code>ABUNDANCE_SHIFT</code></a> + ``\log_{10}(X/H). In both cases the total value of the column given by the line of sight of each pixel is computed.</p></div></div><p><strong>Arguments</strong></p><ul><li><p><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</p></li><li><p><code>grid::CubicGrid</code>: Cubic grid.</p></li><li><p><code>component::Symbol</code>: Target component. It can be either <code>:stellar</code> or <code>:gas</code>.</p></li><li><p><code>field_type::Symbol</code>: If the field is made up of <code>:particles</code> or Voronoi <code>:cells</code>.</p></li><li><p><code>element::Symbol=:all</code>: Target element. The possibilities are the keys of <a href="../../constants/arepo/#GalaxyInspector.ELEMENT_INDEX"><code>ELEMENT_INDEX</code></a>. Set it to :all if you want the total metallicity.</p></li><li><p><code>projection_plane::Symbol=:xy</code>: Projection plane. The options are <code>:xy</code>, <code>:xz</code>, and <code>:yz</code>.</p></li><li><p><code>reduce_grid::Symbol=:square</code>: Type of 2D grid to do the final projection. The options are:</p><ul><li><code>:square</code>    -&gt; The metallicity distribution will be projected into a regular square grid, with a resolution <code>reduce_factor</code> times lower than <code>grid</code>. <code>reduce_factor</code> = 1 means no reduction in resolution.</li><li><code>:circular</code> -&gt; The metallicity distribution will be projected into a flat circular grid, formed by a series of <code>reduce_factor</code> concentric rings. <code>reduce_factor</code> = 1 means that the result will be a single point. Note that this behaves in the opposite way than <code>reduce_grid</code> = :square.</li><li><code>:log_circular</code> -&gt; The metallicity distribution will be projected into a flat circular grid, formed by a series of <code>reduce_factor</code> concentric logarithmic rings. The first bin starts at 1e-3 of the radius. <code>reduce_factor</code> = 1 means that the result will be a single point. Note that this behaves in the opposite way than <code>reduce_grid</code> = :square.</li></ul></li><li><p><code>reduce_factor::Int=1</code>: Factor by which the resolution of the result will be reduced. This will be applied after the metallicity projection. If <code>reduce_grid</code> = :square, the new values will be computed averaging the values of neighboring pixels. <code>reduce_factor</code> has to divide the size of <code>grid</code> exactly. If <code>reduce_grid</code> = :circular, the new values will be computed averaging the values of the pixels the fall within each of the <code>reduce_factor</code> concentric rings.</p></li><li><p><code>mmap_path::String=&quot;./&quot;</code>: Path to store the memory-mapped file if needed (for matrices larger than <a href="../../constants/globals/#GalaxyInspector.MMAP_THRESHOLD"><code>MMAP_THRESHOLD</code></a>).</p></li><li><p><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with three elements:</p><ul><li>A vector with the x coordinates of the grid.</li><li>A vector with the y coordinates of the grid.</li><li>A matrix or vector with the <span>$\log_{10}$</span> of the metallicity at each bin of the 2D grid.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L1594-L1633">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daMolla2015-Tuple{Dict, GalaxyInspector.LinearGrid, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daMolla2015-Tuple{Dict, GalaxyInspector.LinearGrid, Symbol}"><code>GalaxyInspector.daMolla2015</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daMolla2015(
    data_dict::Dict,
    grid::LinearGrid,
    quantity::Symbol;
    &lt;keyword arguments&gt;
)::Union{
    Tuple{
        Vector{&lt;:Unitful.Length},
        &lt;:Union{Vector{&lt;:SurfaceDensity},Vector{&lt;:MassFlowDensity},Vector{Float64}}
    },
    Nothing,
}</code></pre><p>Compute a profile for the Milky Way, compatible with the experimental data in Mollá et al. (2015).</p><p><strong>Arguments</strong></p><ul><li><p><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</p></li><li><p><code>grid::LinearGrid</code>: Linear grid.</p></li><li><p><code>quantity::Symbol</code>: Quantity for the y axis. The options are:</p><ul><li><code>:stellar_area_density</code>               -&gt; Stellar mass surface density.</li><li><code>:sfr_area_density</code>                   -&gt; Star formation rate surface density.</li><li><code>:ode_molecular_stellar_area_density</code> -&gt; Molecular mass surface density.</li><li><code>:br_molecular_area_density</code>          -&gt; Molecular mass surface density, computed using the pressure relation in Blitz et al. (2006).</li><li><code>:ode_atomic_area_density</code>            -&gt; Atomic mass surface density.</li><li><code>:br_atomic_area_density</code>             -&gt; Atomic mass surface density, computed using the pressure relation in Blitz et al. (2006).</li><li><code>:O_stellar_abundance</code>                -&gt; Stellar abundance of oxygen, as <span>$12 + \log_{10}(\mathrm{O \, / \, H})$</span>.</li><li><code>:N_stellar_abundance</code>                -&gt; Stellar abundance of nitrogen, as <span>$12 + \log_{10}(\mathrm{N \, / \, H})$</span>.</li><li><code>:C_stellar_abundance</code>                -&gt; Stellar abundance of carbon, as <span>$12 + \log_{10}(\mathrm{C \, / \, H})$</span>.</li></ul></li><li><p><code>y_unit::Unitful.Units=Unitful.NoUnits</code>: Unit for <code>quantity</code>.</p></li><li><p><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with two elements:</p><ul><li>A vector with the position of each ring.</li><li>A vector with the value <code>quantity</code> in each ring.</li></ul><p>It returns <code>nothing</code> if any of the necessary quantities are missing.</p></li></ul><p><strong>References</strong></p><p>L. Blitz et al. (2006). <em>The Role of Pressure in GMC Formation II: The H2-Pressure Relation</em>. The Astrophysical Journal, <strong>650(2)</strong>, 933. <a href="https://doi.org/10.1086/505417">doi:10.1086/505417</a></p><p>M. Mollá et al. (2015). <em>Galactic chemical evolution: stellar yields and the initial mass function</em>. Monthly Notices of the Royal Astronomical Society <strong>451(4)</strong>, 3693–3708. <a href="https://doi.org/10.1093/mnras/stv1102">doi:10.1093/mnras/stv1102</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L1161-L1209">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daProfile-Tuple{Dict, Symbol, GalaxyInspector.LinearGrid}"><a class="docstring-binding" href="#GalaxyInspector.daProfile-Tuple{Dict, Symbol, GalaxyInspector.LinearGrid}"><code>GalaxyInspector.daProfile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daProfile(
    data_dict::Dict,
    quantity::Symbol,
    grid::LinearGrid;
    &lt;keyword arguments&gt;
)::Union{Tuple{Vector{&lt;:Unitful.Length},Vector{&lt;:Number}},Nothing}</code></pre><p>Compute a profile.</p><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>quantity::Symbol</code>: Target quantity. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a>.</li><li><code>grid::LinearGrid</code>: Linear grid.</li><li><code>norm::Union{Symbol,Nothing}=nothing</code>: The value of <code>quantity</code> in each bin will be divided by the corresponding value of <code>norm</code>. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a>. If set to <code>nothing</code>, no operation is applied.</li><li><code>y_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for <code>quantity</code>, if you want to apply <span>$\log_{10}$</span> to <code>quantity</code>. If set to <code>nothing</code>, the data is left as is.</li><li><code>flat::Bool=true</code>: If the profile will be 2D (rings), or 3D (spherical shells).</li><li><code>total::Bool=true</code>: If the sum (default) or the mean of <code>quantity</code> will be computed for each bin. This affects the values of <code>norm</code> too.</li><li><code>cumulative::Bool=false</code>: If the profile will be accumulated (after dividing by <code>norm</code>).</li><li><code>density::Bool=false</code>: If the profile will be of the density of <code>quantity</code> (after dividing by <code>norm</code>).</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with two elements:</p><ul><li>A vector with the position of each ring or spherical shells.</li><li>A vector with the value of <code>quantity</code> in each each ring or spherical shells.</li></ul><p>It returns <code>nothing</code> if any of the necessary quantities are missing.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L397-L428">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daRotationCurve-Tuple{Dict}"><a class="docstring-binding" href="#GalaxyInspector.daRotationCurve-Tuple{Dict}"><code>GalaxyInspector.daRotationCurve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daRotationCurve(
    data_dict::Dict;
    &lt;keyword arguments&gt;
)::Tuple{Vector{&lt;:Unitful.Length},Vector{&lt;:Unitful.Velocity}}</code></pre><p>Compute a rotation curve.</p><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>R::Unitful.Length=DISK_R</code>: Maximum radial distance for the rotation curve.</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with two elements:</p><ul><li>A vector with the distances to each star.</li><li>A vector with the circular velocity of each star.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L1013-L1033">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daSDSSMockup-Tuple{Dict, GalaxyInspector.CubicGrid}"><a class="docstring-binding" href="#GalaxyInspector.daSDSSMockup-Tuple{Dict, GalaxyInspector.CubicGrid}"><code>GalaxyInspector.daSDSSMockup</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daSDSSMockup(
    data_dict::Dict,
    grid::CubicGrid;
    &lt;keyword arguments&gt;
)::Array</code></pre><p>Compute a mockup image emulating an SDSS observation.</p><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>grid::CubicGrid</code>: Cubic grid.</li><li><code>projection_plane::Symbol=:xy</code>: Projection plane. The options are <code>:xy</code>, <code>:xz</code>, and <code>:yz</code>.</li><li><code>smooth::Bool=false</code>: If gaussian smooththing will be applied to the whole image.</li><li><code>extinction::Bool=true</code>: If true, the extinction due to the neutral gas in front of each star will be applied.</li><li><code>mmap_path::String=&quot;./&quot;</code>: Path to store the memory-mapped file if needed (for matrices larger than <a href="../../constants/globals/#GalaxyInspector.MMAP_THRESHOLD"><code>MMAP_THRESHOLD</code></a>).</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li></ul><p><strong>Returns</strong></p><ul><li>An RGB image with the mock observation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L1907-L1929">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daSFRtxt-Tuple{GalaxyInspector.Simulation, Symbol, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daSFRtxt-Tuple{GalaxyInspector.Simulation, Symbol, Symbol}"><code>GalaxyInspector.daSFRtxt</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daSFRtxt(
    sim_data::Simulation,
    x_quantity::Symbol,
    y_quantity::Symbol;
    &lt;keyword arguments&gt;
)::NTuple{2,Vector{&lt;:Number}}</code></pre><p>Compute the stellar mass or SFR evolution using the data in the <code>sfr.txt</code> file.</p><p><strong>Arguments</strong></p><ul><li><p><code>sim_data::Simulation</code>: The <a href="../../constants/globals/#GalaxyInspector.Simulation"><code>Simulation</code></a> struct for the target simulation.</p></li><li><p><code>x_quantity::Symbol</code>: Quantity for the x axis. The options are:</p><ul><li><code>:scale_factor</code>  -&gt; Scale factor.</li><li><code>:redshift</code>      -&gt; Redshift.</li><li><code>:physical_time</code> -&gt; Physical time since the Big Bang.</li><li><code>:lookback_time</code> -&gt; Physical time left to reach the last snapshot.</li></ul></li><li><p><code>y_quantity::Symbol</code>: Quantity for the y axis. The options are:</p><ul><li><code>:stellar_mass</code> -&gt; Cumulative stellar mass.</li><li><code>:sfr</code>          -&gt; Star formation rate.</li></ul></li><li><p><code>smooth::Int=0</code>: The result will be smoothed out using <code>smooth</code> bins. Set it to 0 if you want no smoothing.</p></li></ul><p><strong>Returns</strong></p><ul><li><p>A Tuple with two elements:</p><ul><li>A Vector with the time series of <code>x_quantity</code>.</li><li>A Vector with the time series of <code>y_quantity</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L2363-L2394">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daScatterDensity-Tuple{Dict, Symbol, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daScatterDensity-Tuple{Dict, Symbol, Symbol}"><code>GalaxyInspector.daScatterDensity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daScatterDensity(
    data_dict::Dict,
    x_quantity::Symbol,
    y_quantity::Symbol;
    &lt;keyword arguments&gt;
)::Tuple{Vector{&lt;:Number},Vector{&lt;:Number},Matrix{Float64}}</code></pre><p>Compute two quantities for every cell/particle using a 2D histogram.</p><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>x_quantity::Symbol</code>: Quantity for the x axis. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a>.</li><li><code>y_quantity::Symbol</code>: Quantity for the y axis. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a>.</li><li><code>x_range::Union{NTuple{2,&lt;:Number},Nothing}=nothing</code>: x axis range for the histogram grid. If set to <code>nothing</code>, the extrema of the values will be used.</li><li><code>y_range::Union{NTuple{2,&lt;:Number},Nothing}=nothing</code>: y axis range for the histogram grid. If set to <code>nothing</code>, the extrema of the values will be used.</li><li><code>x_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for <code>x_quantity</code>, if you want to apply <span>$\log_{10}$</span> to the <code>x_quantity</code>. If set to <code>nothing</code>, the data from <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a> is left as is.</li><li><code>y_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for <code>y_quantity</code>, if you want to apply <span>$\log_{10}$</span> to the <code>y_quantity</code>. If set to <code>nothing</code>, the data from <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a> is left as is.</li><li><code>n_bins::Int=100</code>: Number of bins per side of the grid.</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with three elements:</p><ul><li>A vector with the x coordinates of the grid.</li><li>A vector with the y coordinates of the grid.</li><li>A matrix with the the <span>$\log_{10}$</span> of the counts in each bin.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L131-L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daScatterGalaxy-Tuple{Dict, Symbol, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daScatterGalaxy-Tuple{Dict, Symbol, Symbol}"><code>GalaxyInspector.daScatterGalaxy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daScatterGalaxy(
    data_dict::Dict,
    x_quantity::Symbol,
    y_quantity::Symbol;
    &lt;keyword arguments&gt;
)::NTuple{2,Vector{&lt;:Number}}</code></pre><p>Compute two quantities for every cell/particle in the simulation using <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>x_quantity::Symbol</code>: Quantity for the x axis. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a>.</li><li><code>y_quantity::Symbol</code>: Quantity for the y axis. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a>.</li><li><code>x_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for <code>x_quantity</code>, if you want to apply <span>$\log_{10}$</span> to the <code>x_quantity</code>. If set to <code>nothing</code>, the data from <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a> is left as is.</li><li><code>y_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for <code>y_quantity</code>, if you want to apply <span>$\log_{10}$</span> to the <code>y_quantity</code>. If set to <code>nothing</code>, the data from <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a> is left as is.</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with two elements:</p><ul><li>A vector with the values of <code>x_quantity</code>.</li><li>A vector with the values of <code>y_quantity</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L25-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daScatterWeightedDensity-Tuple{Dict, Symbol, Symbol, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daScatterWeightedDensity-Tuple{Dict, Symbol, Symbol, Symbol}"><code>GalaxyInspector.daScatterWeightedDensity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daScatterWeightedDensity(
    data_dict::Dict,
    x_quantity::Symbol,
    y_quantity::Symbol,
    z_quantity::Symbol;
    &lt;keyword arguments&gt;
)::Tuple{Vector{&lt;:Number},Vector{&lt;:Number},Matrix{Float64}}</code></pre><p>Compute two quantities for every cell/particle using a 2D histogram, weighted by <code>z_quantity</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>x_quantity::Symbol</code>: Quantity for the x axis. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a>.</li><li><code>y_quantity::Symbol</code>: Quantity for the y axis. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a>.</li><li><code>z_quantity::Symbol</code>: Quantity for the weights. It can be any of the quantities valid for <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a>.</li><li><code>x_range::Union{NTuple{2,&lt;:Number},Nothing}=nothing</code>: x axis range. If set to <code>nothing</code>, the extrema of the values will be used.</li><li><code>y_range::Union{NTuple{2,&lt;:Number},Nothing}=nothing</code>: y axis range. If set to <code>nothing</code>, the extrema of the values will be used.</li><li><code>x_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for <code>x_quantity</code>, if you want to apply <span>$\log_{10}$</span> to the <code>x_quantity</code>. If set to <code>nothing</code>, the data from <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a> is left as is.</li><li><code>y_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for <code>y_quantity</code>, if you want to apply <span>$\log_{10}$</span> to the <code>y_quantity</code>. If set to <code>nothing</code>, the data from <a href="../compute_quantities/aggregators/#GalaxyInspector.scatterQty-Tuple{Dict, Symbol}"><code>scatterQty</code></a> is left as is.</li><li><code>total::Bool=true</code>: If the sum (default) or the mean of <code>z_quantity</code> will be used as the value of each bin.</li><li><code>n_bins::Int=100</code>: Number of bins per side of the grid.</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with three elements:</p><ul><li>A vector with the x coordinates of the grid.</li><li>A vector with the y coordinates of the grid.</li><li>A matrix with the <span>$\log_{10}$</span> of <code>z_quantity</code> for each bin.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L252-L284">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daStellarHistory-Tuple{Dict}"><a class="docstring-binding" href="#GalaxyInspector.daStellarHistory-Tuple{Dict}"><code>GalaxyInspector.daStellarHistory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daStellarHistory(
    data_dict::Dict;
    &lt;keyword arguments&gt;
)::Union{Tuple{Vector{&lt;:Unitful.Time},Vector{&lt;:Number}},Nothing}</code></pre><p>Compute the evolution of a given stellar <code>quantity</code> using the stellar ages at a given instant in time.</p><p><strong>Arguments</strong></p><ul><li><p><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</p></li><li><p><code>quantity::Symbol=:sfr</code>: Target quantity. The options are:</p><ul><li><code>:sfr</code>                 -&gt; Star formation rate.</li><li><code>:ssfr</code>                -&gt; The specific star formation rate.</li><li><code>:stellar_mass</code>        -&gt; Stellar mass.</li><li><code>:stellar_metallicity</code> -&gt; Mass fraction of all elements above He in the stars (solar units).</li></ul></li><li><p><code>n_bins::Int=100</code>: Number of bins (time intervals).</p></li><li><p><code>ylog::Bool=false</code>: If true, returns <span>$\log_{10}$</span>(<code>quantity</code>).</p></li><li><p><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with two elements:</p><ul><li>A vector with the physical times.</li><li>A vector with the values of <code>quantity</code> at each time.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L629-L656">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daTrajectory-Tuple{String, Vector{&lt;:Unsigned}, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daTrajectory-Tuple{String, Vector{&lt;:Unsigned}, Symbol}"><code>GalaxyInspector.daTrajectory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daTrajectory(
    simulation_path::String,
    target_ids::Vector{&lt;:Unsigned},
    cp_type::Symbol;
    &lt;keyword arguments&gt;
)::Dict{UInt64,Matrix{Quantity}}</code></pre><p>Compute the trajectory of a set of cells/particles, given their IDs.</p><p><strong>Arguments</strong></p><ul><li><code>simulation_path::String</code>: Path to the simulation directory, set in the code variable <code>OutputDir</code>.</li><li><code>target_ids::Vector{&lt;:Unsigned}</code>: IDs of the cells/particles whose trajectories will be computed.</li><li><code>cp_type::Symbol</code>: Target type of cell/particle. The possibilities are the keys of <a href="../../constants/arepo/#GalaxyInspector.PARTICLE_INDEX"><code>PARTICLE_INDEX</code></a>.</li><li><code>trans_mode::Union{Symbol,Tuple{TranslationType,RotationType,Dict{Symbol,Vector{String}}}}=:all_box</code>: How to translate and rotate the cells/particles, before filtering with <code>filter_mode</code>. For options see <a href="../transformations/#GalaxyInspector.selectTransformation-Tuple{Symbol, Dict{Symbol, Vector{String}}}"><code>selectTransformation</code></a>.</li><li><code>filter_mode::Union{Symbol,Tuple{Function,Dict{Symbol,Vector{String}}}}=:all</code>: Which cells/particles will be selected. For options see <a href="../filters/#GalaxyInspector.selectFilter-Tuple{Symbol, Dict{Symbol, Vector{String}}}"><code>selectFilter</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><p>A dictionary with the following shape:</p><ul><li><p><code>target_id::UInt64</code> -&gt; A matrix with the trajectory of the cell/particle with ID <code>target_id</code>. The matrix has 7 rows, where:</p><ul><li>Row 1: Physical time.</li><li>Rows 2-4: Position [x, y, z].</li><li>Rows 5-7: Velocity [vx, vy, vz].</li></ul></li></ul><p>If the target ID is not found at a given physical time the position and velocity are NaN.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L3483-L3512">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daVSFLaw-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daVSFLaw-Tuple{Dict, GalaxyInspector.CubicGrid, Symbol}"><code>GalaxyInspector.daVSFLaw</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daVSFLaw(
    data_dict::Dict,
    grid::CubicGrid,
    component::Symbol;
    &lt;keyword arguments&gt;
)::Union{NTuple{2,Vector{&lt;:Float64}},Nothing}</code></pre><p>Compute the gas density and the SFR density, used in the volumetric star formation (VSF) law.</p><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>grid::CubicGrid</code>: Cubic grid.</li><li><code>component::Symbol</code>: Target component. It can only be one of the elements of <a href="../../constants/quantities/#GalaxyInspector.COMPONENTS"><code>COMPONENTS</code></a>.</li><li><code>field_type::Symbol=:cells</code>: If the gas surface density will be calculated assuming the gas is in <code>:particles</code> or in Voronoi <code>:cells</code>.</li><li><code>age_limit::Unitful.Time=AGE_RESOLUTION</code>: Age limit for the SFR.</li><li><code>stellar_ff::Function=filterNothing</code>: Filter function for the stars. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li><li><code>gas_ff::Function=filterNothing</code>: Filter function for the gas. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li><li><code>mmap_path::String=&quot;./&quot;</code>: Path to store the memory-mapped file if needed (for matrices larger than <a href="../../constants/globals/#GalaxyInspector.MMAP_THRESHOLD"><code>MMAP_THRESHOLD</code></a>).</li><li><code>m_unit::Unitful.Units=u&quot;Msun&quot;</code>: Target mass unit.</li><li><code>t_unit::Unitful.Units=u&quot;yr&quot;</code>: Target time unit.</li><li><code>l_gas_unit::Unitful.Units=u&quot;pc&quot;</code>: Target length unit for the gas density.</li><li><code>l_stellar_unit::Unitful.Units=u&quot;kpc&quot;</code>: Target length unit for the SFR density.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with two elements:</p><ul><li>A vector with <span>$\log_{10}(\rho_\mathrm{H} \, / \, \mathrm{M_\odot \, pc^{-3}})$</span></li><li>A vector with <span>$\log_{10}(\rho_\mathrm{SFR} \, / \, \mathrm{M_\odot \, yr^{-1} \, kpc^{-3}})$</span></li></ul><p>It returns <code>nothing</code> if any of the necessary quantities are missing.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L3202-L3235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daVelocityField-Tuple{Dict, GalaxyInspector.SquareGrid, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daVelocityField-Tuple{Dict, GalaxyInspector.SquareGrid, Symbol}"><code>GalaxyInspector.daVelocityField</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daVelocityField(
    data_dict::Dict,
    grid::SquareGrid,
    component::Symbol;
    &lt;keyword arguments&gt;
)::Tuple{Vector{&lt;:Unitful.Length},Vector{&lt;:Unitful.Length},Matrix{Float64},Matrix{Float64}}</code></pre><p>Project a 3D velocity field into a given plane.</p><div class="admonition is-info" id="Note-b76448e1aef45ea1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b76448e1aef45ea1" title="Permalink"></a></header><div class="admonition-body"><p>This function computes the mean velocity in each direction of the target plane, at each pixel of the grid, using an 2D histogram. For low resolution grids, the result its the same even for a field made of cells, while being much facter and simpler that the full Voronoi rasterisation.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>data_dict::Dict</code>: Data dictionary (see <a href="../data_acquisition/#GalaxyInspector.makeDataDict-Tuple{String, Int64, Dict{Symbol, Vector{String}}, DataFrames.DataFrame}"><code>makeDataDict</code></a> for the canonical description).</li><li><code>grid::SquareGrid</code>: Square grid.</li><li><code>component::Symbol</code>: Target component. It can only be one of the elements of <a href="../../constants/quantities/#GalaxyInspector.COMPONENTS"><code>COMPONENTS</code></a>.</li><li><code>projection_plane::Symbol=:xy</code>: Projection plane. The options are <code>:xy</code>, <code>:xz</code>, and <code>:yz</code>.</li><li><code>v_unit::Unitful.Units=u&quot;km * s^-1&quot;</code>: Velocity unit</li><li><code>filter_function::Function=filterNothing</code>: Filter function to be applied to <code>data_dict</code> before any other computation. See the required signature and examples in <code>./src/analysis/filters.jl</code>.</li></ul><p><strong>Returns</strong></p><ul><li><p>A tuple with four elements:</p><ul><li>A vector with the x coordinates of the grid.</li><li>A vector with the y coordinates of the grid.</li><li>A matrix with the mean velocity in the x direction at each grid point.</li><li>A matrix with the mean velocity in the y direction at each grid point.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L1821-L1852">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GalaxyInspector.daVirialAccretion-Tuple{GalaxyInspector.Simulation, Symbol}"><a class="docstring-binding" href="#GalaxyInspector.daVirialAccretion-Tuple{GalaxyInspector.Simulation, Symbol}"><code>GalaxyInspector.daVirialAccretion</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">daVirialAccretion(
    sim_data::Simulation;
    &lt;keyword arguments&gt;
)::NTuple{2,Vector{&lt;:Number}}</code></pre><p>Compute the evolution of the accreted mass into a sphere with the virial radius.</p><p><strong>Arguments</strong></p><ul><li><p><code>sim_data::Simulation</code>: The <a href="../../constants/globals/#GalaxyInspector.Simulation"><code>Simulation</code></a> struct for the target simulation.</p></li><li><p><code>component::Symbol</code>: Component to compute the accreted mass for. The options are:</p><ul><li><code>:dark_matter</code> -&gt; Dark matter.</li><li><code>:black_hole</code>  -&gt; Black holes.</li><li><code>:gas</code>         -&gt; Gas.</li><li><code>:stellar</code>     -&gt; Stars.</li><li><code>:all</code>         -&gt; All the matter.</li></ul></li><li><p><code>flux_direction::Symbol=:net</code>: What flux direction will be plotted. The options are:</p><ul><li><code>:net</code>     -&gt; Net accreted mass.</li><li><code>:inflow</code>  -&gt; Inflow mass only.</li><li><code>:outflow</code> -&gt; Outflow mass only.</li></ul></li><li><p><code>halo_idx::Int=1</code>: Index of the target halo (FoF group). Starts at 1.</p></li><li><p><code>trace::Symbol=:automatic</code>: How to trace the mass. The option are:</p><ul><li><code>:automatic</code> -&gt; Automatically decide whether to use tracers or not. It will use tracers for the :gas component, and the particles for every other component.</li><li><code>:tracers</code>   -&gt; Use tracers to compute the mass flux.</li><li><code>:particles</code> -&gt; Use the particles/cells directly to compute the mass flux.</li></ul></li><li><p><code>y_log::Union{Unitful.Units,Nothing}=nothing</code>: Target unit for integrated mass flux, if you want to apply <span>$\log_{10}$</span> to it. If set to <code>nothing</code>, the data from <a href="../compute_quantities/masses/#GalaxyInspector.computeVirialAccretion-Tuple{Dict, Dict, Symbol}"><code>computeVirialAccretion</code></a> is left as is.</p></li><li><p><code>smooth::Int=0</code>: The time series will be smoothed out using <code>smooth</code> bins. Set it to 0 if you want no smoothing.</p></li><li><p><code>show_progress::Bool=true</code>: If a progress bar will be shown.</p></li></ul><p><strong>Returns</strong></p><ul><li><p>A Tuple with two elements:</p><ul><li>A Vector with the physical times.</li><li>A Vector with the accreted mass at each time.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Ezequiel92/GalaxyInspector/blob/dfd88a89865404c5c1109e03ffc5af2bb71177e8/src/analysis/data_analysis.jl#L2663-L2702">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../constants/arepo/">« Arepo constants</a><a class="docs-footer-nextpage" href="../data_acquisition/">Data acquisition functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 29 January 2026 18:36">Thursday 29 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
